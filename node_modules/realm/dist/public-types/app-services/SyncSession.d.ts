import type { App } from "./App";
import { type SyncConfiguration } from "./SyncConfiguration";
import { User } from "./User";
/**
 * The progress direction to register the progress notifier for.
 */
export declare enum ProgressDirection {
    /**
     * Data going from the server to the client.
     */
    Download = "download",
    /**
     * Data going from the client to the server.
     */
    Upload = "upload"
}
/**
 * The progress notification mode to register the progress notifier for.
 */
export declare enum ProgressMode {
    /**
     * The registration will stay active until the callback is unregistered.
     */
    ReportIndefinitely = "reportIndefinitely",
    /**
     * The registration will be active until only the currently transferable bytes are synced.
     */
    ForCurrentlyOutstandingWork = "forCurrentlyOutstandingWork"
}
/**
 * A progress notification callback supporting Partition-Based Sync only.
 * @param transferred - The current number of bytes already transferred.
 * @param transferable - The total number of transferable bytes (i.e. the number of bytes already transferred plus the number of bytes pending transfer).
 * @deprecated - Will be removed in a future major version. Please use {@link EstimateProgressNotificationCallback} instead.
 * @since 1.12.0
 */
export type PartitionBasedSyncProgressNotificationCallback = (transferred: number, transferable: number) => void;
/**
 * A progress notification callback for Atlas Device Sync.
 * @param estimate - An estimate between 0.0 and 1.0 of how much have been transferred.
 */
export type EstimateProgressNotificationCallback = (estimate: number) => void;
/**
 * A callback that will be called when the synchronization progress gets updated.
 */
export type ProgressNotificationCallback = EstimateProgressNotificationCallback | PartitionBasedSyncProgressNotificationCallback;
export declare enum ConnectionState {
    Disconnected = "disconnected",
    Connecting = "connecting",
    Connected = "connected"
}
export type ConnectionNotificationCallback = (newState: ConnectionState, oldState: ConnectionState) => void;
export declare enum SessionState {
    /**
     * The sync session encountered a non-recoverable error and is permanently invalid. Create a new Session to continue syncing.
     */
    Invalid = "invalid",
    /**
     * The sync session is actively communicating or attempting to communicate with Atlas App Services. A session may be considered active even if it is not currently connected. To find out if a session is online, check its connection state.
     */
    Active = "active",
    /**
     * The sync session is not attempting to communicate with Atlas App Services due to the user logging out or synchronization being paused.
     */
    Inactive = "inactive"
}
export declare class SyncSession {
    /**
     * Gets the Sync-part of the configuration that the corresponding Realm was constructed with.
     */
    get config(): SyncConfiguration;
    /**
     * Gets the current state of the session.
     */
    get state(): SessionState;
    /**
     * Gets the URL of the Realm Object Server that this session is connected to.
     */
    get url(): string;
    /**
     * Gets the User that this session was created with.
     */
    get user(): User<import("./FunctionsFactory").DefaultFunctionsFactory, import("../namespace").DefaultObject, import("./UserProfile").DefaultUserProfileData>;
    /**
     * Gets the current state of the connection to the server. Multiple sessions might share the same underlying
     * connection. In that case, any connection change is sent to all sessions.
     *
     * Data will only be synchronized with the server if this method returns `Connected` and `state()` returns `Active` or `Dying`.
     */
    get connectionState(): App.Sync.ConnectionState;
    /**
     * Returns `true` if the session is currently active and connected to the server, `false` if not.
     */
    isConnected(): boolean;
    /**
     * Pause a sync session.
     *
     * This method is asynchronous so in order to know when the session has started you will need
     * to add a connection notification with {@link SyncSession.addConnectionNotification | addConnectionNotification}.
     *
     * This method is idempotent so it will be a no-op if the session is already paused or if multiplexing
     * is enabled.
     * @since 2.16.0-rc.2
     */
    pause(): void;
    /**
     * Resumes a sync session that has been paused.
     *
     * This method is asynchronous so in order to know when the session has started you will need
     * to add a connection notification with {@link SyncSession.addConnectionNotification | addConnectionNotification}.
     *
     * This method is idempotent so it will be a no-op if the session is already started or if multiplexing
     * is enabled.
     * @since 2.16.0-rc.2
     */
    resume(): void;
    /**
     * Reconnects to Atlas Device Sync.
     *
     * This method is asynchronous so in order to know when the session has started you will need
     * to add a connection notification with {@link SyncSession.addConnectionNotification | addConnectionNotification}.
     *
     * This method is idempotent so it will be a no-op if the session is already started.
     * @since 12.2.0
     */
    reconnect(): void;
    /**
     * Register a progress notification callback on a session object.
     * @param direction - The progress direction to register for.
     * @param mode - The progress notification mode to use for the registration.
     * @param callback - The function to call when the progress gets updated.
     * @since 1.12.0
     */
    addProgressNotification(direction: ProgressDirection, mode: ProgressMode, callback: ProgressNotificationCallback): void;
    /**
     * Unregister a progress notification callback that was previously registered with {@link SyncSession.addProgressNotification | addProgressNotification}.
     * Calling the function multiple times with the same callback is ignored.
     * @param callback - A previously registered progress callback.
     * @since 1.12.0
     */
    removeProgressNotification(callback: ProgressNotificationCallback): void;
    /**
     * Registers a connection notification on the session object. This will be notified about changes to the
     * underlying connection to the Realm Object Server.
     * @param callback - Called with the following arguments:
     * 1. `newState`: The new state of the connection
     * 2. `oldState`: The state the connection transitioned from.
     * @since 2.15.0
     */
    addConnectionNotification(callback: ConnectionNotificationCallback): void;
    /**
     * Unregister a state notification callback that was previously registered with addStateNotification.
     * Calling the function multiple times with the same callback is ignored.
     * @param callback - A previously registered state callback.
     * @since 2.15.0
     */
    removeConnectionNotification(callback: ConnectionNotificationCallback): void;
    /**
     * This method returns a promise that does not resolve successfully until all known remote changes have been
     * downloaded and applied to the Realm or the specified timeout is hit in which case it will be rejected. If the method
     * times out, the download will still continue in the background.
     *
     * This method cannot be called before the Realm has been opened.
     * @param timeoutMs - maximum amount of time to wait in milliseconds before the promise will be rejected. If no timeout
     * is specified the method will wait forever.
     */
    downloadAllServerChanges(timeoutMs?: number): Promise<void>;
    /**
     * This method returns a promise that does not resolve successfully until all known local changes have been uploaded
     * to the server or the specified timeout is hit in which case it will be rejected. If the method times out, the upload
     * will still continue in the background.
     *
     * This method cannot be called before the Realm has been opened.
     * @param timeoutMs - Maximum amount of time to wait in milliseconds before the promise is rejected. If no timeout is specified the method will wait forever.
     */
    uploadAllLocalChanges(timeoutMs?: number): Promise<void>;
}
//# sourceMappingURL=SyncSession.d.ts.map