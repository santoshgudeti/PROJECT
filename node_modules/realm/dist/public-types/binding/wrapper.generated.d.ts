import { Decimal128, ObjectId, UUID } from "bson";
import * as utils from "./utils";
import "./patch";
export declare namespace binding {
    const enum SchemaMode {
        Automatic = 0,
        Immutable = 1,
        ReadOnly = 2,
        SoftResetFile = 3,
        HardResetFile = 4,
        AdditiveDiscovered = 5,
        AdditiveExplicit = 6,
        Manual = 7
    }
    const enum PropertyType {
        Int = 0,
        Bool = 1,
        String = 2,
        Data = 3,
        Date = 4,
        Float = 5,
        Double = 6,
        Object = 7,
        LinkingObjects = 8,
        Mixed = 9,
        ObjectId = 10,
        Decimal = 11,
        Uuid = 12,
        Required = 0,
        Nullable = 64,
        Array = 128,
        Set = 256,
        Dictionary = 512,
        Collection = 896,
        Flags = 960
    }
    const enum CollectionType {
        List = 19,
        Set = 20,
        Dictionary = 21
    }
    const enum TableType {
        TopLevel = 0,
        Embedded = 1,
        TopLevelAsymmetric = 2
    }
    const enum DataType {
        Int = 0,
        Bool = 1,
        String = 2,
        Binary = 4,
        Mixed = 6,
        Timestamp = 8,
        Float = 9,
        Double = 10,
        Decimal = 11,
        Link = 12,
        ObjectId = 15,
        TypedLink = 16,
        Uuid = 17
    }
    const enum AuthProvider {
        Anonymous = 0,
        AnonymousNoReuse = 1,
        Facebook = 2,
        Google = 3,
        Apple = 4,
        Custom = 5,
        UsernamePassword = 6,
        Function = 7,
        ApiKey = 8
    }
    const enum AppCacheMode {
        Enabled = 0,
        Disabled = 1
    }
    const enum ClientResetMode {
        Manual = 0,
        DiscardLocal = 1,
        Recover = 2,
        RecoverOrDiscard = 3
    }
    const enum MetadataMode {
        NoEncryption = 0,
        Encryption = 1,
        InMemory = 2
    }
    const enum LoggerLevel {
        All = 0,
        Trace = 1,
        Debug = 2,
        Detail = 3,
        Info = 4,
        Warn = 5,
        Error = 6,
        Fatal = 7,
        Off = 8
    }
    const enum HttpMethod {
        Get = 0,
        Post = 1,
        Patch = 2,
        Put = 3,
        Del = 4
    }
    const enum SyncSessionStopPolicy {
        Immediately = 0,
        LiveIndefinitely = 1,
        AfterChangesUploaded = 2
    }
    const enum SyncSessionState {
        Active = 0,
        Dying = 1,
        Inactive = 2,
        WaitingForAccessToken = 3
    }
    const enum SyncSessionConnectionState {
        Disconnected = 0,
        Connecting = 1,
        Connected = 2
    }
    const enum SyncErrorAction {
        NoAction = 0,
        ProtocolViolation = 1,
        ApplicationBug = 2,
        Warning = 3,
        Transient = 4,
        DeleteRealm = 5,
        ClientReset = 6,
        ClientResetNoRecovery = 7
    }
    const enum SyncFileAction {
        DeleteRealm = 0,
        BackUpThenDeleteRealm = 1
    }
    const enum ProgressDirection {
        Upload = 0,
        Download = 1
    }
    const enum SyncUserState {
        LoggedOut = 0,
        LoggedIn = 1,
        Removed = 2
    }
    const enum SyncSubscriptionSetState {
        Uncommitted = 0,
        Pending = 1,
        Bootstrapping = 2,
        Complete = 3,
        Error = 4,
        Superseded = 5,
        AwaitingMark = 6
    }
    const enum WatchStreamState {
        NeedData = 0,
        HaveEvent = 1,
        HaveError = 2
    }
    const enum ProxyType {
        Http = 0,
        Https = 1
    }
    type AppError = Error & {
        code: number;
    };
    type CppErrorCode = Error & {
        code: number;
        category: string;
    };
    type EJson = null | string | number | boolean | EJson[] | {
        [name: string]: EJson;
    };
    export import Float = utils.Float;
    export import Status = utils.Status;
    export import ListSentinel = utils.ListSentinel;
    export import DictionarySentinel = utils.DictionarySentinel;
    class WeakRef<T extends object> {
        constructor(obj: T);
        deref(): T | undefined;
    }
    class Int64 {
        private brandForInt64;
        static add(a: Int64, b: Int64): Int64;
        static equals(a: Int64, b: Int64 | number | string): boolean;
        static isInt(a: unknown): a is Int64;
        static numToInt(a: number): Int64;
        static strToInt(a: string): Int64;
        static intToNum(a: Int64): number;
    }
    type Mixed = null | symbol | Int64 | boolean | Float | number | string | ArrayBuffer | Timestamp | Decimal128 | ObjectId | UUID | ObjLink | ObjKey;
    type MixedArg = null | Obj | Geospatial | Int64 | boolean | Float | number | string | ArrayBuffer | Timestamp | Decimal128 | ObjectId | UUID | ObjLink | ObjKey;
    /** Using an empty enum to express a nominal type */ enum Schema {
    }
    /** Using an empty enum to express a nominal type */ enum Group {
    }
    /** Using an empty enum to express a nominal type */ enum AuditInterface {
    }
    /** Using an empty enum to express a nominal type */ enum ColKey {
    }
    /** Using an empty enum to express a nominal type */ enum ObjKey {
    }
    /** Using an empty enum to express a nominal type */ enum TableKey {
    }
    type Property = {
        name: string;
        publicName: string;
        type: PropertyType;
        objectType: string;
        linkOriginPropertyName: string;
        /** @default false */
        isPrimary: boolean;
        /** @default false */
        isIndexed: boolean;
        /** @default false */
        isFulltextIndexed: boolean;
        columnKey: ColKey;
    };
    type Property_Relaxed = {
        name: string;
        publicName?: string;
        type: PropertyType;
        objectType?: string;
        linkOriginPropertyName?: string;
        /** @default false */
        isPrimary?: boolean;
        /** @default false */
        isIndexed?: boolean;
        /** @default false */
        isFulltextIndexed?: boolean;
        columnKey?: ColKey;
    };
    type VersionId = {
        /**
         * @deprecated Add 'version' to your opt-in list (under 'records/VersionID/fields/') to use this.
         * @default 0x7FFF_FFFF_FFFF_FFFF
         */
        version: Int64;
        /**
         * @deprecated Add 'index' to your opt-in list (under 'records/VersionID/fields/') to use this.
         * @default 0
         */
        index: number;
    };
    type VersionId_Relaxed = {
        /**
         * @deprecated Add 'version' to your opt-in list (under 'records/VersionID/fields/') to use this.
         * @default 0x7FFF_FFFF_FFFF_FFFF
         */
        version?: Int64;
        /**
         * @deprecated Add 'index' to your opt-in list (under 'records/VersionID/fields/') to use this.
         * @default 0
         */
        index?: number;
    };
    type ObjectSchema = {
        name: string;
        persistedProperties: Array<Property>;
        computedProperties: Array<Property>;
        primaryKey: string;
        tableKey: TableKey;
        /** @default TopLevel */
        tableType: TableType;
        /** @deprecated Add 'alias' to your opt-in list (under 'records/ObjectSchema/fields/') to use this. */
        alias: string;
    };
    type ObjectSchema_Relaxed = {
        name: string;
        persistedProperties?: Array<Property_Relaxed>;
        computedProperties?: Array<Property_Relaxed>;
        primaryKey?: string;
        tableKey?: TableKey;
        /** @default TopLevel */
        tableType?: TableType;
        /** @deprecated Add 'alias' to your opt-in list (under 'records/ObjectSchema/fields/') to use this. */
        alias?: string;
    };
    type GeoPoint = {
        longitude: number;
        latitude: number;
        /** @default std::numeric_limits<double>::quiet_NaN() */
        altitude: number;
    };
    type GeoPoint_Relaxed = {
        longitude: number;
        latitude: number;
        /** @default std::numeric_limits<double>::quiet_NaN() */
        altitude?: number;
    };
    type GeoCircle = {
        radiusRadians: number;
        center: GeoPoint;
    };
    type GeoCircle_Relaxed = {
        radiusRadians: number;
        center: GeoPoint_Relaxed;
    };
    type GeoBox = {
        lo: GeoPoint;
        hi: GeoPoint;
    };
    type GeoBox_Relaxed = {
        lo: GeoPoint_Relaxed;
        hi: GeoPoint_Relaxed;
    };
    type GeoPolygon = {
        points: Array<Array<GeoPoint>>;
    };
    type GeoPolygon_Relaxed = {
        points: Array<Array<GeoPoint_Relaxed>>;
    };
    type RealmConfig = {
        path: string;
        /** @default false */
        cache: boolean;
        encryptionKey: ArrayBuffer;
        fifoFilesFallbackPath: string;
        /** @default false */
        inMemory: boolean;
        schema: undefined | Array<ObjectSchema>;
        /** @default -1 */
        schemaVersion: Int64;
        /** @default SchemaMode::Automatic */
        schemaMode: SchemaMode;
        /** @default false */
        disableFormatUpgrade: boolean;
        syncConfig: null | SyncConfig;
        /** @default false */
        forceSyncHistory: boolean;
        migrationFunction: null | ((old_realm: Realm, new_realm: Realm) => void);
        initializationFunction: null | ((realm: Realm) => void);
        shouldCompactOnLaunchFunction: null | ((total_bytes: Int64, used_bytes: Int64) => boolean);
        /** @default false */
        automaticallyHandleBacklinksInMigrations: boolean;
    };
    type RealmConfig_Relaxed = {
        path: string;
        /** @default false */
        cache?: boolean;
        encryptionKey?: ArrayBuffer;
        fifoFilesFallbackPath?: string;
        /** @default false */
        inMemory?: boolean;
        schema?: undefined | Array<ObjectSchema_Relaxed>;
        /** @default -1 */
        schemaVersion?: Int64;
        /** @default SchemaMode::Automatic */
        schemaMode?: SchemaMode;
        /** @default false */
        disableFormatUpgrade?: boolean;
        syncConfig?: null | SyncConfig_Relaxed;
        /** @default false */
        forceSyncHistory?: boolean;
        migrationFunction?: null | ((old_realm: Realm, new_realm: Realm) => void);
        initializationFunction?: null | ((realm: Realm) => void);
        shouldCompactOnLaunchFunction?: null | ((total_bytes: Int64, used_bytes: Int64) => boolean);
        /** @default false */
        automaticallyHandleBacklinksInMigrations?: boolean;
    };
    type UserIdentity = {
        id: string;
        providerType: string;
    };
    type UserIdentity_Relaxed = {
        id: string;
        providerType: string;
    };
    type UserApiKey = {
        id: ObjectId;
        key: undefined | string;
        name: string;
        disabled: boolean;
    };
    type UserApiKey_Relaxed = {
        id: ObjectId;
        key?: undefined | string;
        name: string;
        disabled: boolean;
    };
    type SyncProxyConfig = {
        address: string;
        port: number;
        type: ProxyType;
    };
    type SyncProxyConfig_Relaxed = {
        address: string;
        port: number;
        type: ProxyType;
    };
    type SyncConfig = {
        user: SyncUser;
        partitionValue: string;
        /** @default AfterChangesUploaded */
        stopPolicy: SyncSessionStopPolicy;
        /** @default false */
        flxSyncRequested: boolean;
        errorHandler: null | ((session: SyncSession, error: SyncError_Relaxed) => void);
        customHttpHeaders: Record<string, string>;
        /** @default true */
        clientValidateSsl: boolean;
        sslTrustCertificatePath: undefined | string;
        sslVerifyCallback: null | SslVerifyCallback;
        /** @default ClientResyncMode::Manual; */
        clientResyncMode: ClientResetMode;
        notifyBeforeClientReset: null | ((before_frozen: Realm) => void);
        notifyAfterClientReset: null | ((before_frozen: Realm, after: ThreadSafeReference, did_recover: boolean) => void);
        /** @default false */
        cancelWaitsOnNonfatalError: boolean;
        proxyConfig: undefined | SyncProxyConfig;
    };
    type SyncConfig_Relaxed = {
        user: SyncUser;
        partitionValue?: string;
        /** @default AfterChangesUploaded */
        stopPolicy?: SyncSessionStopPolicy;
        /** @default false */
        flxSyncRequested?: boolean;
        errorHandler?: null | ((session: SyncSession, error: SyncError) => void);
        customHttpHeaders?: Record<string, string>;
        /** @default true */
        clientValidateSsl?: boolean;
        sslTrustCertificatePath?: undefined | string;
        sslVerifyCallback?: null | SslVerifyCallback;
        /** @default ClientResyncMode::Manual; */
        clientResyncMode?: ClientResetMode;
        notifyBeforeClientReset?: null | ((before_frozen: Realm) => void);
        notifyAfterClientReset?: null | ((before_frozen: Realm, after: ThreadSafeReference, did_recover: boolean) => void);
        /** @default false */
        cancelWaitsOnNonfatalError?: boolean;
        proxyConfig?: undefined | SyncProxyConfig_Relaxed;
    };
    type SyncSubscription = {
        id: ObjectId;
        createdAt: Timestamp;
        updatedAt: Timestamp;
        name: undefined | string;
        objectClassName: string;
        queryString: string;
    };
    type SyncSubscription_Relaxed = {
        id: ObjectId;
        createdAt: Timestamp;
        updatedAt: Timestamp;
        name?: undefined | string;
        objectClassName: string;
        queryString: string;
    };
    type ObjectChangeSet = {
        isDeleted: boolean;
        changedColumns: Array<ColKey>;
    };
    type ObjectChangeSet_Relaxed = {
        isDeleted: boolean;
        changedColumns: Array<ColKey>;
    };
    type CollectionChangeSetMove = {
        /** @deprecated Add 'from' to your opt-in list (under 'records/CollectionChangeSetMove/fields/') to use this. */
        from: number;
        /** @deprecated Add 'to' to your opt-in list (under 'records/CollectionChangeSetMove/fields/') to use this. */
        to: number;
    };
    type CollectionChangeSetMove_Relaxed = {
        /** @deprecated Add 'from' to your opt-in list (under 'records/CollectionChangeSetMove/fields/') to use this. */
        from: number;
        /** @deprecated Add 'to' to your opt-in list (under 'records/CollectionChangeSetMove/fields/') to use this. */
        to: number;
    };
    type CollectionChangeSet = {
        deletions: IndexSet;
        insertions: IndexSet;
        modifications: IndexSet;
        modificationsNew: IndexSet;
        /** @deprecated Add 'moves' to your opt-in list (under 'records/CollectionChangeSet/fields/') to use this. */
        moves: Array<CollectionChangeSetMove>;
        /** @deprecated Add 'collection_root_was_deleted' to your opt-in list (under 'records/CollectionChangeSet/fields/') to use this. */
        collectionRootWasDeleted: boolean;
        /** @deprecated Add 'collection_was_cleared' to your opt-in list (under 'records/CollectionChangeSet/fields/') to use this. */
        collectionWasCleared: boolean;
    };
    type CollectionChangeSet_Relaxed = {
        deletions: IndexSet;
        insertions: IndexSet;
        modifications: IndexSet;
        modificationsNew: IndexSet;
        /** @deprecated Add 'moves' to your opt-in list (under 'records/CollectionChangeSet/fields/') to use this. */
        moves: Array<CollectionChangeSetMove_Relaxed>;
        /** @deprecated Add 'collection_root_was_deleted' to your opt-in list (under 'records/CollectionChangeSet/fields/') to use this. */
        collectionRootWasDeleted: boolean;
        /** @deprecated Add 'collection_was_cleared' to your opt-in list (under 'records/CollectionChangeSet/fields/') to use this. */
        collectionWasCleared: boolean;
    };
    type DictionaryChangeSet = {
        deletions: Array<Mixed>;
        insertions: Array<Mixed>;
        modifications: Array<Mixed>;
        /** @deprecated Add 'collection_root_was_deleted' to your opt-in list (under 'records/DictionaryChangeSet/fields/') to use this. */
        collectionRootWasDeleted: boolean;
    };
    type DictionaryChangeSet_Relaxed = {
        deletions: Array<MixedArg>;
        insertions: Array<MixedArg>;
        modifications: Array<MixedArg>;
        /** @deprecated Add 'collection_root_was_deleted' to your opt-in list (under 'records/DictionaryChangeSet/fields/') to use this. */
        collectionRootWasDeleted: boolean;
    };
    type BindingContext = Record<string, never>;
    type BindingContext_Relaxed = {
        didChange?: null | ((r: Realm) => void);
        beforeNotify?: null | ((r: Realm) => void);
        schemaDidChange?: null | ((r: Realm) => void);
    };
    type ResumptionDelayInfo = {
        /** @default 3000000 */ maxResumptionDelayInterval: Int64;
        /** @default 1000 */
        resumptionDelayInterval: Int64;
        /** @default 2 */
        resumptionDelayBackoffMultiplier: number;
        /** @default 4 */
        delayJitterDivisor: number;
    };
    type ResumptionDelayInfo_Relaxed = {
        /** @default 3000000 */ maxResumptionDelayInterval?: Int64;
        /** @default 1000 */
        resumptionDelayInterval?: Int64;
        /** @default 2 */
        resumptionDelayBackoffMultiplier?: number;
        /** @default 4 */
        delayJitterDivisor?: number;
    };
    type SyncClientTimeouts = {
        /** @default 120000 */ connectTimeout: Int64;
        /** @default 30000 */
        connectionLingerTime: Int64;
        /** @default 60000 */
        pingKeepalivePeriod: Int64;
        /** @default 120000 */
        pongKeepaliveTimeout: Int64;
        /** @default 60000 */
        fastReconnectLimit: Int64;
        reconnectBackoffInfo: ResumptionDelayInfo;
    };
    type SyncClientTimeouts_Relaxed = {
        /** @default 120000 */ connectTimeout?: Int64;
        /** @default 30000 */
        connectionLingerTime?: Int64;
        /** @default 60000 */
        pingKeepalivePeriod?: Int64;
        /** @default 120000 */
        pongKeepaliveTimeout?: Int64;
        /** @default 60000 */
        fastReconnectLimit?: Int64;
        reconnectBackoffInfo?: ResumptionDelayInfo_Relaxed;
    };
    type SyncClientConfig = {
        /** @deprecated Add 'logger_factory' to your opt-in list (under 'records/SyncClientConfig/fields/') to use this. */
        loggerFactory: null | LoggerFactory;
        /**
         * @deprecated Add 'log_level' to your opt-in list (under 'records/SyncClientConfig/fields/') to use this.
         * @default LoggerLevel::info
         */
        logLevel: LoggerLevel;
        /** @default false */
        multiplexSessions: boolean;
        userAgentBindingInfo: string;
        /** @deprecated Add 'user_agent_application_info' to your opt-in list (under 'records/SyncClientConfig/fields/') to use this. */
        userAgentApplicationInfo: string;
        timeouts: SyncClientTimeouts;
    };
    type SyncClientConfig_Relaxed = {
        /** @deprecated Add 'logger_factory' to your opt-in list (under 'records/SyncClientConfig/fields/') to use this. */
        loggerFactory?: null | LoggerFactory;
        /**
         * @deprecated Add 'log_level' to your opt-in list (under 'records/SyncClientConfig/fields/') to use this.
         * @default LoggerLevel::info
         */
        logLevel?: LoggerLevel;
        /** @default false */
        multiplexSessions?: boolean;
        userAgentBindingInfo?: string;
        /** @deprecated Add 'user_agent_application_info' to your opt-in list (under 'records/SyncClientConfig/fields/') to use this. */
        userAgentApplicationInfo?: string;
        timeouts?: SyncClientTimeouts_Relaxed;
    };
    type SyncError = {
        status: Status;
        isFatal: boolean;
        simpleMessage: string;
        logUrl: string;
        userInfo: Record<string, string>;
        /**
         * @deprecated Add 'is_unrecognized_by_client' to your opt-in list (under 'records/SyncError/fields/') to use this.
         * @default false
         */
        isUnrecognizedByClient: boolean;
        isClientResetRequested: boolean;
        /**
         * @deprecated Add 'server_requests_action' to your opt-in list (under 'records/SyncError/fields/') to use this.
         * @default NoAction
         */
        serverRequestsAction: SyncErrorAction;
        compensatingWritesInfo: Array<CompensatingWriteErrorInfo>;
    };
    type SyncError_Relaxed = {
        status: Status;
        isFatal: boolean;
        simpleMessage: string;
        logUrl: string;
        userInfo: Record<string, string>;
        /**
         * @deprecated Add 'is_unrecognized_by_client' to your opt-in list (under 'records/SyncError/fields/') to use this.
         * @default false
         */
        isUnrecognizedByClient?: boolean;
        isClientResetRequested: boolean;
        /**
         * @deprecated Add 'server_requests_action' to your opt-in list (under 'records/SyncError/fields/') to use this.
         * @default NoAction
         */
        serverRequestsAction?: SyncErrorAction;
        compensatingWritesInfo: Array<CompensatingWriteErrorInfo_Relaxed>;
    };
    type Request = {
        method: HttpMethod;
        url: string;
        timeoutMs: Int64;
        headers: Record<string, string>;
        body: string;
        /** @deprecated Add 'uses_refresh_token' to your opt-in list (under 'records/Request/fields/') to use this. */
        usesRefreshToken: boolean;
    };
    type Request_Relaxed = {
        method: HttpMethod;
        url: string;
        timeoutMs: Int64;
        headers: Record<string, string>;
        body: string;
        /** @deprecated Add 'uses_refresh_token' to your opt-in list (under 'records/Request/fields/') to use this. */
        usesRefreshToken: boolean;
    };
    type Response = {
        httpStatusCode: number;
        customStatusCode: number;
        headers: Record<string, string>;
        body: string;
    };
    type Response_Relaxed = {
        httpStatusCode: number;
        customStatusCode: number;
        headers: Record<string, string>;
        body: string;
    };
    type DeviceInfo = {
        platformVersion: string;
        sdkVersion: string;
        sdk: string;
        deviceName: string;
        deviceVersion: string;
        frameworkName: string;
        frameworkVersion: string;
        bundleId: string;
    };
    type DeviceInfo_Relaxed = {
        platformVersion: string;
        sdkVersion: string;
        sdk: string;
        deviceName: string;
        deviceVersion: string;
        frameworkName: string;
        frameworkVersion: string;
        bundleId: string;
    };
    type AppConfig = {
        appId: string;
        transport: GenericNetworkTransport;
        baseUrl: undefined | string;
        defaultRequestTimeoutMs: undefined | Int64;
        deviceInfo: DeviceInfo;
        baseFilePath: string;
        syncClientConfig: SyncClientConfig;
        /** @default MetadataMode::Encryption */
        metadataMode: MetadataMode;
        customEncryptionKey: undefined | ArrayBuffer;
        /** @deprecated Add 'security_access_group' to your opt-in list (under 'records/AppConfig/fields/') to use this. */
        securityAccessGroup: string;
    };
    type AppConfig_Relaxed = {
        appId: string;
        transport: GenericNetworkTransport;
        baseUrl?: undefined | string;
        defaultRequestTimeoutMs?: undefined | Int64;
        deviceInfo: DeviceInfo_Relaxed;
        baseFilePath: string;
        syncClientConfig: SyncClientConfig_Relaxed;
        /** @default MetadataMode::Encryption */
        metadataMode?: MetadataMode;
        customEncryptionKey?: undefined | ArrayBuffer;
        /** @deprecated Add 'security_access_group' to your opt-in list (under 'records/AppConfig/fields/') to use this. */
        securityAccessGroup?: string;
    };
    type CompensatingWriteErrorInfo = {
        objectName: string;
        reason: string;
        primaryKey: Mixed;
    };
    type CompensatingWriteErrorInfo_Relaxed = {
        objectName: string;
        reason: string;
        primaryKey: MixedArg;
    };
    type SaltedFileIdent = {
        ident: Int64;
        salt: Int64;
    };
    type SaltedFileIdent_Relaxed = {
        ident: Int64;
        salt: Int64;
    };
    class Helpers {
        /** Opting out of structural typing */
        private brandForHelpers;
        private constructor();
        static getTable(r: Realm, key: TableKey): TableRef;
        static getKeypathMapping(r: Realm): KeyPathMapping;
        static resultsAppendQuery(results: Results, query: Query): Results;
        static makeObjectNotifier(r: Realm, o: Obj): ObjectNotifier;
        static setBindingContext(r: Realm, methods: BindingContext_Relaxed): void;
        static getOrCreateObjectWithPrimaryKey(t: TableRef, pk: MixedArg): [Obj, boolean];
        static makeNetworkTransport(runRequest: (request: Readonly<Request>, callback: (response: Response_Relaxed) => void) => void): GenericNetworkTransport;
        static deleteDataForObject(realm: Realm, object_type: string): void;
        static base64Decode(input: string): ArrayBuffer;
        static makeLoggerFactory(log: (category: Readonly<string>, level: LoggerLevel, message: Readonly<string>) => void): LoggerFactory;
        static makeLogger(log: (category: Readonly<string>, level: LoggerLevel, message: Readonly<string>) => void): Logger;
        static simulateSyncError(session: SyncSession, code: Readonly<number>, message: Readonly<string>, type: Readonly<string>, is_fatal: boolean): void;
        static consumeThreadSafeReferenceToSharedRealm(tsr: ThreadSafeReference): Realm;
        static fileExists(path: string): boolean;
        static eraseSubscription(subs: MutableSyncSubscriptionSet, sub_to_remove: Readonly<SyncSubscription_Relaxed>): boolean;
        static getResultsDescription(results: Readonly<Results>): string;
        static feedBuffer(ws: WatchStream, buffer: ArrayBuffer): void;
        static makeSslVerifyCallback(callback: (server_address: Readonly<string>, server_port: number, pem_data: string, preverify_ok: number, depth: number) => boolean): SslVerifyCallback;
        static needsFileFormatUpgrade(config: Readonly<RealmConfig_Relaxed>): boolean;
        static syncUserAsAppUser(sync_user: null | SyncUser): null | User;
        static appUserAsSyncUser(sync_user: null | User): null | SyncUser;
    }
    class LogCategoryRef {
        /** Opting out of structural typing */
        private brandForLogCategoryRef;
        private constructor();
        setDefaultLevelThreshold(level: LoggerLevel): void;
        static getCategory(name: string): LogCategoryRef;
    }
    class Logger {
        /** Opting out of structural typing */
        private brandForLogger;
        private constructor();
        static setDefaultLogger(logger: null | Logger): void;
    }
    class ConstTableRef {
        /** Opting out of structural typing */
        private brandForConstTableRef;
        protected constructor();
        getColumnType(column: ColKey): DataType;
        getLinkTarget(column: ColKey): ConstTableRef;
        getObject(key: ObjKey): Obj;
        tryGetObject(key: ObjKey): null | Obj;
        query(query_string: string, args: Array<MixedArg | MixedArg[]>, mapping: KeyPathMapping): Query;
        findPrimaryKey(pk: MixedArg): ObjKey;
        get key(): TableKey;
        [Symbol.iterator](): Iterator<Obj>;
    }
    class TableRef extends ConstTableRef {
        /** Opting out of structural typing */
        private brandForTableRef;
        private constructor();
        createObject(): Obj;
        removeObject(key: ObjKey): void;
        getLinkTarget(column: ColKey): TableRef;
        clear(): void;
        getPrimaryKeyColumn(): ColKey;
    }
    class Obj {
        /** Opting out of structural typing */
        private brandForObj;
        private constructor();
        getAny(column: ColKey): Mixed;
        setAny(column: ColKey, value: MixedArg): void;
        setCollection(column: ColKey, type: CollectionType): Obj;
        addInt(column: ColKey, value: Int64): Obj;
        getLinkedObject(column: ColKey): null | Obj;
        getBacklinkCount(): number;
        getBacklinkView(src_table: TableRef, src_col_key: ColKey): TableView;
        createAndSetLinkedObject(column: ColKey): Obj;
        get isValid(): boolean;
        get table(): TableRef;
        get key(): ObjKey;
    }
    class Transaction {
        /** Opting out of structural typing */
        private brandForTransaction;
        private constructor();
    }
    class ObjectStore {
        /** Opting out of structural typing */
        private brandForObjectStore;
        private constructor();
    }
    class Timestamp {
        /** Opting out of structural typing */
        private brandForTimestamp;
        private constructor();
        static make(seconds: Int64, nanoseconds: number): Timestamp;
        get seconds(): Int64;
        get nanoseconds(): number;
    }
    class Geospatial {
        /** Opting out of structural typing */
        private brandForGeospatial;
        private constructor();
        static makeFromCircle(circle: GeoCircle_Relaxed): Geospatial;
        static makeFromBox(box: GeoBox_Relaxed): Geospatial;
        static makeFromPolygon(polygon: GeoPolygon_Relaxed): Geospatial;
    }
    class ObjLink {
        /** Opting out of structural typing */
        private brandForObjLink;
        private constructor();
        get tableKey(): TableKey;
        get objKey(): ObjKey;
    }
    class KeyPathMapping {
        /** Opting out of structural typing */
        private brandForKeyPathMapping;
        private constructor();
    }
    class Query {
        /** Opting out of structural typing */
        private brandForQuery;
        private constructor();
        get table(): ConstTableRef;
        get description(): string;
    }
    class SortDescriptor {
        /** Opting out of structural typing */
        private brandForSortDescriptor;
        private constructor();
    }
    class TableView {
        /** Opting out of structural typing */
        private brandForTableView;
        private constructor();
    }
    class Results {
        /** Opting out of structural typing */
        private brandForResults;
        private constructor();
        size(): number;
        indexOf(value: MixedArg): number;
        indexOfObj(obj: Obj): number;
        getObj(index: number): Obj;
        getAny(index: number): Mixed;
        getList(index: number): List;
        getDictionary(index: number): Dictionary;
        sortByNames(order: Array<[string, boolean]>): Results;
        snapshot(): Results;
        max(column: ColKey): undefined | Mixed;
        min(column: ColKey): undefined | Mixed;
        average(column: ColKey): undefined | Mixed;
        sum(column: ColKey): undefined | Mixed;
        clear(): void;
        addNotificationCallback(cb: (changes: Readonly<CollectionChangeSet>) => void, keyPaths: undefined | Array<Array<[TableKey, ColKey]>>): NotificationToken;
        static fromTable(r: Realm, table: ConstTableRef): Results;
        static fromTableView(r: Realm, table: TableView): Results;
        get isValid(): boolean;
        get query(): Query;
        get objectType(): string;
        get type(): PropertyType;
    }
    class Realm {
        /** Opting out of structural typing */
        private brandForRealm;
        private constructor();
        beginTransaction(): void;
        commitTransaction(): void;
        cancelTransaction(): void;
        updateSchema(schema: Array<ObjectSchema_Relaxed>, version: Int64, migration_function: null | ((old_realm: Realm, new_realm: Realm) => void), initialization_function: null | ((realm: Realm) => void), in_transaction: boolean): void;
        compact(): boolean;
        convert(config: RealmConfig_Relaxed): void;
        verifyOpen(): void;
        createKeyPathArray(table_name: string, key_paths: Readonly<Array<string>>): Array<Array<[TableKey, ColKey]>>;
        close(): void;
        static getSharedRealm(config: RealmConfig_Relaxed): Realm;
        static getSynchronizedRealm(config: RealmConfig_Relaxed): AsyncOpenTask;
        static getSchemaVersion(config: Readonly<RealmConfig_Relaxed>): Int64;
        get config(): Readonly<RealmConfig>;
        get schema(): Readonly<Array<ObjectSchema>>;
        get schemaVersion(): Int64;
        get isInTransaction(): boolean;
        get isInMigration(): boolean;
        get isEmpty(): boolean;
        get isClosed(): boolean;
        get syncSession(): null | SyncSession;
        get latestSubscriptionSet(): SyncSubscriptionSet;
        get $addr(): number;
        $resetSharedPtr(): void;
    }
    class RealmCoordinator {
        /** Opting out of structural typing */
        private brandForRealmCoordinator;
        private constructor();
        static clearAllCaches(): void;
    }
    class ObjectNotifier {
        /** Opting out of structural typing */
        private brandForObjectNotifier;
        private constructor();
        addCallback(cb: (changes: ObjectChangeSet) => void, keyPaths: undefined | Array<Array<[TableKey, ColKey]>>): Int64;
    }
    class NotificationToken {
        /** Opting out of structural typing */
        private brandForNotificationToken;
        private constructor();
        unregister(): void;
        static forObject(notifier: ObjectNotifier, token: Int64): NotificationToken;
    }
    class IndexSet {
        /** Opting out of structural typing */
        private brandForIndexSet;
        private constructor();
        [Symbol.iterator](): Iterator<[number, number]>;
    }
    class Collection {
        /** Opting out of structural typing */
        private brandForCollection;
        protected constructor();
        getAny(ndx: number): Mixed;
        asResults(): Results;
        snapshot(): Results;
        get type(): PropertyType;
        get objectSchema(): Readonly<ObjectSchema>;
        get size(): number;
        get isValid(): boolean;
    }
    class List extends Collection {
        /** Opting out of structural typing */
        private brandForList;
        private constructor();
        getObj(ndx: number): Obj;
        getList(path_elem: number): List;
        getDictionary(path_elem: number): Dictionary;
        move(source_ndx: number, dest_ndx: number): void;
        remove(ndx: number): void;
        removeAll(): void;
        swap(ndx1: number, ndx2: number): void;
        deleteAll(): void;
        insertAny(list_ndx: number, value: MixedArg): void;
        insertEmbedded(ndx: number): Obj;
        insertCollection(path_elem: number, dict_or_list: CollectionType): void;
        setAny(list_ndx: number, value: MixedArg): void;
        setEmbedded(list_ndx: number): Obj;
        setCollection(path_element: number, dict_or_list: CollectionType): void;
        static make(r: Realm, parent: Readonly<Obj>, col: ColKey): List;
    }
    class Set extends Collection {
        /** Opting out of structural typing */
        private brandForSet;
        private constructor();
        getObj(ndx: number): Obj;
        insertAny(val: MixedArg): [number, boolean];
        removeAny(val: MixedArg): [number, boolean];
        removeAll(): void;
        deleteAll(): void;
        static make(r: Realm, parent: Readonly<Obj>, col: ColKey): Set;
    }
    class Dictionary extends Collection {
        /** Opting out of structural typing */
        private brandForDictionary;
        private constructor();
        getList(path_elem: string): List;
        getDictionary(path_elem: string): Dictionary;
        contains(key: string): boolean;
        addKeyBasedNotificationCallback(cb: (changes: DictionaryChangeSet) => void, keyPaths: undefined | Array<Array<[TableKey, ColKey]>>): NotificationToken;
        insertAny(key: string, value: MixedArg): [number, boolean];
        insertEmbedded(key: string): Obj;
        insertCollection(path_elem: string, dict_or_list: CollectionType): void;
        tryGetAny(key: string): undefined | Mixed;
        removeAll(): void;
        tryErase(key: string): boolean;
        static make(r: Realm, parent: Readonly<Obj>, col: ColKey): Dictionary;
        get keys(): Results;
        get values(): Results;
        [Symbol.iterator](): Iterator<[Readonly<Mixed>, Mixed]>;
    }
    class GoogleAuthCode {
        /** Opting out of structural typing */
        private brandForGoogleAuthCode;
        private constructor();
        static make(code: string): GoogleAuthCode;
    }
    class GoogleIdToken {
        /** Opting out of structural typing */
        private brandForGoogleIdToken;
        private constructor();
        static make(token: string): GoogleIdToken;
    }
    class AppCredentials {
        /** Opting out of structural typing */
        private brandForAppCredentials;
        private constructor();
        static facebook(access_token: Readonly<string>): AppCredentials;
        static anonymous(reuse_anonymous_credentials: boolean): AppCredentials;
        static apple(id_token: Readonly<string>): AppCredentials;
        static googleAuth(id_token: GoogleAuthCode): AppCredentials;
        static googleId(id_token: GoogleIdToken): AppCredentials;
        static custom(token: Readonly<string>): AppCredentials;
        static usernamePassword(username: string, password: string): AppCredentials;
        static function(serialized_payload: Readonly<Record<string, EJson>>): AppCredentials;
        static apiKey(api_key: string): AppCredentials;
    }
    class UserSubscriptionToken {
        /** Opting out of structural typing */
        private brandForUserSubscriptionToken;
        private constructor();
    }
    class SyncUser {
        /** Opting out of structural typing */
        private brandForSyncUser;
        private constructor();
        get isLoggedIn(): boolean;
    }
    class User {
        /** Opting out of structural typing */
        private brandForUser;
        private constructor();
        subscribe(observer: () => void): UserSubscriptionToken;
        unsubscribe(token: UserSubscriptionToken): void;
        pathForRealm(config: SyncConfig_Relaxed, custom_file_name: undefined | string): string;
        accessTokenRefreshRequired(): boolean;
        requestRefreshLocation(): Promise<void>;
        requestAccessToken(): Promise<void>;
        trackRealm(path: string): void;
        get userId(): string;
        get appId(): string;
        get legacyIdentities(): Array<string>;
        get accessToken(): string;
        get refreshToken(): string;
        get state(): SyncUserState;
        get deviceId(): string;
        get hasDeviceId(): boolean;
        get userProfile(): UserProfile;
        get identities(): Array<UserIdentity>;
        get customData(): undefined | Record<string, EJson>;
        get app(): App;
    }
    class UserProfile {
        /** Opting out of structural typing */
        private brandForUserProfile;
        private constructor();
        data(): Record<string, EJson>;
    }
    class AppSubscriptionToken {
        /** Opting out of structural typing */
        private brandForAppSubscriptionToken;
        private constructor();
    }
    class App {
        /** Opting out of structural typing */
        private brandForApp;
        private constructor();
        logInWithCredentials(credentials: AppCredentials): Promise<User>;
        logOutUser(user: User): Promise<void>;
        refreshCustomData(user: User): Promise<void>;
        linkUser(user: User, credentials: Readonly<AppCredentials>): Promise<User>;
        switchUser(user: User): void;
        removeUser(user: User): Promise<void>;
        deleteUser(user: User): Promise<void>;
        usernamePasswordProviderClient(): UsernamePasswordProviderClient;
        userApiKeyProviderClient(): UserApiKeyProviderClient;
        pushNotificationClient(service_name: Readonly<string>): PushClient;
        subscribe(observer: () => void): AppSubscriptionToken;
        unsubscribe(token: AppSubscriptionToken): void;
        callFunction(user: Readonly<User>, name: string, args: EJson[], service_name: undefined | string): Promise<Readonly<EJson>>;
        makeStreamingRequest(user: User, name: string, args: EJson[], service_name: undefined | string): Request;
        updateBaseUrl(base_url: string): Promise<void>;
        getBaseUrl(): string;
        immediatelyRunFileActions(realm_path: string): boolean;
        static getApp(mode: AppCacheMode, config: Readonly<AppConfig_Relaxed>): App;
        static clearCachedApps(): void;
        get config(): Readonly<AppConfig>;
        get currentUser(): null | User;
        get allUsers(): Array<User>;
        get syncManager(): SyncManager;
    }
    class WatchStream {
        /** Opting out of structural typing */
        private brandForWatchStream;
        private constructor();
        nextEvent(): Record<string, EJson>;
        static make(): WatchStream;
        get state(): WatchStreamState;
        get error(): AppError;
    }
    class PushClient {
        /** Opting out of structural typing */
        private brandForPushClient;
        private constructor();
        registerDevice(registration_token: Readonly<string>, sync_user: Readonly<User>): Promise<void>;
        deregisterDevice(sync_user: Readonly<User>): Promise<void>;
    }
    class UsernamePasswordProviderClient {
        /** Opting out of structural typing */
        private brandForUsernamePasswordProviderClient;
        private constructor();
        registerEmail(email: Readonly<string>, password: Readonly<string>): Promise<void>;
        retryCustomConfirmation(email: Readonly<string>): Promise<void>;
        confirmUser(token: Readonly<string>, token_id: Readonly<string>): Promise<void>;
        resendConfirmationEmail(email: Readonly<string>): Promise<void>;
        resetPassword(password: Readonly<string>, token: Readonly<string>, token_id: Readonly<string>): Promise<void>;
        sendResetPasswordEmail(email: Readonly<string>): Promise<void>;
        callResetPasswordFunction(email: Readonly<string>, password: Readonly<string>, args: Readonly<EJson[]>): Promise<void>;
    }
    class UserApiKeyProviderClient {
        /** Opting out of structural typing */
        private brandForUserApiKeyProviderClient;
        private constructor();
        createApiKey(name: Readonly<string>, user: User): Promise<UserApiKey>;
        fetchApiKey(id: ObjectId, user: Readonly<User>): Promise<UserApiKey>;
        fetchApiKeys(user: Readonly<User>): Promise<Array<UserApiKey>>;
        deleteApiKey(id: ObjectId, user: Readonly<User>): Promise<void>;
        enableApiKey(id: ObjectId, user: Readonly<User>): Promise<void>;
        disableApiKey(id: ObjectId, user: Readonly<User>): Promise<void>;
    }
    class LoggerFactory {
        /** Opting out of structural typing */
        private brandForLoggerFactory;
        private constructor();
    }
    class SyncManager {
        /** Opting out of structural typing */
        private brandForSyncManager;
        private constructor();
        setSessionMultiplexing(allowed: boolean): void;
        setLogLevel(level: LoggerLevel): void;
        setLoggerFactory(factory: LoggerFactory): void;
        setUserAgent(user_agent: string): void;
        reconnect(): void;
        getExistingActiveSession(path: Readonly<string>): null | SyncSession;
        getAllSessionsFor(user: Readonly<User>): Array<SyncSession>;
        get hasExistingSessions(): boolean;
    }
    class ThreadSafeReference {
        /** Opting out of structural typing */
        private brandForThreadSafeReference;
        private constructor();
    }
    class AsyncOpenTask {
        /** Opting out of structural typing */
        private brandForAsyncOpenTask;
        private constructor();
        start(): Promise<ThreadSafeReference>;
        cancel(): void;
        registerDownloadProgressNotifier(callback: (transferred_bytes: Int64, transferrable_bytes: Int64, progress_estimate: number) => void): Int64;
        unregisterDownloadProgressNotifier(token: Int64): void;
        $resetSharedPtr(): void;
    }
    class SyncSession {
        /** Opting out of structural typing */
        private brandForSyncSession;
        private constructor();
        waitForUploadCompletion(): Promise<void>;
        waitForDownloadCompletion(): Promise<void>;
        registerProgressNotifier(callback: (transferred_bytes: Int64, transferrable_bytes: Int64, progress_estimate: number) => void, direction: ProgressDirection, is_streaming: boolean): Int64;
        unregisterProgressNotifier(token: Int64): void;
        registerConnectionChangeCallback(callback: (old_state: SyncSessionConnectionState, new_state: SyncSessionConnectionState) => void): Int64;
        unregisterConnectionChangeCallback(token: Int64): void;
        reviveIfNeeded(): void;
        handleReconnect(): void;
        forceClose(): void;
        getFileIdent(): SaltedFileIdent;
        get state(): SyncSessionState;
        get connectionState(): SyncSessionConnectionState;
        get user(): SyncUser;
        get config(): SyncConfig;
        get fullRealmUrl(): string;
        $resetSharedPtr(): void;
    }
    class SslVerifyCallback {
        /** Opting out of structural typing */
        private brandForSslVerifyCallback;
        private constructor();
    }
    class SyncSubscriptionSet {
        /** Opting out of structural typing */
        private brandForSyncSubscriptionSet;
        protected constructor();
        makeMutableCopy(): MutableSyncSubscriptionSet;
        getStateChangeNotification(notify_when: SyncSubscriptionSetState): Promise<SyncSubscriptionSetState>;
        findByName(name: string): null | Readonly<SyncSubscription>;
        findByQuery(query: Readonly<Query>): null | Readonly<SyncSubscription>;
        refresh(): void;
        get version(): Int64;
        get state(): SyncSubscriptionSetState;
        get errorStr(): string;
        get size(): number;
        [Symbol.iterator](): Iterator<Readonly<SyncSubscription>>;
    }
    class MutableSyncSubscriptionSet extends SyncSubscriptionSet {
        /** Opting out of structural typing */
        private brandForMutableSyncSubscriptionSet;
        private constructor();
        clear(): void;
        insertOrAssignByName(name: string, query: Readonly<Query>): [Readonly<SyncSubscription>, boolean];
        insertOrAssignByQuery(query: Readonly<Query>): [Readonly<SyncSubscription>, boolean];
        eraseByName(name: string): boolean;
        eraseByQuery(query: Readonly<Query>): boolean;
        commit(): SyncSubscriptionSet;
    }
    class Scheduler {
        /** Opting out of structural typing */
        private brandForScheduler;
        private constructor();
    }
    class GenericNetworkTransport {
        /** Opting out of structural typing */
        private brandForGenericNetworkTransport;
        private constructor();
    }
    class JsPlatformHelpers {
        /** Opting out of structural typing */
        private brandForJsPlatformHelpers;
        private constructor();
        static setDefaultRealmFileDirectory(dir: string): void;
        static defaultRealmFileDirectory(): string;
        static ensureDirectoryExistsForFile(file: Readonly<string>): void;
        static copyBundledRealmFiles(): void;
        static removeRealmFilesFromDirectory(directory: Readonly<string>): void;
        static removeFile(path: Readonly<string>): void;
        static removeDirectory(path: Readonly<string>): void;
        static excludeFromIcloudBackup(path: Readonly<string>, value: boolean): void;
        static getCpuArch(): string;
    }
    class WeakSyncSession {
        /** Opting out of structural typing */
        private brandForWeakSyncSession;
        private constructor();
        rawDereference(): null | SyncSession;
        static weakCopyOf(shared: SyncSession): WeakSyncSession;
    }
}
/**
 * Is true when the native module has been injected.
 * Useful to perform asserts on platforms which inject the native module synchronously.
 */
export declare let isReady: boolean;
/**
 * Resolves when the native module has been injected.
 * Useful to perform asserts on platforms which inject the native module asynchronously.
 */
export declare const ready: Promise<void>;
type Extras = {
    Int64: typeof binding.Int64;
    WeakRef: typeof binding.WeakRef;
};
export declare function injectNativeModule(nativeModule: any, extras: Extras): void;
export {};
//# sourceMappingURL=wrapper.generated.d.ts.map