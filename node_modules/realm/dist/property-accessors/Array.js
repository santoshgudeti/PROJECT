"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2024 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.createArrayPropertyAccessor = void 0;
const binding_1 = require("../binding");
const assert_1 = require("../assert");
const List_1 = require("../collection-accessors/List");
const Results_1 = require("../collection-accessors/Results");
const errors_1 = require("../errors");
const List_2 = require("../List");
const Results_2 = require("../Results");
const TypeHelpers_1 = require("../TypeHelpers");
/** @internal */
function createArrayPropertyAccessor({ realm, type, name, columnKey, objectType, embedded, linkOriginPropertyName, getClassHelpers, optional, }) {
    const realmInternal = realm.internal;
    const itemType = (0, TypeHelpers_1.toItemType)(type);
    const itemHelpers = (0, TypeHelpers_1.getTypeHelpers)(itemType, {
        realm,
        name: `element of ${name}`,
        optional,
        getClassHelpers,
        objectType,
        objectSchemaName: undefined,
    });
    if (itemType === 8 /* binding.PropertyType.LinkingObjects */) {
        // Locate the table of the targeted object
        assert_1.assert.string(objectType, "object type");
        (0, assert_1.assert)(objectType !== "", "Expected a non-empty string");
        const targetClassHelpers = getClassHelpers(objectType);
        const { objectSchema: { tableKey, persistedProperties }, } = targetClassHelpers;
        // TODO: Check if we want to match with the `p.name` or `p.publicName` here
        const targetProperty = persistedProperties.find((p) => p.name === linkOriginPropertyName);
        (0, assert_1.assert)(targetProperty, `Expected a '${linkOriginPropertyName}' property on ${objectType}`);
        const tableRef = binding_1.binding.Helpers.getTable(realmInternal, tableKey);
        const resultsAccessor = (0, Results_1.createResultsAccessor)({ realm, typeHelpers: itemHelpers, itemType });
        return {
            get(obj) {
                const tableView = obj.getBacklinkView(tableRef, targetProperty.columnKey);
                const results = binding_1.binding.Results.fromTableView(realmInternal, tableView);
                return new Results_2.Results(realm, results, resultsAccessor, itemHelpers);
            },
            set() {
                throw new Error("Not supported");
            },
        };
    }
    else {
        const listAccessor = (0, List_1.createListAccessor)({ realm, typeHelpers: itemHelpers, itemType, isEmbedded: embedded });
        return {
            listAccessor,
            get(obj) {
                const internal = binding_1.binding.List.make(realm.internal, obj, columnKey);
                assert_1.assert.instanceOf(internal, binding_1.binding.List);
                return new List_2.List(realm, internal, listAccessor, itemHelpers);
            },
            set(obj, values) {
                assert_1.assert.inTransaction(realm);
                assert_1.assert.iterable(values);
                const internal = binding_1.binding.List.make(realm.internal, obj, columnKey);
                internal.removeAll();
                let index = 0;
                try {
                    for (const value of values) {
                        listAccessor.insert(internal, index++, value);
                    }
                }
                catch (err) {
                    if (err instanceof errors_1.TypeAssertionError) {
                        err.rename(`${name}[${index - 1}]`);
                    }
                    throw err;
                }
            },
        };
    }
}
exports.createArrayPropertyAccessor = createArrayPropertyAccessor;
//# sourceMappingURL=Array.js.map