// This file is generated: Update the spec instead of editing this file directly
#include <realm/sync/config.hpp>
#include <realm/sync/subscriptions.hpp>
#include <realm/status.hpp>
#include <realm/object-store/shared_realm.hpp>
#include <realm/object-store/object_store.hpp>
#include <realm/object-store/object_schema.hpp>
#include <realm/object-store/results.hpp>
#include <realm/object-store/thread_safe_reference.hpp>
#include <realm/object-store/util/scheduler.hpp>
#include <realm/object-store/collection_notifications.hpp>
#include <realm/object-store/impl/object_notifier.hpp>
#include <realm/object-store/impl/realm_coordinator.hpp>
#include <realm/object-store/sync/async_open_task.hpp>
#include <realm/object-store/sync/app_credentials.hpp>
#include <realm/object-store/sync/generic_network_transport.hpp>
#include <realm/object-store/sync/app.hpp>
#include <realm/object-store/sync/sync_manager.hpp>
#include <realm/object-store/sync/sync_session.hpp>
#include <realm/object-store/sync/sync_user.hpp>
#include <realm/object-store/sync/app_user.hpp>
#include <realm/object-store/sync/mongo_collection.hpp>
#include <realm/util/bson/bson.hpp>
#include <platform.hpp>

#include <jsi/jsi.h>
#include <chrono>
#include <realm_js_jsi_helpers.h>

// Using all-caps JSI to avoid risk of conflicts with jsi namespace from fb.
namespace realm::js::JSI {
namespace {

class RealmAddon;
jsi::Value Helpers_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_get_keypath_mapping([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_results_append_query([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_make_object_notifier([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
Helpers::BindingContextMethods STRUCT_FROM_JS_BindingContext(jsi::Runtime& _env, auto&& val);
jsi::Value Helpers_set_binding_context([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_get_or_create_object_with_primary_key([[maybe_unused]] jsi::Runtime& _env,
                                                         [[maybe_unused]] const jsi::Value& thisValue,
                                                         [[maybe_unused]] const jsi::Value* args,
                                                         [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_Request(jsi::Runtime& _env, const app::Request& in);
app::Response STRUCT_FROM_JS_Response(jsi::Runtime& _env, auto&& val);
jsi::Value Helpers_make_network_transport([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_delete_data_for_object([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_base64_decode([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_make_logger_factory([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_make_logger([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_simulate_sync_error([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_consume_thread_safe_reference_to_shared_realm([[maybe_unused]] jsi::Runtime& _env,
                                                                 [[maybe_unused]] const jsi::Value& thisValue,
                                                                 [[maybe_unused]] const jsi::Value* args,
                                                                 [[maybe_unused]] size_t count);
jsi::Value Helpers_file_exists([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
sync::Subscription STRUCT_FROM_JS_SyncSubscription(jsi::Runtime& _env, auto&& val);
jsi::Value Helpers_erase_subscription([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_get_results_description([[maybe_unused]] jsi::Runtime& _env,
                                           [[maybe_unused]] const jsi::Value& thisValue,
                                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_feed_buffer([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_make_ssl_verify_callback([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
Property STRUCT_FROM_JS_Property(jsi::Runtime& _env, auto&& val);
ObjectSchema STRUCT_FROM_JS_ObjectSchema(jsi::Runtime& _env, auto&& val);
jsi::Value STRUCT_TO_JS_CompensatingWriteErrorInfo(jsi::Runtime& _env, const sync::CompensatingWriteErrorInfo& in);
jsi::Value STRUCT_TO_JS_SyncError(jsi::Runtime& _env, const SyncError& in);
SyncConfig::ProxyConfig STRUCT_FROM_JS_SyncProxyConfig(jsi::Runtime& _env, auto&& val);
SyncConfig STRUCT_FROM_JS_SyncConfig(jsi::Runtime& _env, auto&& val);
RealmConfig STRUCT_FROM_JS_RealmConfig(jsi::Runtime& _env, auto&& val);
jsi::Value Helpers_needs_file_format_upgrade([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_sync_user_as_app_user([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Helpers_app_user_as_sync_user([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Helpers& JS_TO_CLASS_Helpers(jsi::Runtime& _env, const jsi::Value& val);
jsi::Value LogCategoryRef_set_default_level_threshold([[maybe_unused]] jsi::Runtime& _env,
                                                      [[maybe_unused]] const jsi::Value& thisValue,
                                                      [[maybe_unused]] const jsi::Value* args,
                                                      [[maybe_unused]] size_t count);
jsi::Value LogCategoryRef_get_category([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] util::LogCategoryRef& JS_TO_CLASS_LogCategoryRef(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_LogCategoryRef(jsi::Runtime& _env, util::LogCategoryRef val);
jsi::Value Logger_set_default_logger([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<util::Logger>& JS_TO_SHARED_Logger(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_Logger(jsi::Runtime& _env, std::shared_ptr<util::Logger> val);
jsi::Value ConstTableRef_get_column_type([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_get_link_target([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_get_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_try_get_object([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_query([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_find_primary_key([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_get_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ConstTableRef_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] ConstTableRef& JS_TO_CLASS_ConstTableRef(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_ConstTableRef(jsi::Runtime& _env, ConstTableRef val);
jsi::Value TableRef_create_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value TableRef_remove_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value TableRef_get_link_target([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value TableRef_clear([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value TableRef_get_primary_key_column([[maybe_unused]] jsi::Runtime& _env,
                                           [[maybe_unused]] const jsi::Value& thisValue,
                                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] TableRef& JS_TO_CLASS_TableRef(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_TableRef(jsi::Runtime& _env, TableRef val);
jsi::Value Obj_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_set_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_set_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_add_int([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_get_linked_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_get_backlink_count([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_get_backlink_view([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_create_and_set_linked_object([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Obj_get_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Obj& JS_TO_CLASS_Obj(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Obj(jsi::Runtime& _env, Obj val);
[[maybe_unused]] const std::shared_ptr<Transaction>& JS_TO_SHARED_Transaction(jsi::Runtime& _env,
                                                                              const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_Transaction(jsi::Runtime& _env, std::shared_ptr<Transaction> val);
[[maybe_unused]] ObjectStore& JS_TO_CLASS_ObjectStore(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_ObjectStore(jsi::Runtime& _env, ObjectStore val);
jsi::Value Timestamp_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Timestamp_get_seconds([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Timestamp_get_nanoseconds([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Timestamp& JS_TO_CLASS_Timestamp(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Timestamp(jsi::Runtime& _env, Timestamp val);
GeoPoint STRUCT_FROM_JS_GeoPoint(jsi::Runtime& _env, auto&& val);
GeoCircle STRUCT_FROM_JS_GeoCircle(jsi::Runtime& _env, auto&& val);
jsi::Value Geospatial_make_from_circle([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
GeoBox STRUCT_FROM_JS_GeoBox(jsi::Runtime& _env, auto&& val);
jsi::Value Geospatial_make_from_box([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
GeoPolygon STRUCT_FROM_JS_GeoPolygon(jsi::Runtime& _env, auto&& val);
jsi::Value Geospatial_make_from_polygon([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Geospatial& JS_TO_CLASS_Geospatial(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Geospatial(jsi::Runtime& _env, Geospatial val);
jsi::Value ObjLink_get_table_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value ObjLink_get_obj_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] ObjLink& JS_TO_CLASS_ObjLink(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_ObjLink(jsi::Runtime& _env, ObjLink val);
[[maybe_unused]] query_parser::KeyPathMapping& JS_TO_CLASS_KeyPathMapping(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_KeyPathMapping(jsi::Runtime& _env, query_parser::KeyPathMapping val);
jsi::Value Query_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Query_get_description([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Query& JS_TO_CLASS_Query(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Query(jsi::Runtime& _env, Query val);
[[maybe_unused]] SortDescriptor& JS_TO_CLASS_SortDescriptor(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_SortDescriptor(jsi::Runtime& _env, SortDescriptor val);
[[maybe_unused]] TableView& JS_TO_CLASS_TableView(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_TableView(jsi::Runtime& _env, TableView val);
jsi::Value Results_size([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_index_of([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_index_of_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_dictionary([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_sort_by_names([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_snapshot([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_max([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_min([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_average([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_sum([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_clear([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_CollectionChangeSet(jsi::Runtime& _env, const CollectionChangeSet& in);
jsi::Value Results_add_notification_callback([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_from_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_from_table_view([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_query([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_object_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Results_get_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] Results& JS_TO_CLASS_Results(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Results(jsi::Runtime& _env, Results val);
jsi::Value Realm_begin_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_commit_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_cancel_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_update_schema([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_compact([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_convert([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_verify_open([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_create_key_path_array([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_close([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_get_shared_realm([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_get_synchronized_realm([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_get_schema_version([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_Property(jsi::Runtime& _env, const Property& in);
jsi::Value STRUCT_TO_JS_ObjectSchema(jsi::Runtime& _env, const ObjectSchema& in);
jsi::Value STRUCT_TO_JS_SyncProxyConfig(jsi::Runtime& _env, const SyncConfig::ProxyConfig& in);
jsi::Value STRUCT_TO_JS_SyncConfig(jsi::Runtime& _env, const SyncConfig& in);
jsi::Value STRUCT_TO_JS_RealmConfig(jsi::Runtime& _env, const RealmConfig& in);
jsi::Value Realm_config([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_schema([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_schema_version([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_is_in_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_is_in_migration([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_is_empty([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_is_closed([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_sync_session([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_get_latest_subscription_set([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_DOLLAR_addr([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Realm_DOLLAR_resetSharedPtr([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<Realm>& JS_TO_SHARED_Realm(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_Realm(jsi::Runtime& _env, std::shared_ptr<Realm> val);
jsi::Value RealmCoordinator_clear_all_caches([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<_impl::RealmCoordinator>& JS_TO_SHARED_RealmCoordinator(jsi::Runtime& _env,
                                                                                               const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_RealmCoordinator(jsi::Runtime& _env,
                                                            std::shared_ptr<_impl::RealmCoordinator> val);
jsi::Value STRUCT_TO_JS_ObjectChangeSet(jsi::Runtime& _env, const ObjectChangeSet& in);
jsi::Value ObjectNotifier_add_callback([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<_impl::ObjectNotifier>& JS_TO_SHARED_ObjectNotifier(jsi::Runtime& _env,
                                                                                           const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_ObjectNotifier(jsi::Runtime& _env,
                                                          std::shared_ptr<_impl::ObjectNotifier> val);
jsi::Value NotificationToken_unregister([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value NotificationToken_for_object([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] NotificationToken& JS_TO_CLASS_NotificationToken(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_NotificationToken(jsi::Runtime& _env, NotificationToken val);
jsi::Value IndexSet_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] IndexSet& JS_TO_CLASS_IndexSet(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_IndexSet(jsi::Runtime& _env, IndexSet val);
jsi::Value Collection_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_as_results([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_snapshot([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_get_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_get_object_schema([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_size([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Collection_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] object_store::Collection& JS_TO_CLASS_Collection(jsi::Runtime& _env, const jsi::Value& val);
jsi::Value List_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_get_dictionary([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_move([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_remove([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_swap([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_delete_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_insert_embedded([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_insert_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_set_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_set_embedded([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_set_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value List_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] List& JS_TO_CLASS_List(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_List(jsi::Runtime& _env, List val);
jsi::Value Set_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Set_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Set_remove_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Set_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Set_delete_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Set_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] object_store::Set& JS_TO_CLASS_Set(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Set(jsi::Runtime& _env, object_store::Set val);
jsi::Value Dictionary_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_get_dictionary([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_contains([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_DictionaryChangeSet(jsi::Runtime& _env, const DictionaryChangeSet& in);
jsi::Value Dictionary_add_key_based_notification_callback([[maybe_unused]] jsi::Runtime& _env,
                                                          [[maybe_unused]] const jsi::Value& thisValue,
                                                          [[maybe_unused]] const jsi::Value* args,
                                                          [[maybe_unused]] size_t count);
jsi::Value Dictionary_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_insert_embedded([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_insert_collection([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_try_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_try_erase([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_get_keys([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_get_values([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value Dictionary_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] object_store::Dictionary& JS_TO_CLASS_Dictionary(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_Dictionary(jsi::Runtime& _env, object_store::Dictionary val);
jsi::Value GoogleAuthCode_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] app::AuthCode& JS_TO_CLASS_GoogleAuthCode(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_GoogleAuthCode(jsi::Runtime& _env, app::AuthCode val);
jsi::Value GoogleIdToken_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] app::IdToken& JS_TO_CLASS_GoogleIdToken(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_GoogleIdToken(jsi::Runtime& _env, app::IdToken val);
jsi::Value AppCredentials_facebook([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value AppCredentials_anonymous([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value AppCredentials_apple([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value AppCredentials_google_auth([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value AppCredentials_google_id([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value AppCredentials_custom([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value AppCredentials_username_password([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value AppCredentials_function([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value AppCredentials_api_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] app::AppCredentials& JS_TO_CLASS_AppCredentials(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_AppCredentials(jsi::Runtime& _env, app::AppCredentials val);
[[maybe_unused]] app::User::Token& JS_TO_CLASS_UserSubscriptionToken(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_UserSubscriptionToken(jsi::Runtime& _env, app::User::Token val);
jsi::Value SyncUser_is_logged_in([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<SyncUser>& JS_TO_SHARED_SyncUser(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_SyncUser(jsi::Runtime& _env, std::shared_ptr<SyncUser> val);
jsi::Value User_subscribe([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_unsubscribe([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_path_for_realm([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_access_token_refresh_required([[maybe_unused]] jsi::Runtime& _env,
                                              [[maybe_unused]] const jsi::Value& thisValue,
                                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_request_refresh_location([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_request_access_token([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_track_realm([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_user_id([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_app_id([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_legacy_identities([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_access_token([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_refresh_token([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_state([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_device_id([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_has_device_id([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_user_profile([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_UserIdentity(jsi::Runtime& _env, const app::UserIdentity& in);
jsi::Value User_identities([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_custom_data([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value User_app([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<app::User>& JS_TO_SHARED_User(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_User(jsi::Runtime& _env, std::shared_ptr<app::User> val);
jsi::Value UserProfile_data([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] app::UserProfile& JS_TO_CLASS_UserProfile(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_UserProfile(jsi::Runtime& _env, app::UserProfile val);
[[maybe_unused]] app::App::Token& JS_TO_CLASS_AppSubscriptionToken(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_AppSubscriptionToken(jsi::Runtime& _env, app::App::Token val);
jsi::Value App_log_in_with_credentials([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_log_out_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_refresh_custom_data([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_link_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_switch_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_remove_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_delete_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_usernamePasswordProviderClient([[maybe_unused]] jsi::Runtime& _env,
                                              [[maybe_unused]] const jsi::Value& thisValue,
                                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_userAPIKeyProviderClient([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_push_notification_client([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_subscribe([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_unsubscribe([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_call_function([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_make_streaming_request([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_update_base_url([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_get_base_url([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_immediately_run_file_actions([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
app::AppConfig::DeviceInfo STRUCT_FROM_JS_DeviceInfo(jsi::Runtime& _env, auto&& val);
sync::ResumptionDelayInfo STRUCT_FROM_JS_ResumptionDelayInfo(jsi::Runtime& _env, auto&& val);
SyncClientTimeouts STRUCT_FROM_JS_SyncClientTimeouts(jsi::Runtime& _env, auto&& val);
SyncClientConfig STRUCT_FROM_JS_SyncClientConfig(jsi::Runtime& _env, auto&& val);
app::AppConfig STRUCT_FROM_JS_AppConfig(jsi::Runtime& _env, auto&& val);
jsi::Value App_get_app([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_clear_cached_apps([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_DeviceInfo(jsi::Runtime& _env, const app::AppConfig::DeviceInfo& in);
jsi::Value STRUCT_TO_JS_ResumptionDelayInfo(jsi::Runtime& _env, const sync::ResumptionDelayInfo& in);
jsi::Value STRUCT_TO_JS_SyncClientTimeouts(jsi::Runtime& _env, const SyncClientTimeouts& in);
jsi::Value STRUCT_TO_JS_SyncClientConfig(jsi::Runtime& _env, const SyncClientConfig& in);
jsi::Value STRUCT_TO_JS_AppConfig(jsi::Runtime& _env, const app::AppConfig& in);
jsi::Value App_config([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_current_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_all_users([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value App_sync_manager([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<app::App>& JS_TO_SHARED_App(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_App(jsi::Runtime& _env, std::shared_ptr<app::App> val);
jsi::Value WatchStream_next_event([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value WatchStream_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value WatchStream_state([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value WatchStream_error([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] app::WatchStream& JS_TO_CLASS_WatchStream(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_WatchStream(jsi::Runtime& _env, app::WatchStream val);
jsi::Value PushClient_register_device([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value PushClient_deregister_device([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] app::PushClient& JS_TO_CLASS_PushClient(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_PushClient(jsi::Runtime& _env, app::PushClient val);
jsi::Value UsernamePasswordProviderClient_register_email([[maybe_unused]] jsi::Runtime& _env,
                                                         [[maybe_unused]] const jsi::Value& thisValue,
                                                         [[maybe_unused]] const jsi::Value* args,
                                                         [[maybe_unused]] size_t count);
jsi::Value UsernamePasswordProviderClient_retry_custom_confirmation([[maybe_unused]] jsi::Runtime& _env,
                                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                                    [[maybe_unused]] const jsi::Value* args,
                                                                    [[maybe_unused]] size_t count);
jsi::Value UsernamePasswordProviderClient_confirm_user([[maybe_unused]] jsi::Runtime& _env,
                                                       [[maybe_unused]] const jsi::Value& thisValue,
                                                       [[maybe_unused]] const jsi::Value* args,
                                                       [[maybe_unused]] size_t count);
jsi::Value UsernamePasswordProviderClient_resend_confirmation_email([[maybe_unused]] jsi::Runtime& _env,
                                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                                    [[maybe_unused]] const jsi::Value* args,
                                                                    [[maybe_unused]] size_t count);
jsi::Value UsernamePasswordProviderClient_reset_password([[maybe_unused]] jsi::Runtime& _env,
                                                         [[maybe_unused]] const jsi::Value& thisValue,
                                                         [[maybe_unused]] const jsi::Value* args,
                                                         [[maybe_unused]] size_t count);
jsi::Value UsernamePasswordProviderClient_send_reset_password_email([[maybe_unused]] jsi::Runtime& _env,
                                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                                    [[maybe_unused]] const jsi::Value* args,
                                                                    [[maybe_unused]] size_t count);
jsi::Value UsernamePasswordProviderClient_call_reset_password_function([[maybe_unused]] jsi::Runtime& _env,
                                                                       [[maybe_unused]] const jsi::Value& thisValue,
                                                                       [[maybe_unused]] const jsi::Value* args,
                                                                       [[maybe_unused]] size_t count);
[[maybe_unused]] app::App::UsernamePasswordProviderClient&
JS_TO_CLASS_UsernamePasswordProviderClient(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value
JS_FROM_CLASS_UsernamePasswordProviderClient(jsi::Runtime& _env, app::App::UsernamePasswordProviderClient val);
jsi::Value STRUCT_TO_JS_UserAPIKey(jsi::Runtime& _env, const app::App::UserAPIKey& in);
jsi::Value UserAPIKeyProviderClient_create_api_key([[maybe_unused]] jsi::Runtime& _env,
                                                   [[maybe_unused]] const jsi::Value& thisValue,
                                                   [[maybe_unused]] const jsi::Value* args,
                                                   [[maybe_unused]] size_t count);
jsi::Value UserAPIKeyProviderClient_fetch_api_key([[maybe_unused]] jsi::Runtime& _env,
                                                  [[maybe_unused]] const jsi::Value& thisValue,
                                                  [[maybe_unused]] const jsi::Value* args,
                                                  [[maybe_unused]] size_t count);
jsi::Value UserAPIKeyProviderClient_fetch_api_keys([[maybe_unused]] jsi::Runtime& _env,
                                                   [[maybe_unused]] const jsi::Value& thisValue,
                                                   [[maybe_unused]] const jsi::Value* args,
                                                   [[maybe_unused]] size_t count);
jsi::Value UserAPIKeyProviderClient_delete_api_key([[maybe_unused]] jsi::Runtime& _env,
                                                   [[maybe_unused]] const jsi::Value& thisValue,
                                                   [[maybe_unused]] const jsi::Value* args,
                                                   [[maybe_unused]] size_t count);
jsi::Value UserAPIKeyProviderClient_enable_api_key([[maybe_unused]] jsi::Runtime& _env,
                                                   [[maybe_unused]] const jsi::Value& thisValue,
                                                   [[maybe_unused]] const jsi::Value* args,
                                                   [[maybe_unused]] size_t count);
jsi::Value UserAPIKeyProviderClient_disable_api_key([[maybe_unused]] jsi::Runtime& _env,
                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                    [[maybe_unused]] const jsi::Value* args,
                                                    [[maybe_unused]] size_t count);
[[maybe_unused]] app::App::UserAPIKeyProviderClient& JS_TO_CLASS_UserAPIKeyProviderClient(jsi::Runtime& _env,
                                                                                          const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_UserAPIKeyProviderClient(jsi::Runtime& _env,
                                                                   app::App::UserAPIKeyProviderClient val);
[[maybe_unused]] std::function<std::shared_ptr<util::Logger>(util::Logger::Level)>&
JS_TO_CLASS_LoggerFactory(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value
JS_FROM_CLASS_LoggerFactory(jsi::Runtime& _env,
                            std::function<std::shared_ptr<util::Logger>(util::Logger::Level)> val);
jsi::Value SyncManager_set_session_multiplexing([[maybe_unused]] jsi::Runtime& _env,
                                                [[maybe_unused]] const jsi::Value& thisValue,
                                                [[maybe_unused]] const jsi::Value* args,
                                                [[maybe_unused]] size_t count);
jsi::Value SyncManager_set_log_level([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncManager_set_logger_factory([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncManager_set_user_agent([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncManager_reconnect([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncManager_get_existing_active_session([[maybe_unused]] jsi::Runtime& _env,
                                                   [[maybe_unused]] const jsi::Value& thisValue,
                                                   [[maybe_unused]] const jsi::Value* args,
                                                   [[maybe_unused]] size_t count);
jsi::Value SyncManager_get_all_sessions_for([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncManager_has_existing_sessions([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<SyncManager>& JS_TO_SHARED_SyncManager(jsi::Runtime& _env,
                                                                              const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_SyncManager(jsi::Runtime& _env, std::shared_ptr<SyncManager> val);
[[maybe_unused]] ThreadSafeReference& JS_TO_CLASS_ThreadSafeReference(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_ThreadSafeReference(jsi::Runtime& _env, ThreadSafeReference val);
jsi::Value AsyncOpenTask_start([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value AsyncOpenTask_cancel([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value AsyncOpenTask_register_download_progress_notifier([[maybe_unused]] jsi::Runtime& _env,
                                                             [[maybe_unused]] const jsi::Value& thisValue,
                                                             [[maybe_unused]] const jsi::Value* args,
                                                             [[maybe_unused]] size_t count);
jsi::Value AsyncOpenTask_unregister_download_progress_notifier([[maybe_unused]] jsi::Runtime& _env,
                                                               [[maybe_unused]] const jsi::Value& thisValue,
                                                               [[maybe_unused]] const jsi::Value* args,
                                                               [[maybe_unused]] size_t count);
jsi::Value AsyncOpenTask_DOLLAR_resetSharedPtr([[maybe_unused]] jsi::Runtime& _env,
                                               [[maybe_unused]] const jsi::Value& thisValue,
                                               [[maybe_unused]] const jsi::Value* args,
                                               [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<AsyncOpenTask>& JS_TO_SHARED_AsyncOpenTask(jsi::Runtime& _env,
                                                                                  const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_AsyncOpenTask(jsi::Runtime& _env, std::shared_ptr<AsyncOpenTask> val);
jsi::Value SyncSession_wait_for_upload_completion([[maybe_unused]] jsi::Runtime& _env,
                                                  [[maybe_unused]] const jsi::Value& thisValue,
                                                  [[maybe_unused]] const jsi::Value* args,
                                                  [[maybe_unused]] size_t count);
jsi::Value SyncSession_wait_for_download_completion([[maybe_unused]] jsi::Runtime& _env,
                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                    [[maybe_unused]] const jsi::Value* args,
                                                    [[maybe_unused]] size_t count);
jsi::Value SyncSession_register_progress_notifier([[maybe_unused]] jsi::Runtime& _env,
                                                  [[maybe_unused]] const jsi::Value& thisValue,
                                                  [[maybe_unused]] const jsi::Value* args,
                                                  [[maybe_unused]] size_t count);
jsi::Value SyncSession_unregister_progress_notifier([[maybe_unused]] jsi::Runtime& _env,
                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                    [[maybe_unused]] const jsi::Value* args,
                                                    [[maybe_unused]] size_t count);
jsi::Value SyncSession_register_connection_change_callback([[maybe_unused]] jsi::Runtime& _env,
                                                           [[maybe_unused]] const jsi::Value& thisValue,
                                                           [[maybe_unused]] const jsi::Value* args,
                                                           [[maybe_unused]] size_t count);
jsi::Value SyncSession_unregister_connection_change_callback([[maybe_unused]] jsi::Runtime& _env,
                                                             [[maybe_unused]] const jsi::Value& thisValue,
                                                             [[maybe_unused]] const jsi::Value* args,
                                                             [[maybe_unused]] size_t count);
jsi::Value SyncSession_revive_if_needed([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSession_handle_reconnect([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSession_force_close([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_SaltedFileIdent(jsi::Runtime& _env, const sync::SaltedFileIdent& in);
jsi::Value SyncSession_get_file_ident([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSession_state([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSession_connection_state([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSession_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSession_config([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSession_full_realm_url([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSession_DOLLAR_resetSharedPtr([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] const std::shared_ptr<SyncSession>& JS_TO_SHARED_SyncSession(jsi::Runtime& _env,
                                                                              const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_SyncSession(jsi::Runtime& _env, std::shared_ptr<SyncSession> val);
[[maybe_unused]] std::function<SyncConfig::SSLVerifyCallback>& JS_TO_CLASS_SSLVerifyCallback(jsi::Runtime& _env,
                                                                                             const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_SSLVerifyCallback(jsi::Runtime& _env,
                                                            std::function<SyncConfig::SSLVerifyCallback> val);
jsi::Value SyncSubscriptionSet_make_mutable_copy([[maybe_unused]] jsi::Runtime& _env,
                                                 [[maybe_unused]] const jsi::Value& thisValue,
                                                 [[maybe_unused]] const jsi::Value* args,
                                                 [[maybe_unused]] size_t count);
jsi::Value SyncSubscriptionSet_get_state_change_notification([[maybe_unused]] jsi::Runtime& _env,
                                                             [[maybe_unused]] const jsi::Value& thisValue,
                                                             [[maybe_unused]] const jsi::Value* args,
                                                             [[maybe_unused]] size_t count);
jsi::Value STRUCT_TO_JS_SyncSubscription(jsi::Runtime& _env, const sync::Subscription& in);
jsi::Value SyncSubscriptionSet_find_by_name([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSubscriptionSet_find_by_query([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSubscriptionSet_refresh([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSubscriptionSet_version([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSubscriptionSet_state([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSubscriptionSet_error_str([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSubscriptionSet_size([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value SyncSubscriptionSet_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env,
                                               [[maybe_unused]] const jsi::Value& thisValue,
                                               [[maybe_unused]] const jsi::Value* args,
                                               [[maybe_unused]] size_t count);
[[maybe_unused]] sync::SubscriptionSet& JS_TO_CLASS_SyncSubscriptionSet(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_SyncSubscriptionSet(jsi::Runtime& _env, sync::SubscriptionSet val);
jsi::Value MutableSyncSubscriptionSet_clear([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value MutableSyncSubscriptionSet_insert_or_assign_by_name([[maybe_unused]] jsi::Runtime& _env,
                                                               [[maybe_unused]] const jsi::Value& thisValue,
                                                               [[maybe_unused]] const jsi::Value* args,
                                                               [[maybe_unused]] size_t count);
jsi::Value MutableSyncSubscriptionSet_insert_or_assign_by_query([[maybe_unused]] jsi::Runtime& _env,
                                                                [[maybe_unused]] const jsi::Value& thisValue,
                                                                [[maybe_unused]] const jsi::Value* args,
                                                                [[maybe_unused]] size_t count);
jsi::Value MutableSyncSubscriptionSet_erase_by_name([[maybe_unused]] jsi::Runtime& _env,
                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                    [[maybe_unused]] const jsi::Value* args,
                                                    [[maybe_unused]] size_t count);
jsi::Value MutableSyncSubscriptionSet_erase_by_query([[maybe_unused]] jsi::Runtime& _env,
                                                     [[maybe_unused]] const jsi::Value& thisValue,
                                                     [[maybe_unused]] const jsi::Value* args,
                                                     [[maybe_unused]] size_t count);
jsi::Value MutableSyncSubscriptionSet_commit([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] sync::MutableSubscriptionSet& JS_TO_CLASS_MutableSyncSubscriptionSet(jsi::Runtime& _env,
                                                                                      const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_MutableSyncSubscriptionSet(jsi::Runtime& _env,
                                                                     sync::MutableSubscriptionSet val);
[[maybe_unused]] const std::shared_ptr<util::Scheduler>& JS_TO_SHARED_Scheduler(jsi::Runtime& _env,
                                                                                const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_Scheduler(jsi::Runtime& _env, std::shared_ptr<util::Scheduler> val);
[[maybe_unused]] const std::shared_ptr<app::GenericNetworkTransport>&
JS_TO_SHARED_GenericNetworkTransport(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_SHARED_GenericNetworkTransport(jsi::Runtime& _env,
                                                                   std::shared_ptr<app::GenericNetworkTransport> val);
jsi::Value JsPlatformHelpers_set_default_realm_file_directory([[maybe_unused]] jsi::Runtime& _env,
                                                              [[maybe_unused]] const jsi::Value& thisValue,
                                                              [[maybe_unused]] const jsi::Value* args,
                                                              [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_default_realm_file_directory([[maybe_unused]] jsi::Runtime& _env,
                                                          [[maybe_unused]] const jsi::Value& thisValue,
                                                          [[maybe_unused]] const jsi::Value* args,
                                                          [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_ensure_directory_exists_for_file([[maybe_unused]] jsi::Runtime& _env,
                                                              [[maybe_unused]] const jsi::Value& thisValue,
                                                              [[maybe_unused]] const jsi::Value* args,
                                                              [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_copy_bundled_realm_files([[maybe_unused]] jsi::Runtime& _env,
                                                      [[maybe_unused]] const jsi::Value& thisValue,
                                                      [[maybe_unused]] const jsi::Value* args,
                                                      [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_remove_realm_files_from_directory([[maybe_unused]] jsi::Runtime& _env,
                                                               [[maybe_unused]] const jsi::Value& thisValue,
                                                               [[maybe_unused]] const jsi::Value* args,
                                                               [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_remove_file([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_remove_directory([[maybe_unused]] jsi::Runtime& _env,
                                              [[maybe_unused]] const jsi::Value& thisValue,
                                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_exclude_from_icloud_backup([[maybe_unused]] jsi::Runtime& _env,
                                                        [[maybe_unused]] const jsi::Value& thisValue,
                                                        [[maybe_unused]] const jsi::Value* args,
                                                        [[maybe_unused]] size_t count);
jsi::Value JsPlatformHelpers_get_cpu_arch([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] JsPlatformHelpers& JS_TO_CLASS_JsPlatformHelpers(jsi::Runtime& _env, const jsi::Value& val);
jsi::Value WeakSyncSession_raw_dereference([[maybe_unused]] jsi::Runtime& _env,
                                           [[maybe_unused]] const jsi::Value& thisValue,
                                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value WeakSyncSession_weak_copy_of([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
[[maybe_unused]] std::weak_ptr<SyncSession>& JS_TO_CLASS_WeakSyncSession(jsi::Runtime& _env, const jsi::Value& val);
[[maybe_unused]] jsi::Value JS_FROM_CLASS_WeakSyncSession(jsi::Runtime& _env, std::weak_ptr<SyncSession> val);
jsi::Value JS_FROM_Mixed(jsi::Runtime& _env, Mixed val);
Mixed JS_TO_Mixed(jsi::Runtime& _env, auto&& val);
int64_t bigIntToI64(jsi::Runtime& _env, auto&& val);
uint64_t bigIntToU64(jsi::Runtime& _env, auto&& val);
jsi::Value bigIntFromI64(jsi::Runtime& _env, int64_t val);
jsi::Value bigIntFromU64(jsi::Runtime& _env, uint64_t val);
jsi::Value createWeakRef([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
jsi::Value lockWeakRef([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
class RealmAddon {
public:
    inline const std::string& wrapString(std::string str);
    inline auto startCall();
    jsi::Value injectInjectables([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count);
    RealmAddon(jsi::Runtime& _env, jsi::Object& exports);

    std::deque<std::string> m_string_bufs;
    static std::unique_ptr<RealmAddon> self;
    jsi::Runtime& m_rt;
    const bool m_on_hermes;
    std::optional<jsi::Function> m_cls_Long_ctor;
    std::optional<jsi::Function> m_cls_ArrayBuffer_ctor;
    std::optional<jsi::Function> m_cls_Float_ctor;
    std::optional<jsi::Function> m_cls_UUID_ctor;
    std::optional<jsi::Function> m_cls_ObjectId_ctor;
    std::optional<jsi::Function> m_cls_Decimal128_ctor;
    std::optional<jsi::Function> m_cls_EJSON_parse_ctor;
    std::optional<jsi::Function> m_cls_EJSON_stringify_ctor;
    std::optional<jsi::Function> m_cls_Symbol_for_ctor;
    std::optional<jsi::Function> m_cls_Helpers_ctor;
    std::optional<jsi::Function> m_cls_LogCategoryRef_ctor;
    std::optional<jsi::Function> m_cls_Logger_ctor;
    std::optional<jsi::Function> m_cls_ConstTableRef_ctor;
    std::optional<jsi::Function> m_cls_TableRef_ctor;
    std::optional<jsi::Function> m_cls_Obj_ctor;
    std::optional<jsi::Function> m_cls_Transaction_ctor;
    std::optional<jsi::Function> m_cls_ObjectStore_ctor;
    std::optional<jsi::Function> m_cls_Timestamp_ctor;
    std::optional<jsi::Function> m_cls_Geospatial_ctor;
    std::optional<jsi::Function> m_cls_ObjLink_ctor;
    std::optional<jsi::Function> m_cls_KeyPathMapping_ctor;
    std::optional<jsi::Function> m_cls_Query_ctor;
    std::optional<jsi::Function> m_cls_SortDescriptor_ctor;
    std::optional<jsi::Function> m_cls_TableView_ctor;
    std::optional<jsi::Function> m_cls_Results_ctor;
    std::optional<jsi::Function> m_cls_Realm_ctor;
    std::optional<jsi::Function> m_cls_RealmCoordinator_ctor;
    std::optional<jsi::Function> m_cls_ObjectNotifier_ctor;
    std::optional<jsi::Function> m_cls_NotificationToken_ctor;
    std::optional<jsi::Function> m_cls_IndexSet_ctor;
    std::optional<jsi::Function> m_cls_Collection_ctor;
    std::optional<jsi::Function> m_cls_List_ctor;
    std::optional<jsi::Function> m_cls_Set_ctor;
    std::optional<jsi::Function> m_cls_Dictionary_ctor;
    std::optional<jsi::Function> m_cls_GoogleAuthCode_ctor;
    std::optional<jsi::Function> m_cls_GoogleIdToken_ctor;
    std::optional<jsi::Function> m_cls_AppCredentials_ctor;
    std::optional<jsi::Function> m_cls_UserSubscriptionToken_ctor;
    std::optional<jsi::Function> m_cls_SyncUser_ctor;
    std::optional<jsi::Function> m_cls_User_ctor;
    std::optional<jsi::Function> m_cls_UserProfile_ctor;
    std::optional<jsi::Function> m_cls_AppSubscriptionToken_ctor;
    std::optional<jsi::Function> m_cls_App_ctor;
    std::optional<jsi::Function> m_cls_WatchStream_ctor;
    std::optional<jsi::Function> m_cls_PushClient_ctor;
    std::optional<jsi::Function> m_cls_UsernamePasswordProviderClient_ctor;
    std::optional<jsi::Function> m_cls_UserApiKeyProviderClient_ctor;
    std::optional<jsi::Function> m_cls_LoggerFactory_ctor;
    std::optional<jsi::Function> m_cls_SyncManager_ctor;
    std::optional<jsi::Function> m_cls_ThreadSafeReference_ctor;
    std::optional<jsi::Function> m_cls_AsyncOpenTask_ctor;
    std::optional<jsi::Function> m_cls_SyncSession_ctor;
    std::optional<jsi::Function> m_cls_SslVerifyCallback_ctor;
    std::optional<jsi::Function> m_cls_SyncSubscriptionSet_ctor;
    std::optional<jsi::Function> m_cls_MutableSyncSubscriptionSet_ctor;
    std::optional<jsi::Function> m_cls_Scheduler_ctor;
    std::optional<jsi::Function> m_cls_GenericNetworkTransport_ctor;
    std::optional<jsi::Function> m_cls_JsPlatformHelpers_ctor;
    std::optional<jsi::Function> m_cls_WeakSyncSession_ctor;
    std::optional<jsi::Function> m_cls_Helpers_extractor;
    std::optional<jsi::Function> m_cls_LogCategoryRef_extractor;
    std::optional<jsi::Function> m_cls_Logger_extractor;
    std::optional<jsi::Function> m_cls_ConstTableRef_extractor;
    std::optional<jsi::Function> m_cls_TableRef_extractor;
    std::optional<jsi::Function> m_cls_Obj_extractor;
    std::optional<jsi::Function> m_cls_Transaction_extractor;
    std::optional<jsi::Function> m_cls_ObjectStore_extractor;
    std::optional<jsi::Function> m_cls_Timestamp_extractor;
    std::optional<jsi::Function> m_cls_Geospatial_extractor;
    std::optional<jsi::Function> m_cls_ObjLink_extractor;
    std::optional<jsi::Function> m_cls_KeyPathMapping_extractor;
    std::optional<jsi::Function> m_cls_Query_extractor;
    std::optional<jsi::Function> m_cls_SortDescriptor_extractor;
    std::optional<jsi::Function> m_cls_TableView_extractor;
    std::optional<jsi::Function> m_cls_Results_extractor;
    std::optional<jsi::Function> m_cls_Realm_extractor;
    std::optional<jsi::Function> m_cls_RealmCoordinator_extractor;
    std::optional<jsi::Function> m_cls_ObjectNotifier_extractor;
    std::optional<jsi::Function> m_cls_NotificationToken_extractor;
    std::optional<jsi::Function> m_cls_IndexSet_extractor;
    std::optional<jsi::Function> m_cls_Collection_extractor;
    std::optional<jsi::Function> m_cls_List_extractor;
    std::optional<jsi::Function> m_cls_Set_extractor;
    std::optional<jsi::Function> m_cls_Dictionary_extractor;
    std::optional<jsi::Function> m_cls_GoogleAuthCode_extractor;
    std::optional<jsi::Function> m_cls_GoogleIdToken_extractor;
    std::optional<jsi::Function> m_cls_AppCredentials_extractor;
    std::optional<jsi::Function> m_cls_UserSubscriptionToken_extractor;
    std::optional<jsi::Function> m_cls_SyncUser_extractor;
    std::optional<jsi::Function> m_cls_User_extractor;
    std::optional<jsi::Function> m_cls_UserProfile_extractor;
    std::optional<jsi::Function> m_cls_AppSubscriptionToken_extractor;
    std::optional<jsi::Function> m_cls_App_extractor;
    std::optional<jsi::Function> m_cls_WatchStream_extractor;
    std::optional<jsi::Function> m_cls_PushClient_extractor;
    std::optional<jsi::Function> m_cls_UsernamePasswordProviderClient_extractor;
    std::optional<jsi::Function> m_cls_UserApiKeyProviderClient_extractor;
    std::optional<jsi::Function> m_cls_LoggerFactory_extractor;
    std::optional<jsi::Function> m_cls_SyncManager_extractor;
    std::optional<jsi::Function> m_cls_ThreadSafeReference_extractor;
    std::optional<jsi::Function> m_cls_AsyncOpenTask_extractor;
    std::optional<jsi::Function> m_cls_SyncSession_extractor;
    std::optional<jsi::Function> m_cls_SslVerifyCallback_extractor;
    std::optional<jsi::Function> m_cls_SyncSubscriptionSet_extractor;
    std::optional<jsi::Function> m_cls_MutableSyncSubscriptionSet_extractor;
    std::optional<jsi::Function> m_cls_Scheduler_extractor;
    std::optional<jsi::Function> m_cls_GenericNetworkTransport_extractor;
    std::optional<jsi::Function> m_cls_JsPlatformHelpers_extractor;
    std::optional<jsi::Function> m_cls_WeakSyncSession_extractor;
    jsi::PropNameID m_prop_didChange;
    jsi::PropNameID m_prop_bind;
    jsi::PropNameID m_prop_beforeNotify;
    jsi::PropNameID m_prop_schemaDidChange;
    jsi::PropNameID m_prop_method;
    jsi::PropNameID m_prop_url;
    jsi::PropNameID m_prop_timeoutMs;
    jsi::PropNameID m_prop_headers;
    jsi::PropNameID m_prop_body;
    jsi::PropNameID m_prop_callback;
    jsi::PropNameID m_prop_httpStatusCode;
    jsi::PropNameID m_prop_customStatusCode;
    jsi::PropNameID m_prop_id;
    jsi::PropNameID m_prop_createdAt;
    jsi::PropNameID m_prop_updatedAt;
    jsi::PropNameID m_prop_name;
    jsi::PropNameID m_prop_objectClassName;
    jsi::PropNameID m_prop_queryString;
    jsi::PropNameID m_prop_path;
    jsi::PropNameID m_prop_cache;
    jsi::PropNameID m_prop_encryptionKey;
    jsi::PropNameID m_prop_fifoFilesFallbackPath;
    jsi::PropNameID m_prop_inMemory;
    jsi::PropNameID m_prop_schema;
    jsi::PropNameID m_prop_persistedProperties;
    jsi::PropNameID m_prop_publicName;
    jsi::PropNameID m_prop_type;
    jsi::PropNameID m_prop_objectType;
    jsi::PropNameID m_prop_linkOriginPropertyName;
    jsi::PropNameID m_prop_isPrimary;
    jsi::PropNameID m_prop_isIndexed;
    jsi::PropNameID m_prop_isFulltextIndexed;
    jsi::PropNameID m_prop_columnKey;
    jsi::PropNameID m_prop_computedProperties;
    jsi::PropNameID m_prop_primaryKey;
    jsi::PropNameID m_prop_tableKey;
    jsi::PropNameID m_prop_tableType;
    jsi::PropNameID m_prop_schemaVersion;
    jsi::PropNameID m_prop_schemaMode;
    jsi::PropNameID m_prop_disableFormatUpgrade;
    jsi::PropNameID m_prop_syncConfig;
    jsi::PropNameID m_prop_user;
    jsi::PropNameID m_prop_partitionValue;
    jsi::PropNameID m_prop_stopPolicy;
    jsi::PropNameID m_prop_flxSyncRequested;
    jsi::PropNameID m_prop_errorHandler;
    jsi::PropNameID m_prop_status;
    jsi::PropNameID m_prop_isFatal;
    jsi::PropNameID m_prop_simpleMessage;
    jsi::PropNameID m_prop_logUrl;
    jsi::PropNameID m_prop_userInfo;
    jsi::PropNameID m_prop_isClientResetRequested;
    jsi::PropNameID m_prop_compensatingWritesInfo;
    jsi::PropNameID m_prop_objectName;
    jsi::PropNameID m_prop_reason;
    jsi::PropNameID m_prop_customHttpHeaders;
    jsi::PropNameID m_prop_clientValidateSsl;
    jsi::PropNameID m_prop_sslTrustCertificatePath;
    jsi::PropNameID m_prop_sslVerifyCallback;
    jsi::PropNameID m_prop_clientResyncMode;
    jsi::PropNameID m_prop_notifyBeforeClientReset;
    jsi::PropNameID m_prop_notifyAfterClientReset;
    jsi::PropNameID m_prop_cancelWaitsOnNonfatalError;
    jsi::PropNameID m_prop_proxyConfig;
    jsi::PropNameID m_prop_address;
    jsi::PropNameID m_prop_port;
    jsi::PropNameID m_prop_forceSyncHistory;
    jsi::PropNameID m_prop_migrationFunction;
    jsi::PropNameID m_prop_initializationFunction;
    jsi::PropNameID m_prop_shouldCompactOnLaunchFunction;
    jsi::PropNameID m_prop_automaticallyHandleBacklinksInMigrations;
    jsi::PropNameID m_prop_next;
    jsi::PropNameID m_prop_done;
    jsi::PropNameID m_prop_value;
    jsi::PropNameID m_prop_radiusRadians;
    jsi::PropNameID m_prop_center;
    jsi::PropNameID m_prop_longitude;
    jsi::PropNameID m_prop_latitude;
    jsi::PropNameID m_prop_altitude;
    jsi::PropNameID m_prop_lo;
    jsi::PropNameID m_prop_hi;
    jsi::PropNameID m_prop_points;
    jsi::PropNameID m_prop_deletions;
    jsi::PropNameID m_prop_insertions;
    jsi::PropNameID m_prop_modifications;
    jsi::PropNameID m_prop_modificationsNew;
    jsi::PropNameID m_prop_isDeleted;
    jsi::PropNameID m_prop_changedColumns;
    jsi::PropNameID m_prop_code;
    jsi::PropNameID m_prop_providerType;
    jsi::PropNameID m_prop_appId;
    jsi::PropNameID m_prop_transport;
    jsi::PropNameID m_prop_baseUrl;
    jsi::PropNameID m_prop_defaultRequestTimeoutMs;
    jsi::PropNameID m_prop_deviceInfo;
    jsi::PropNameID m_prop_platformVersion;
    jsi::PropNameID m_prop_sdkVersion;
    jsi::PropNameID m_prop_sdk;
    jsi::PropNameID m_prop_deviceName;
    jsi::PropNameID m_prop_deviceVersion;
    jsi::PropNameID m_prop_frameworkName;
    jsi::PropNameID m_prop_frameworkVersion;
    jsi::PropNameID m_prop_bundleId;
    jsi::PropNameID m_prop_baseFilePath;
    jsi::PropNameID m_prop_syncClientConfig;
    jsi::PropNameID m_prop_multiplexSessions;
    jsi::PropNameID m_prop_userAgentBindingInfo;
    jsi::PropNameID m_prop_timeouts;
    jsi::PropNameID m_prop_connectTimeout;
    jsi::PropNameID m_prop_connectionLingerTime;
    jsi::PropNameID m_prop_pingKeepalivePeriod;
    jsi::PropNameID m_prop_pongKeepaliveTimeout;
    jsi::PropNameID m_prop_fastReconnectLimit;
    jsi::PropNameID m_prop_reconnectBackoffInfo;
    jsi::PropNameID m_prop_maxResumptionDelayInterval;
    jsi::PropNameID m_prop_resumptionDelayInterval;
    jsi::PropNameID m_prop_resumptionDelayBackoffMultiplier;
    jsi::PropNameID m_prop_delayJitterDivisor;
    jsi::PropNameID m_prop_metadataMode;
    jsi::PropNameID m_prop_customEncryptionKey;
    jsi::PropNameID m_prop_key;
    jsi::PropNameID m_prop_disabled;
    jsi::PropNameID m_prop_ident;
    jsi::PropNameID m_prop_salt;
    jsi::PropNameID m_prop_high;
    jsi::PropNameID m_prop_low;
};
std::unique_ptr<RealmAddon> RealmAddon::self;
const std::string& RealmAddon::wrapString(std::string str)
{
    return m_string_bufs.emplace_back(std::move(str));
}
auto RealmAddon::startCall()
{
    return ContainerResizer(m_string_bufs);
}
jsi::Value RealmAddon::injectInjectables([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    auto ctors = args[0].asObject(_env);
    m_cls_Long_ctor = ctors.getProperty(_env, "Long").asObject(_env).asFunction(_env);
    m_cls_ArrayBuffer_ctor = ctors.getProperty(_env, "ArrayBuffer").asObject(_env).asFunction(_env);
    m_cls_Float_ctor = ctors.getProperty(_env, "Float").asObject(_env).asFunction(_env);
    m_cls_UUID_ctor = ctors.getProperty(_env, "UUID").asObject(_env).asFunction(_env);
    m_cls_ObjectId_ctor = ctors.getProperty(_env, "ObjectId").asObject(_env).asFunction(_env);
    m_cls_Decimal128_ctor = ctors.getProperty(_env, "Decimal128").asObject(_env).asFunction(_env);
    m_cls_EJSON_parse_ctor = ctors.getProperty(_env, "EJSON_parse").asObject(_env).asFunction(_env);
    m_cls_EJSON_stringify_ctor = ctors.getProperty(_env, "EJSON_stringify").asObject(_env).asFunction(_env);
    m_cls_Symbol_for_ctor = ctors.getProperty(_env, "Symbol_for").asObject(_env).asFunction(_env);
    m_cls_Helpers_ctor = ctors.getProperty(_env, "Helpers").asObject(_env).asFunction(_env);
    m_cls_LogCategoryRef_ctor = ctors.getProperty(_env, "LogCategoryRef").asObject(_env).asFunction(_env);
    m_cls_Logger_ctor = ctors.getProperty(_env, "Logger").asObject(_env).asFunction(_env);
    m_cls_ConstTableRef_ctor = ctors.getProperty(_env, "ConstTableRef").asObject(_env).asFunction(_env);
    m_cls_TableRef_ctor = ctors.getProperty(_env, "TableRef").asObject(_env).asFunction(_env);
    m_cls_Obj_ctor = ctors.getProperty(_env, "Obj").asObject(_env).asFunction(_env);
    m_cls_Transaction_ctor = ctors.getProperty(_env, "Transaction").asObject(_env).asFunction(_env);
    m_cls_ObjectStore_ctor = ctors.getProperty(_env, "ObjectStore").asObject(_env).asFunction(_env);
    m_cls_Timestamp_ctor = ctors.getProperty(_env, "Timestamp").asObject(_env).asFunction(_env);
    m_cls_Geospatial_ctor = ctors.getProperty(_env, "Geospatial").asObject(_env).asFunction(_env);
    m_cls_ObjLink_ctor = ctors.getProperty(_env, "ObjLink").asObject(_env).asFunction(_env);
    m_cls_KeyPathMapping_ctor = ctors.getProperty(_env, "KeyPathMapping").asObject(_env).asFunction(_env);
    m_cls_Query_ctor = ctors.getProperty(_env, "Query").asObject(_env).asFunction(_env);
    m_cls_SortDescriptor_ctor = ctors.getProperty(_env, "SortDescriptor").asObject(_env).asFunction(_env);
    m_cls_TableView_ctor = ctors.getProperty(_env, "TableView").asObject(_env).asFunction(_env);
    m_cls_Results_ctor = ctors.getProperty(_env, "Results").asObject(_env).asFunction(_env);
    m_cls_Realm_ctor = ctors.getProperty(_env, "Realm").asObject(_env).asFunction(_env);
    m_cls_RealmCoordinator_ctor = ctors.getProperty(_env, "RealmCoordinator").asObject(_env).asFunction(_env);
    m_cls_ObjectNotifier_ctor = ctors.getProperty(_env, "ObjectNotifier").asObject(_env).asFunction(_env);
    m_cls_NotificationToken_ctor = ctors.getProperty(_env, "NotificationToken").asObject(_env).asFunction(_env);
    m_cls_IndexSet_ctor = ctors.getProperty(_env, "IndexSet").asObject(_env).asFunction(_env);
    m_cls_Collection_ctor = ctors.getProperty(_env, "Collection").asObject(_env).asFunction(_env);
    m_cls_List_ctor = ctors.getProperty(_env, "List").asObject(_env).asFunction(_env);
    m_cls_Set_ctor = ctors.getProperty(_env, "Set").asObject(_env).asFunction(_env);
    m_cls_Dictionary_ctor = ctors.getProperty(_env, "Dictionary").asObject(_env).asFunction(_env);
    m_cls_GoogleAuthCode_ctor = ctors.getProperty(_env, "GoogleAuthCode").asObject(_env).asFunction(_env);
    m_cls_GoogleIdToken_ctor = ctors.getProperty(_env, "GoogleIdToken").asObject(_env).asFunction(_env);
    m_cls_AppCredentials_ctor = ctors.getProperty(_env, "AppCredentials").asObject(_env).asFunction(_env);
    m_cls_UserSubscriptionToken_ctor =
        ctors.getProperty(_env, "UserSubscriptionToken").asObject(_env).asFunction(_env);
    m_cls_SyncUser_ctor = ctors.getProperty(_env, "SyncUser").asObject(_env).asFunction(_env);
    m_cls_User_ctor = ctors.getProperty(_env, "User").asObject(_env).asFunction(_env);
    m_cls_UserProfile_ctor = ctors.getProperty(_env, "UserProfile").asObject(_env).asFunction(_env);
    m_cls_AppSubscriptionToken_ctor = ctors.getProperty(_env, "AppSubscriptionToken").asObject(_env).asFunction(_env);
    m_cls_App_ctor = ctors.getProperty(_env, "App").asObject(_env).asFunction(_env);
    m_cls_WatchStream_ctor = ctors.getProperty(_env, "WatchStream").asObject(_env).asFunction(_env);
    m_cls_PushClient_ctor = ctors.getProperty(_env, "PushClient").asObject(_env).asFunction(_env);
    m_cls_UsernamePasswordProviderClient_ctor =
        ctors.getProperty(_env, "UsernamePasswordProviderClient").asObject(_env).asFunction(_env);
    m_cls_UserApiKeyProviderClient_ctor =
        ctors.getProperty(_env, "UserApiKeyProviderClient").asObject(_env).asFunction(_env);
    m_cls_LoggerFactory_ctor = ctors.getProperty(_env, "LoggerFactory").asObject(_env).asFunction(_env);
    m_cls_SyncManager_ctor = ctors.getProperty(_env, "SyncManager").asObject(_env).asFunction(_env);
    m_cls_ThreadSafeReference_ctor = ctors.getProperty(_env, "ThreadSafeReference").asObject(_env).asFunction(_env);
    m_cls_AsyncOpenTask_ctor = ctors.getProperty(_env, "AsyncOpenTask").asObject(_env).asFunction(_env);
    m_cls_SyncSession_ctor = ctors.getProperty(_env, "SyncSession").asObject(_env).asFunction(_env);
    m_cls_SslVerifyCallback_ctor = ctors.getProperty(_env, "SslVerifyCallback").asObject(_env).asFunction(_env);
    m_cls_SyncSubscriptionSet_ctor = ctors.getProperty(_env, "SyncSubscriptionSet").asObject(_env).asFunction(_env);
    m_cls_MutableSyncSubscriptionSet_ctor =
        ctors.getProperty(_env, "MutableSyncSubscriptionSet").asObject(_env).asFunction(_env);
    m_cls_Scheduler_ctor = ctors.getProperty(_env, "Scheduler").asObject(_env).asFunction(_env);
    m_cls_GenericNetworkTransport_ctor =
        ctors.getProperty(_env, "GenericNetworkTransport").asObject(_env).asFunction(_env);
    m_cls_JsPlatformHelpers_ctor = ctors.getProperty(_env, "JsPlatformHelpers").asObject(_env).asFunction(_env);
    m_cls_WeakSyncSession_ctor = ctors.getProperty(_env, "WeakSyncSession").asObject(_env).asFunction(_env);
    m_cls_Helpers_extractor = m_cls_Helpers_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_LogCategoryRef_extractor =
        m_cls_LogCategoryRef_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Logger_extractor = m_cls_Logger_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_ConstTableRef_extractor =
        m_cls_ConstTableRef_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_TableRef_extractor = m_cls_TableRef_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Obj_extractor = m_cls_Obj_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Transaction_extractor =
        m_cls_Transaction_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_ObjectStore_extractor =
        m_cls_ObjectStore_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Timestamp_extractor = m_cls_Timestamp_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Geospatial_extractor = m_cls_Geospatial_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_ObjLink_extractor = m_cls_ObjLink_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_KeyPathMapping_extractor =
        m_cls_KeyPathMapping_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Query_extractor = m_cls_Query_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_SortDescriptor_extractor =
        m_cls_SortDescriptor_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_TableView_extractor = m_cls_TableView_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Results_extractor = m_cls_Results_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Realm_extractor = m_cls_Realm_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_RealmCoordinator_extractor =
        m_cls_RealmCoordinator_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_ObjectNotifier_extractor =
        m_cls_ObjectNotifier_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_NotificationToken_extractor =
        m_cls_NotificationToken_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_IndexSet_extractor = m_cls_IndexSet_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Collection_extractor = m_cls_Collection_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_List_extractor = m_cls_List_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Set_extractor = m_cls_Set_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Dictionary_extractor = m_cls_Dictionary_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_GoogleAuthCode_extractor =
        m_cls_GoogleAuthCode_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_GoogleIdToken_extractor =
        m_cls_GoogleIdToken_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_AppCredentials_extractor =
        m_cls_AppCredentials_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_UserSubscriptionToken_extractor =
        m_cls_UserSubscriptionToken_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_SyncUser_extractor = m_cls_SyncUser_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_User_extractor = m_cls_User_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_UserProfile_extractor =
        m_cls_UserProfile_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_AppSubscriptionToken_extractor =
        m_cls_AppSubscriptionToken_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_App_extractor = m_cls_App_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_WatchStream_extractor =
        m_cls_WatchStream_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_PushClient_extractor = m_cls_PushClient_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_UsernamePasswordProviderClient_extractor =
        m_cls_UsernamePasswordProviderClient_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_UserApiKeyProviderClient_extractor =
        m_cls_UserApiKeyProviderClient_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_LoggerFactory_extractor =
        m_cls_LoggerFactory_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_SyncManager_extractor =
        m_cls_SyncManager_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_ThreadSafeReference_extractor =
        m_cls_ThreadSafeReference_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_AsyncOpenTask_extractor =
        m_cls_AsyncOpenTask_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_SyncSession_extractor =
        m_cls_SyncSession_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_SslVerifyCallback_extractor =
        m_cls_SslVerifyCallback_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_SyncSubscriptionSet_extractor =
        m_cls_SyncSubscriptionSet_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_MutableSyncSubscriptionSet_extractor =
        m_cls_MutableSyncSubscriptionSet_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_Scheduler_extractor = m_cls_Scheduler_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_GenericNetworkTransport_extractor =
        m_cls_GenericNetworkTransport_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_JsPlatformHelpers_extractor =
        m_cls_JsPlatformHelpers_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);
    m_cls_WeakSyncSession_extractor =
        m_cls_WeakSyncSession_ctor->getProperty(_env, "_extract").asObject(_env).asFunction(_env);

    return jsi::Value::undefined();
}
RealmAddon::RealmAddon(jsi::Runtime& _env, jsi::Object& exports)
    : m_rt(_env)
    , m_on_hermes(_env.global().getProperty(_env, "HermesInternal").isObject())
    , m_prop_didChange(jsi::PropNameID::forAscii(_env, "didChange"))
    , m_prop_bind(jsi::PropNameID::forAscii(_env, "bind"))
    , m_prop_beforeNotify(jsi::PropNameID::forAscii(_env, "beforeNotify"))
    , m_prop_schemaDidChange(jsi::PropNameID::forAscii(_env, "schemaDidChange"))
    , m_prop_method(jsi::PropNameID::forAscii(_env, "method"))
    , m_prop_url(jsi::PropNameID::forAscii(_env, "url"))
    , m_prop_timeoutMs(jsi::PropNameID::forAscii(_env, "timeoutMs"))
    , m_prop_headers(jsi::PropNameID::forAscii(_env, "headers"))
    , m_prop_body(jsi::PropNameID::forAscii(_env, "body"))
    , m_prop_callback(jsi::PropNameID::forAscii(_env, "callback"))
    , m_prop_httpStatusCode(jsi::PropNameID::forAscii(_env, "httpStatusCode"))
    , m_prop_customStatusCode(jsi::PropNameID::forAscii(_env, "customStatusCode"))
    , m_prop_id(jsi::PropNameID::forAscii(_env, "id"))
    , m_prop_createdAt(jsi::PropNameID::forAscii(_env, "createdAt"))
    , m_prop_updatedAt(jsi::PropNameID::forAscii(_env, "updatedAt"))
    , m_prop_name(jsi::PropNameID::forAscii(_env, "name"))
    , m_prop_objectClassName(jsi::PropNameID::forAscii(_env, "objectClassName"))
    , m_prop_queryString(jsi::PropNameID::forAscii(_env, "queryString"))
    , m_prop_path(jsi::PropNameID::forAscii(_env, "path"))
    , m_prop_cache(jsi::PropNameID::forAscii(_env, "cache"))
    , m_prop_encryptionKey(jsi::PropNameID::forAscii(_env, "encryptionKey"))
    , m_prop_fifoFilesFallbackPath(jsi::PropNameID::forAscii(_env, "fifoFilesFallbackPath"))
    , m_prop_inMemory(jsi::PropNameID::forAscii(_env, "inMemory"))
    , m_prop_schema(jsi::PropNameID::forAscii(_env, "schema"))
    , m_prop_persistedProperties(jsi::PropNameID::forAscii(_env, "persistedProperties"))
    , m_prop_publicName(jsi::PropNameID::forAscii(_env, "publicName"))
    , m_prop_type(jsi::PropNameID::forAscii(_env, "type"))
    , m_prop_objectType(jsi::PropNameID::forAscii(_env, "objectType"))
    , m_prop_linkOriginPropertyName(jsi::PropNameID::forAscii(_env, "linkOriginPropertyName"))
    , m_prop_isPrimary(jsi::PropNameID::forAscii(_env, "isPrimary"))
    , m_prop_isIndexed(jsi::PropNameID::forAscii(_env, "isIndexed"))
    , m_prop_isFulltextIndexed(jsi::PropNameID::forAscii(_env, "isFulltextIndexed"))
    , m_prop_columnKey(jsi::PropNameID::forAscii(_env, "columnKey"))
    , m_prop_computedProperties(jsi::PropNameID::forAscii(_env, "computedProperties"))
    , m_prop_primaryKey(jsi::PropNameID::forAscii(_env, "primaryKey"))
    , m_prop_tableKey(jsi::PropNameID::forAscii(_env, "tableKey"))
    , m_prop_tableType(jsi::PropNameID::forAscii(_env, "tableType"))
    , m_prop_schemaVersion(jsi::PropNameID::forAscii(_env, "schemaVersion"))
    , m_prop_schemaMode(jsi::PropNameID::forAscii(_env, "schemaMode"))
    , m_prop_disableFormatUpgrade(jsi::PropNameID::forAscii(_env, "disableFormatUpgrade"))
    , m_prop_syncConfig(jsi::PropNameID::forAscii(_env, "syncConfig"))
    , m_prop_user(jsi::PropNameID::forAscii(_env, "user"))
    , m_prop_partitionValue(jsi::PropNameID::forAscii(_env, "partitionValue"))
    , m_prop_stopPolicy(jsi::PropNameID::forAscii(_env, "stopPolicy"))
    , m_prop_flxSyncRequested(jsi::PropNameID::forAscii(_env, "flxSyncRequested"))
    , m_prop_errorHandler(jsi::PropNameID::forAscii(_env, "errorHandler"))
    , m_prop_status(jsi::PropNameID::forAscii(_env, "status"))
    , m_prop_isFatal(jsi::PropNameID::forAscii(_env, "isFatal"))
    , m_prop_simpleMessage(jsi::PropNameID::forAscii(_env, "simpleMessage"))
    , m_prop_logUrl(jsi::PropNameID::forAscii(_env, "logUrl"))
    , m_prop_userInfo(jsi::PropNameID::forAscii(_env, "userInfo"))
    , m_prop_isClientResetRequested(jsi::PropNameID::forAscii(_env, "isClientResetRequested"))
    , m_prop_compensatingWritesInfo(jsi::PropNameID::forAscii(_env, "compensatingWritesInfo"))
    , m_prop_objectName(jsi::PropNameID::forAscii(_env, "objectName"))
    , m_prop_reason(jsi::PropNameID::forAscii(_env, "reason"))
    , m_prop_customHttpHeaders(jsi::PropNameID::forAscii(_env, "customHttpHeaders"))
    , m_prop_clientValidateSsl(jsi::PropNameID::forAscii(_env, "clientValidateSsl"))
    , m_prop_sslTrustCertificatePath(jsi::PropNameID::forAscii(_env, "sslTrustCertificatePath"))
    , m_prop_sslVerifyCallback(jsi::PropNameID::forAscii(_env, "sslVerifyCallback"))
    , m_prop_clientResyncMode(jsi::PropNameID::forAscii(_env, "clientResyncMode"))
    , m_prop_notifyBeforeClientReset(jsi::PropNameID::forAscii(_env, "notifyBeforeClientReset"))
    , m_prop_notifyAfterClientReset(jsi::PropNameID::forAscii(_env, "notifyAfterClientReset"))
    , m_prop_cancelWaitsOnNonfatalError(jsi::PropNameID::forAscii(_env, "cancelWaitsOnNonfatalError"))
    , m_prop_proxyConfig(jsi::PropNameID::forAscii(_env, "proxyConfig"))
    , m_prop_address(jsi::PropNameID::forAscii(_env, "address"))
    , m_prop_port(jsi::PropNameID::forAscii(_env, "port"))
    , m_prop_forceSyncHistory(jsi::PropNameID::forAscii(_env, "forceSyncHistory"))
    , m_prop_migrationFunction(jsi::PropNameID::forAscii(_env, "migrationFunction"))
    , m_prop_initializationFunction(jsi::PropNameID::forAscii(_env, "initializationFunction"))
    , m_prop_shouldCompactOnLaunchFunction(jsi::PropNameID::forAscii(_env, "shouldCompactOnLaunchFunction"))
    , m_prop_automaticallyHandleBacklinksInMigrations(
          jsi::PropNameID::forAscii(_env, "automaticallyHandleBacklinksInMigrations"))
    , m_prop_next(jsi::PropNameID::forAscii(_env, "next"))
    , m_prop_done(jsi::PropNameID::forAscii(_env, "done"))
    , m_prop_value(jsi::PropNameID::forAscii(_env, "value"))
    , m_prop_radiusRadians(jsi::PropNameID::forAscii(_env, "radiusRadians"))
    , m_prop_center(jsi::PropNameID::forAscii(_env, "center"))
    , m_prop_longitude(jsi::PropNameID::forAscii(_env, "longitude"))
    , m_prop_latitude(jsi::PropNameID::forAscii(_env, "latitude"))
    , m_prop_altitude(jsi::PropNameID::forAscii(_env, "altitude"))
    , m_prop_lo(jsi::PropNameID::forAscii(_env, "lo"))
    , m_prop_hi(jsi::PropNameID::forAscii(_env, "hi"))
    , m_prop_points(jsi::PropNameID::forAscii(_env, "points"))
    , m_prop_deletions(jsi::PropNameID::forAscii(_env, "deletions"))
    , m_prop_insertions(jsi::PropNameID::forAscii(_env, "insertions"))
    , m_prop_modifications(jsi::PropNameID::forAscii(_env, "modifications"))
    , m_prop_modificationsNew(jsi::PropNameID::forAscii(_env, "modificationsNew"))
    , m_prop_isDeleted(jsi::PropNameID::forAscii(_env, "isDeleted"))
    , m_prop_changedColumns(jsi::PropNameID::forAscii(_env, "changedColumns"))
    , m_prop_code(jsi::PropNameID::forAscii(_env, "code"))
    , m_prop_providerType(jsi::PropNameID::forAscii(_env, "providerType"))
    , m_prop_appId(jsi::PropNameID::forAscii(_env, "appId"))
    , m_prop_transport(jsi::PropNameID::forAscii(_env, "transport"))
    , m_prop_baseUrl(jsi::PropNameID::forAscii(_env, "baseUrl"))
    , m_prop_defaultRequestTimeoutMs(jsi::PropNameID::forAscii(_env, "defaultRequestTimeoutMs"))
    , m_prop_deviceInfo(jsi::PropNameID::forAscii(_env, "deviceInfo"))
    , m_prop_platformVersion(jsi::PropNameID::forAscii(_env, "platformVersion"))
    , m_prop_sdkVersion(jsi::PropNameID::forAscii(_env, "sdkVersion"))
    , m_prop_sdk(jsi::PropNameID::forAscii(_env, "sdk"))
    , m_prop_deviceName(jsi::PropNameID::forAscii(_env, "deviceName"))
    , m_prop_deviceVersion(jsi::PropNameID::forAscii(_env, "deviceVersion"))
    , m_prop_frameworkName(jsi::PropNameID::forAscii(_env, "frameworkName"))
    , m_prop_frameworkVersion(jsi::PropNameID::forAscii(_env, "frameworkVersion"))
    , m_prop_bundleId(jsi::PropNameID::forAscii(_env, "bundleId"))
    , m_prop_baseFilePath(jsi::PropNameID::forAscii(_env, "baseFilePath"))
    , m_prop_syncClientConfig(jsi::PropNameID::forAscii(_env, "syncClientConfig"))
    , m_prop_multiplexSessions(jsi::PropNameID::forAscii(_env, "multiplexSessions"))
    , m_prop_userAgentBindingInfo(jsi::PropNameID::forAscii(_env, "userAgentBindingInfo"))
    , m_prop_timeouts(jsi::PropNameID::forAscii(_env, "timeouts"))
    , m_prop_connectTimeout(jsi::PropNameID::forAscii(_env, "connectTimeout"))
    , m_prop_connectionLingerTime(jsi::PropNameID::forAscii(_env, "connectionLingerTime"))
    , m_prop_pingKeepalivePeriod(jsi::PropNameID::forAscii(_env, "pingKeepalivePeriod"))
    , m_prop_pongKeepaliveTimeout(jsi::PropNameID::forAscii(_env, "pongKeepaliveTimeout"))
    , m_prop_fastReconnectLimit(jsi::PropNameID::forAscii(_env, "fastReconnectLimit"))
    , m_prop_reconnectBackoffInfo(jsi::PropNameID::forAscii(_env, "reconnectBackoffInfo"))
    , m_prop_maxResumptionDelayInterval(jsi::PropNameID::forAscii(_env, "maxResumptionDelayInterval"))
    , m_prop_resumptionDelayInterval(jsi::PropNameID::forAscii(_env, "resumptionDelayInterval"))
    , m_prop_resumptionDelayBackoffMultiplier(jsi::PropNameID::forAscii(_env, "resumptionDelayBackoffMultiplier"))
    , m_prop_delayJitterDivisor(jsi::PropNameID::forAscii(_env, "delayJitterDivisor"))
    , m_prop_metadataMode(jsi::PropNameID::forAscii(_env, "metadataMode"))
    , m_prop_customEncryptionKey(jsi::PropNameID::forAscii(_env, "customEncryptionKey"))
    , m_prop_key(jsi::PropNameID::forAscii(_env, "key"))
    , m_prop_disabled(jsi::PropNameID::forAscii(_env, "disabled"))
    , m_prop_ident(jsi::PropNameID::forAscii(_env, "ident"))
    , m_prop_salt(jsi::PropNameID::forAscii(_env, "salt"))
    , m_prop_high(jsi::PropNameID::forAscii(_env, "high"))
    , m_prop_low(jsi::PropNameID::forAscii(_env, "low"))
{


    exports.setProperty(_env, "Helpers_get_table",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_get_table"), 1, Helpers_get_table));
    exports.setProperty(
        _env, "Helpers_get_keypath_mapping",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_get_keypath_mapping"), 1,
                                              Helpers_get_keypath_mapping));
    exports.setProperty(
        _env, "Helpers_results_append_query",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_results_append_query"),
                                              1, Helpers_results_append_query));
    exports.setProperty(
        _env, "Helpers_make_object_notifier",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_make_object_notifier"),
                                              1, Helpers_make_object_notifier));
    exports.setProperty(
        _env, "Helpers_set_binding_context",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_set_binding_context"), 1,
                                              Helpers_set_binding_context));
    exports.setProperty(_env, "Helpers_get_or_create_object_with_primary_key",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_get_or_create_object_with_primary_key"), 1,
                            Helpers_get_or_create_object_with_primary_key));
    exports.setProperty(
        _env, "Helpers_make_network_transport",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_make_network_transport"),
                                              1, Helpers_make_network_transport));
    exports.setProperty(
        _env, "Helpers_delete_data_for_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_delete_data_for_object"),
                                              1, Helpers_delete_data_for_object));
    exports.setProperty(
        _env, "Helpers_base64_decode",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_base64_decode"), 1,
                                              Helpers_base64_decode));
    exports.setProperty(
        _env, "Helpers_make_logger_factory",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_make_logger_factory"), 1,
                                              Helpers_make_logger_factory));
    exports.setProperty(_env, "Helpers_make_logger",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_make_logger"), 1, Helpers_make_logger));
    exports.setProperty(
        _env, "Helpers_simulate_sync_error",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_simulate_sync_error"), 1,
                                              Helpers_simulate_sync_error));
    exports.setProperty(_env, "Helpers_consume_thread_safe_reference_to_shared_realm",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "Helpers_consume_thread_safe_reference_to_shared_realm"),
                            1, Helpers_consume_thread_safe_reference_to_shared_realm));
    exports.setProperty(_env, "Helpers_file_exists",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_file_exists"), 1, Helpers_file_exists));
    exports.setProperty(
        _env, "Helpers_erase_subscription",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_erase_subscription"), 1,
                                              Helpers_erase_subscription));
    exports.setProperty(_env, "Helpers_get_results_description",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_get_results_description"), 1,
                            Helpers_get_results_description));
    exports.setProperty(_env, "Helpers_feed_buffer",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_feed_buffer"), 1, Helpers_feed_buffer));
    exports.setProperty(_env, "Helpers_make_ssl_verify_callback",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_make_ssl_verify_callback"), 1,
                            Helpers_make_ssl_verify_callback));
    exports.setProperty(_env, "Helpers_needs_file_format_upgrade",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Helpers_needs_file_format_upgrade"), 1,
                            Helpers_needs_file_format_upgrade));
    exports.setProperty(
        _env, "Helpers_sync_user_as_app_user",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_sync_user_as_app_user"),
                                              1, Helpers_sync_user_as_app_user));
    exports.setProperty(
        _env, "Helpers_app_user_as_sync_user",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Helpers_app_user_as_sync_user"),
                                              1, Helpers_app_user_as_sync_user));
    exports.setProperty(_env, "LogCategoryRef_set_default_level_threshold",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "LogCategoryRef_set_default_level_threshold"), 1,
                            LogCategoryRef_set_default_level_threshold));
    exports.setProperty(
        _env, "LogCategoryRef_get_category",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "LogCategoryRef_get_category"), 1,
                                              LogCategoryRef_get_category));
    exports.setProperty(
        _env, "Logger_set_default_logger",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Logger_set_default_logger"), 1,
                                              Logger_set_default_logger));
    exports.setProperty(
        _env, "ConstTableRef_get_column_type",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_get_column_type"),
                                              1, ConstTableRef_get_column_type));
    exports.setProperty(
        _env, "ConstTableRef_get_link_target",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_get_link_target"),
                                              1, ConstTableRef_get_link_target));
    exports.setProperty(
        _env, "ConstTableRef_get_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_get_object"), 1,
                                              ConstTableRef_get_object));
    exports.setProperty(
        _env, "ConstTableRef_try_get_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_try_get_object"),
                                              1, ConstTableRef_try_get_object));
    exports.setProperty(_env, "ConstTableRef_query",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "ConstTableRef_query"), 1, ConstTableRef_query));
    exports.setProperty(
        _env, "ConstTableRef_find_primary_key",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_find_primary_key"),
                                              1, ConstTableRef_find_primary_key));
    exports.setProperty(
        _env, "ConstTableRef_get_key",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_get_key"), 1,
                                              ConstTableRef_get_key));
    exports.setProperty(
        _env, "ConstTableRef_Symbol_iterator",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ConstTableRef_Symbol_iterator"),
                                              1, ConstTableRef_Symbol_iterator));
    exports.setProperty(
        _env, "TableRef_create_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "TableRef_create_object"), 1,
                                              TableRef_create_object));
    exports.setProperty(
        _env, "TableRef_remove_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "TableRef_remove_object"), 1,
                                              TableRef_remove_object));
    exports.setProperty(
        _env, "TableRef_get_link_target",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "TableRef_get_link_target"), 1,
                                              TableRef_get_link_target));
    exports.setProperty(_env, "TableRef_clear",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "TableRef_clear"),
                                                              1, TableRef_clear));
    exports.setProperty(_env, "TableRef_get_primary_key_column",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "TableRef_get_primary_key_column"), 1,
                            TableRef_get_primary_key_column));
    exports.setProperty(
        _env, "Obj_get_any",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_any"), 1, Obj_get_any));
    exports.setProperty(
        _env, "Obj_set_any",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_set_any"), 1, Obj_set_any));
    exports.setProperty(_env, "Obj_set_collection",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Obj_set_collection"), 1, Obj_set_collection));
    exports.setProperty(
        _env, "Obj_add_int",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_add_int"), 1, Obj_add_int));
    exports.setProperty(
        _env, "Obj_get_linked_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_linked_object"), 1,
                                              Obj_get_linked_object));
    exports.setProperty(
        _env, "Obj_get_backlink_count",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_backlink_count"), 1,
                                              Obj_get_backlink_count));
    exports.setProperty(
        _env, "Obj_get_backlink_view",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_backlink_view"), 1,
                                              Obj_get_backlink_view));
    exports.setProperty(_env, "Obj_create_and_set_linked_object",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Obj_create_and_set_linked_object"), 1,
                            Obj_create_and_set_linked_object));
    exports.setProperty(_env, "Obj_is_valid",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_is_valid"),
                                                              1, Obj_is_valid));
    exports.setProperty(_env, "Obj_get_table",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_table"),
                                                              1, Obj_get_table));
    exports.setProperty(
        _env, "Obj_get_key",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Obj_get_key"), 1, Obj_get_key));
    exports.setProperty(_env, "Timestamp_make",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Timestamp_make"),
                                                              1, Timestamp_make));
    exports.setProperty(
        _env, "Timestamp_get_seconds",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Timestamp_get_seconds"), 1,
                                              Timestamp_get_seconds));
    exports.setProperty(
        _env, "Timestamp_get_nanoseconds",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Timestamp_get_nanoseconds"), 1,
                                              Timestamp_get_nanoseconds));
    exports.setProperty(
        _env, "Geospatial_make_from_circle",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Geospatial_make_from_circle"), 1,
                                              Geospatial_make_from_circle));
    exports.setProperty(
        _env, "Geospatial_make_from_box",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Geospatial_make_from_box"), 1,
                                              Geospatial_make_from_box));
    exports.setProperty(
        _env, "Geospatial_make_from_polygon",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Geospatial_make_from_polygon"),
                                              1, Geospatial_make_from_polygon));
    exports.setProperty(
        _env, "ObjLink_get_table_key",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ObjLink_get_table_key"), 1,
                                              ObjLink_get_table_key));
    exports.setProperty(_env, "ObjLink_get_obj_key",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "ObjLink_get_obj_key"), 1, ObjLink_get_obj_key));
    exports.setProperty(_env, "Query_get_table",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Query_get_table"), 1, Query_get_table));
    exports.setProperty(
        _env, "Query_get_description",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Query_get_description"), 1,
                                              Query_get_description));
    exports.setProperty(_env, "Results_size",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_size"),
                                                              1, Results_size));
    exports.setProperty(_env, "Results_index_of",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_index_of"), 1, Results_index_of));
    exports.setProperty(_env, "Results_index_of_obj",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_index_of_obj"), 1, Results_index_of_obj));
    exports.setProperty(_env, "Results_get_obj",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_get_obj"), 1, Results_get_obj));
    exports.setProperty(_env, "Results_get_any",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_get_any"), 1, Results_get_any));
    exports.setProperty(_env, "Results_get_list",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_get_list"), 1, Results_get_list));
    exports.setProperty(
        _env, "Results_get_dictionary",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_get_dictionary"), 1,
                                              Results_get_dictionary));
    exports.setProperty(
        _env, "Results_sort_by_names",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_sort_by_names"), 1,
                                              Results_sort_by_names));
    exports.setProperty(_env, "Results_snapshot",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_snapshot"), 1, Results_snapshot));
    exports.setProperty(
        _env, "Results_max",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_max"), 1, Results_max));
    exports.setProperty(
        _env, "Results_min",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_min"), 1, Results_min));
    exports.setProperty(_env, "Results_average",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_average"), 1, Results_average));
    exports.setProperty(
        _env, "Results_sum",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_sum"), 1, Results_sum));
    exports.setProperty(_env, "Results_clear",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_clear"),
                                                              1, Results_clear));
    exports.setProperty(_env, "Results_add_notification_callback",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_add_notification_callback"), 1,
                            Results_add_notification_callback));
    exports.setProperty(_env, "Results_from_table",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_from_table"), 1, Results_from_table));
    exports.setProperty(
        _env, "Results_from_table_view",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_from_table_view"), 1,
                                              Results_from_table_view));
    exports.setProperty(_env, "Results_is_valid",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_is_valid"), 1, Results_is_valid));
    exports.setProperty(_env, "Results_get_query",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_get_query"), 1, Results_get_query));
    exports.setProperty(
        _env, "Results_get_object_type",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Results_get_object_type"), 1,
                                              Results_get_object_type));
    exports.setProperty(_env, "Results_get_type",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Results_get_type"), 1, Results_get_type));
    exports.setProperty(
        _env, "Realm_begin_transaction",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_begin_transaction"), 1,
                                              Realm_begin_transaction));
    exports.setProperty(
        _env, "Realm_commit_transaction",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_commit_transaction"), 1,
                                              Realm_commit_transaction));
    exports.setProperty(
        _env, "Realm_cancel_transaction",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_cancel_transaction"), 1,
                                              Realm_cancel_transaction));
    exports.setProperty(_env, "Realm_update_schema",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_update_schema"), 1, Realm_update_schema));
    exports.setProperty(_env, "Realm_compact",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_compact"),
                                                              1, Realm_compact));
    exports.setProperty(_env, "Realm_convert",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_convert"),
                                                              1, Realm_convert));
    exports.setProperty(_env, "Realm_verify_open",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_verify_open"), 1, Realm_verify_open));
    exports.setProperty(
        _env, "Realm_create_key_path_array",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_create_key_path_array"), 1,
                                              Realm_create_key_path_array));
    exports.setProperty(
        _env, "Realm_close",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_close"), 1, Realm_close));
    exports.setProperty(
        _env, "Realm_get_shared_realm",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_get_shared_realm"), 1,
                                              Realm_get_shared_realm));
    exports.setProperty(
        _env, "Realm_get_synchronized_realm",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_get_synchronized_realm"),
                                              1, Realm_get_synchronized_realm));
    exports.setProperty(
        _env, "Realm_get_schema_version",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_get_schema_version"), 1,
                                              Realm_get_schema_version));
    exports.setProperty(_env, "Realm_config",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_config"),
                                                              1, Realm_config));
    exports.setProperty(_env, "Realm_schema",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_schema"),
                                                              1, Realm_schema));
    exports.setProperty(_env, "Realm_schema_version",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_schema_version"), 1, Realm_schema_version));
    exports.setProperty(
        _env, "Realm_is_in_transaction",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_is_in_transaction"), 1,
                                              Realm_is_in_transaction));
    exports.setProperty(
        _env, "Realm_is_in_migration",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_is_in_migration"), 1,
                                              Realm_is_in_migration));
    exports.setProperty(_env, "Realm_is_empty",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_is_empty"),
                                                              1, Realm_is_empty));
    exports.setProperty(_env, "Realm_is_closed",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_is_closed"), 1, Realm_is_closed));
    exports.setProperty(_env, "Realm_sync_session",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_sync_session"), 1, Realm_sync_session));
    exports.setProperty(_env, "Realm_get_latest_subscription_set",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_get_latest_subscription_set"), 1,
                            Realm_get_latest_subscription_set));
    exports.setProperty(_env, "Realm_DOLLAR_addr",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Realm_DOLLAR_addr"), 1, Realm_DOLLAR_addr));
    exports.setProperty(
        _env, "Realm_DOLLAR_resetSharedPtr",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Realm_DOLLAR_resetSharedPtr"), 1,
                                              Realm_DOLLAR_resetSharedPtr));
    exports.setProperty(_env, "RealmCoordinator_clear_all_caches",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "RealmCoordinator_clear_all_caches"), 1,
                            RealmCoordinator_clear_all_caches));
    exports.setProperty(
        _env, "ObjectNotifier_add_callback",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "ObjectNotifier_add_callback"), 1,
                                              ObjectNotifier_add_callback));
    exports.setProperty(
        _env, "NotificationToken_unregister",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "NotificationToken_unregister"),
                                              1, NotificationToken_unregister));
    exports.setProperty(
        _env, "NotificationToken_for_object",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "NotificationToken_for_object"),
                                              1, NotificationToken_for_object));
    exports.setProperty(
        _env, "IndexSet_Symbol_iterator",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "IndexSet_Symbol_iterator"), 1,
                                              IndexSet_Symbol_iterator));
    exports.setProperty(_env, "Collection_get_any",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Collection_get_any"), 1, Collection_get_any));
    exports.setProperty(
        _env, "Collection_as_results",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Collection_as_results"), 1,
                                              Collection_as_results));
    exports.setProperty(_env, "Collection_snapshot",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Collection_snapshot"), 1, Collection_snapshot));
    exports.setProperty(_env, "Collection_get_type",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Collection_get_type"), 1, Collection_get_type));
    exports.setProperty(
        _env, "Collection_get_object_schema",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Collection_get_object_schema"),
                                              1, Collection_get_object_schema));
    exports.setProperty(_env, "Collection_size",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Collection_size"), 1, Collection_size));
    exports.setProperty(_env, "Collection_is_valid",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Collection_is_valid"), 1, Collection_is_valid));
    exports.setProperty(_env, "List_get_obj",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_get_obj"),
                                                              1, List_get_obj));
    exports.setProperty(_env, "List_get_list",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_get_list"),
                                                              1, List_get_list));
    exports.setProperty(_env, "List_get_dictionary",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_get_dictionary"), 1, List_get_dictionary));
    exports.setProperty(
        _env, "List_move",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_move"), 1, List_move));
    exports.setProperty(
        _env, "List_remove",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_remove"), 1, List_remove));
    exports.setProperty(_env, "List_remove_all",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_remove_all"), 1, List_remove_all));
    exports.setProperty(
        _env, "List_swap",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_swap"), 1, List_swap));
    exports.setProperty(_env, "List_delete_all",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_delete_all"), 1, List_delete_all));
    exports.setProperty(_env, "List_insert_any",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_insert_any"), 1, List_insert_any));
    exports.setProperty(_env, "List_insert_embedded",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_insert_embedded"), 1, List_insert_embedded));
    exports.setProperty(
        _env, "List_insert_collection",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_insert_collection"), 1,
                                              List_insert_collection));
    exports.setProperty(_env, "List_set_any",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_set_any"),
                                                              1, List_set_any));
    exports.setProperty(_env, "List_set_embedded",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_set_embedded"), 1, List_set_embedded));
    exports.setProperty(_env, "List_set_collection",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "List_set_collection"), 1, List_set_collection));
    exports.setProperty(
        _env, "List_make",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "List_make"), 1, List_make));
    exports.setProperty(
        _env, "Set_get_obj",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_get_obj"), 1, Set_get_obj));
    exports.setProperty(_env, "Set_insert_any",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_insert_any"),
                                                              1, Set_insert_any));
    exports.setProperty(_env, "Set_remove_any",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_remove_any"),
                                                              1, Set_remove_any));
    exports.setProperty(_env, "Set_remove_all",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_remove_all"),
                                                              1, Set_remove_all));
    exports.setProperty(_env, "Set_delete_all",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_delete_all"),
                                                              1, Set_delete_all));
    exports.setProperty(
        _env, "Set_make",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Set_make"), 1, Set_make));
    exports.setProperty(_env, "Dictionary_get_list",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_get_list"), 1, Dictionary_get_list));
    exports.setProperty(
        _env, "Dictionary_get_dictionary",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_get_dictionary"), 1,
                                              Dictionary_get_dictionary));
    exports.setProperty(_env, "Dictionary_contains",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_contains"), 1, Dictionary_contains));
    exports.setProperty(_env, "Dictionary_add_key_based_notification_callback",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_add_key_based_notification_callback"),
                            1, Dictionary_add_key_based_notification_callback));
    exports.setProperty(
        _env, "Dictionary_insert_any",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_insert_any"), 1,
                                              Dictionary_insert_any));
    exports.setProperty(
        _env, "Dictionary_insert_embedded",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_insert_embedded"), 1,
                                              Dictionary_insert_embedded));
    exports.setProperty(
        _env, "Dictionary_insert_collection",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_insert_collection"),
                                              1, Dictionary_insert_collection));
    exports.setProperty(
        _env, "Dictionary_try_get_any",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_try_get_any"), 1,
                                              Dictionary_try_get_any));
    exports.setProperty(
        _env, "Dictionary_remove_all",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_remove_all"), 1,
                                              Dictionary_remove_all));
    exports.setProperty(_env, "Dictionary_try_erase",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_try_erase"), 1, Dictionary_try_erase));
    exports.setProperty(_env, "Dictionary_make",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_make"), 1, Dictionary_make));
    exports.setProperty(_env, "Dictionary_get_keys",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "Dictionary_get_keys"), 1, Dictionary_get_keys));
    exports.setProperty(
        _env, "Dictionary_get_values",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_get_values"), 1,
                                              Dictionary_get_values));
    exports.setProperty(
        _env, "Dictionary_Symbol_iterator",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "Dictionary_Symbol_iterator"), 1,
                                              Dictionary_Symbol_iterator));
    exports.setProperty(_env, "GoogleAuthCode_make",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "GoogleAuthCode_make"), 1, GoogleAuthCode_make));
    exports.setProperty(_env, "GoogleIdToken_make",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "GoogleIdToken_make"), 1, GoogleIdToken_make));
    exports.setProperty(
        _env, "AppCredentials_facebook",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "AppCredentials_facebook"), 1,
                                              AppCredentials_facebook));
    exports.setProperty(
        _env, "AppCredentials_anonymous",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "AppCredentials_anonymous"), 1,
                                              AppCredentials_anonymous));
    exports.setProperty(_env, "AppCredentials_apple",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "AppCredentials_apple"), 1, AppCredentials_apple));
    exports.setProperty(
        _env, "AppCredentials_google_auth",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "AppCredentials_google_auth"), 1,
                                              AppCredentials_google_auth));
    exports.setProperty(
        _env, "AppCredentials_google_id",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "AppCredentials_google_id"), 1,
                                              AppCredentials_google_id));
    exports.setProperty(
        _env, "AppCredentials_custom",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "AppCredentials_custom"), 1,
                                              AppCredentials_custom));
    exports.setProperty(_env, "AppCredentials_username_password",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "AppCredentials_username_password"), 1,
                            AppCredentials_username_password));
    exports.setProperty(
        _env, "AppCredentials_function",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "AppCredentials_function"), 1,
                                              AppCredentials_function));
    exports.setProperty(
        _env, "AppCredentials_api_key",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "AppCredentials_api_key"), 1,
                                              AppCredentials_api_key));
    exports.setProperty(
        _env, "SyncUser_is_logged_in",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncUser_is_logged_in"), 1,
                                              SyncUser_is_logged_in));
    exports.setProperty(_env, "User_subscribe",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "User_subscribe"),
                                                              1, User_subscribe));
    exports.setProperty(_env, "User_unsubscribe",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "User_unsubscribe"), 1, User_unsubscribe));
    exports.setProperty(_env, "User_path_for_realm",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "User_path_for_realm"), 1, User_path_for_realm));
    exports.setProperty(_env, "User_access_token_refresh_required",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "User_access_token_refresh_required"), 1,
                            User_access_token_refresh_required));
    exports.setProperty(
        _env, "User_request_refresh_location",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "User_request_refresh_location"),
                                              1, User_request_refresh_location));
    exports.setProperty(
        _env, "User_request_access_token",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "User_request_access_token"), 1,
                                              User_request_access_token));
    exports.setProperty(_env, "User_track_realm",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "User_track_realm"), 1, User_track_realm));
    exports.setProperty(_env, "User_user_id",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "User_user_id"),
                                                              1, User_user_id));
    exports.setProperty(
        _env, "User_app_id",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "User_app_id"), 1, User_app_id));
    exports.setProperty(
        _env, "User_legacy_identities",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "User_legacy_identities"), 1,
                                              User_legacy_identities));
    exports.setProperty(_env, "User_access_token",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "User_access_token"), 1, User_access_token));
    exports.setProperty(_env, "User_refresh_token",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "User_refresh_token"), 1, User_refresh_token));
    exports.setProperty(
        _env, "User_state",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "User_state"), 1, User_state));
    exports.setProperty(_env, "User_device_id",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "User_device_id"),
                                                              1, User_device_id));
    exports.setProperty(_env, "User_has_device_id",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "User_has_device_id"), 1, User_has_device_id));
    exports.setProperty(_env, "User_user_profile",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "User_user_profile"), 1, User_user_profile));
    exports.setProperty(_env, "User_identities",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "User_identities"), 1, User_identities));
    exports.setProperty(_env, "User_custom_data",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "User_custom_data"), 1, User_custom_data));
    exports.setProperty(
        _env, "User_app",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "User_app"), 1, User_app));
    exports.setProperty(_env, "UserProfile_data",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "UserProfile_data"), 1, UserProfile_data));
    exports.setProperty(
        _env, "App_log_in_with_credentials",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_log_in_with_credentials"), 1,
                                              App_log_in_with_credentials));
    exports.setProperty(_env, "App_log_out_user",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_log_out_user"), 1, App_log_out_user));
    exports.setProperty(
        _env, "App_refresh_custom_data",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_refresh_custom_data"), 1,
                                              App_refresh_custom_data));
    exports.setProperty(_env, "App_link_user",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_link_user"),
                                                              1, App_link_user));
    exports.setProperty(_env, "App_switch_user",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_switch_user"), 1, App_switch_user));
    exports.setProperty(_env, "App_remove_user",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_remove_user"), 1, App_remove_user));
    exports.setProperty(_env, "App_delete_user",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_delete_user"), 1, App_delete_user));
    exports.setProperty(_env, "App_usernamePasswordProviderClient",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_usernamePasswordProviderClient"), 1,
                            App_usernamePasswordProviderClient));
    exports.setProperty(
        _env, "App_userAPIKeyProviderClient",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_userAPIKeyProviderClient"),
                                              1, App_userAPIKeyProviderClient));
    exports.setProperty(
        _env, "App_push_notification_client",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_push_notification_client"),
                                              1, App_push_notification_client));
    exports.setProperty(_env, "App_subscribe",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_subscribe"),
                                                              1, App_subscribe));
    exports.setProperty(_env, "App_unsubscribe",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_unsubscribe"), 1, App_unsubscribe));
    exports.setProperty(_env, "App_call_function",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_call_function"), 1, App_call_function));
    exports.setProperty(
        _env, "App_make_streaming_request",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_make_streaming_request"), 1,
                                              App_make_streaming_request));
    exports.setProperty(_env, "App_update_base_url",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_update_base_url"), 1, App_update_base_url));
    exports.setProperty(_env, "App_get_base_url",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_get_base_url"), 1, App_get_base_url));
    exports.setProperty(_env, "App_immediately_run_file_actions",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_immediately_run_file_actions"), 1,
                            App_immediately_run_file_actions));
    exports.setProperty(
        _env, "App_get_app",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_get_app"), 1, App_get_app));
    exports.setProperty(
        _env, "App_clear_cached_apps",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_clear_cached_apps"), 1,
                                              App_clear_cached_apps));
    exports.setProperty(
        _env, "App_config",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_config"), 1, App_config));
    exports.setProperty(_env, "App_current_user",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_current_user"), 1, App_current_user));
    exports.setProperty(_env, "App_all_users",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "App_all_users"),
                                                              1, App_all_users));
    exports.setProperty(_env, "App_sync_manager",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "App_sync_manager"), 1, App_sync_manager));
    exports.setProperty(
        _env, "WatchStream_next_event",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "WatchStream_next_event"), 1,
                                              WatchStream_next_event));
    exports.setProperty(_env, "WatchStream_make",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "WatchStream_make"), 1, WatchStream_make));
    exports.setProperty(_env, "WatchStream_state",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "WatchStream_state"), 1, WatchStream_state));
    exports.setProperty(_env, "WatchStream_error",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "WatchStream_error"), 1, WatchStream_error));
    exports.setProperty(
        _env, "PushClient_register_device",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "PushClient_register_device"), 1,
                                              PushClient_register_device));
    exports.setProperty(
        _env, "PushClient_deregister_device",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "PushClient_deregister_device"),
                                              1, PushClient_deregister_device));
    exports.setProperty(_env, "UsernamePasswordProviderClient_register_email",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "UsernamePasswordProviderClient_register_email"), 1,
                            UsernamePasswordProviderClient_register_email));
    exports.setProperty(
        _env, "UsernamePasswordProviderClient_retry_custom_confirmation",
        jsi::Function::createFromHostFunction(
            _env, jsi::PropNameID::forAscii(_env, "UsernamePasswordProviderClient_retry_custom_confirmation"), 1,
            UsernamePasswordProviderClient_retry_custom_confirmation));
    exports.setProperty(_env, "UsernamePasswordProviderClient_confirm_user",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "UsernamePasswordProviderClient_confirm_user"), 1,
                            UsernamePasswordProviderClient_confirm_user));
    exports.setProperty(
        _env, "UsernamePasswordProviderClient_resend_confirmation_email",
        jsi::Function::createFromHostFunction(
            _env, jsi::PropNameID::forAscii(_env, "UsernamePasswordProviderClient_resend_confirmation_email"), 1,
            UsernamePasswordProviderClient_resend_confirmation_email));
    exports.setProperty(_env, "UsernamePasswordProviderClient_reset_password",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "UsernamePasswordProviderClient_reset_password"), 1,
                            UsernamePasswordProviderClient_reset_password));
    exports.setProperty(
        _env, "UsernamePasswordProviderClient_send_reset_password_email",
        jsi::Function::createFromHostFunction(
            _env, jsi::PropNameID::forAscii(_env, "UsernamePasswordProviderClient_send_reset_password_email"), 1,
            UsernamePasswordProviderClient_send_reset_password_email));
    exports.setProperty(
        _env, "UsernamePasswordProviderClient_call_reset_password_function",
        jsi::Function::createFromHostFunction(
            _env, jsi::PropNameID::forAscii(_env, "UsernamePasswordProviderClient_call_reset_password_function"), 1,
            UsernamePasswordProviderClient_call_reset_password_function));
    exports.setProperty(_env, "UserAPIKeyProviderClient_create_api_key",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "UserAPIKeyProviderClient_create_api_key"), 1,
                            UserAPIKeyProviderClient_create_api_key));
    exports.setProperty(_env, "UserAPIKeyProviderClient_fetch_api_key",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "UserAPIKeyProviderClient_fetch_api_key"), 1,
                            UserAPIKeyProviderClient_fetch_api_key));
    exports.setProperty(_env, "UserAPIKeyProviderClient_fetch_api_keys",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "UserAPIKeyProviderClient_fetch_api_keys"), 1,
                            UserAPIKeyProviderClient_fetch_api_keys));
    exports.setProperty(_env, "UserAPIKeyProviderClient_delete_api_key",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "UserAPIKeyProviderClient_delete_api_key"), 1,
                            UserAPIKeyProviderClient_delete_api_key));
    exports.setProperty(_env, "UserAPIKeyProviderClient_enable_api_key",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "UserAPIKeyProviderClient_enable_api_key"), 1,
                            UserAPIKeyProviderClient_enable_api_key));
    exports.setProperty(_env, "UserAPIKeyProviderClient_disable_api_key",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "UserAPIKeyProviderClient_disable_api_key"), 1,
                            UserAPIKeyProviderClient_disable_api_key));
    exports.setProperty(_env, "SyncManager_set_session_multiplexing",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncManager_set_session_multiplexing"), 1,
                            SyncManager_set_session_multiplexing));
    exports.setProperty(
        _env, "SyncManager_set_log_level",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncManager_set_log_level"), 1,
                                              SyncManager_set_log_level));
    exports.setProperty(
        _env, "SyncManager_set_logger_factory",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncManager_set_logger_factory"),
                                              1, SyncManager_set_logger_factory));
    exports.setProperty(
        _env, "SyncManager_set_user_agent",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncManager_set_user_agent"), 1,
                                              SyncManager_set_user_agent));
    exports.setProperty(
        _env, "SyncManager_reconnect",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncManager_reconnect"), 1,
                                              SyncManager_reconnect));
    exports.setProperty(_env, "SyncManager_get_existing_active_session",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncManager_get_existing_active_session"), 1,
                            SyncManager_get_existing_active_session));
    exports.setProperty(_env, "SyncManager_get_all_sessions_for",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncManager_get_all_sessions_for"), 1,
                            SyncManager_get_all_sessions_for));
    exports.setProperty(_env, "SyncManager_has_existing_sessions",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncManager_has_existing_sessions"), 1,
                            SyncManager_has_existing_sessions));
    exports.setProperty(_env, "AsyncOpenTask_start",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "AsyncOpenTask_start"), 1, AsyncOpenTask_start));
    exports.setProperty(_env, "AsyncOpenTask_cancel",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "AsyncOpenTask_cancel"), 1, AsyncOpenTask_cancel));
    exports.setProperty(_env, "AsyncOpenTask_register_download_progress_notifier",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "AsyncOpenTask_register_download_progress_notifier"), 1,
                            AsyncOpenTask_register_download_progress_notifier));
    exports.setProperty(_env, "AsyncOpenTask_unregister_download_progress_notifier",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "AsyncOpenTask_unregister_download_progress_notifier"), 1,
                            AsyncOpenTask_unregister_download_progress_notifier));
    exports.setProperty(_env, "AsyncOpenTask_DOLLAR_resetSharedPtr",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "AsyncOpenTask_DOLLAR_resetSharedPtr"), 1,
                            AsyncOpenTask_DOLLAR_resetSharedPtr));
    exports.setProperty(_env, "SyncSession_wait_for_upload_completion",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSession_wait_for_upload_completion"), 1,
                            SyncSession_wait_for_upload_completion));
    exports.setProperty(_env, "SyncSession_wait_for_download_completion",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSession_wait_for_download_completion"), 1,
                            SyncSession_wait_for_download_completion));
    exports.setProperty(_env, "SyncSession_register_progress_notifier",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSession_register_progress_notifier"), 1,
                            SyncSession_register_progress_notifier));
    exports.setProperty(_env, "SyncSession_unregister_progress_notifier",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSession_unregister_progress_notifier"), 1,
                            SyncSession_unregister_progress_notifier));
    exports.setProperty(_env, "SyncSession_register_connection_change_callback",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSession_register_connection_change_callback"),
                            1, SyncSession_register_connection_change_callback));
    exports.setProperty(_env, "SyncSession_unregister_connection_change_callback",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "SyncSession_unregister_connection_change_callback"), 1,
                            SyncSession_unregister_connection_change_callback));
    exports.setProperty(
        _env, "SyncSession_revive_if_needed",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSession_revive_if_needed"),
                                              1, SyncSession_revive_if_needed));
    exports.setProperty(
        _env, "SyncSession_handle_reconnect",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSession_handle_reconnect"),
                                              1, SyncSession_handle_reconnect));
    exports.setProperty(
        _env, "SyncSession_force_close",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSession_force_close"), 1,
                                              SyncSession_force_close));
    exports.setProperty(
        _env, "SyncSession_get_file_ident",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSession_get_file_ident"), 1,
                                              SyncSession_get_file_ident));
    exports.setProperty(_env, "SyncSession_state",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSession_state"), 1, SyncSession_state));
    exports.setProperty(
        _env, "SyncSession_connection_state",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSession_connection_state"),
                                              1, SyncSession_connection_state));
    exports.setProperty(_env, "SyncSession_user",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSession_user"), 1, SyncSession_user));
    exports.setProperty(_env, "SyncSession_config",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSession_config"), 1, SyncSession_config));
    exports.setProperty(
        _env, "SyncSession_full_realm_url",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSession_full_realm_url"), 1,
                                              SyncSession_full_realm_url));
    exports.setProperty(_env, "SyncSession_DOLLAR_resetSharedPtr",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSession_DOLLAR_resetSharedPtr"), 1,
                            SyncSession_DOLLAR_resetSharedPtr));
    exports.setProperty(_env, "SyncSubscriptionSet_make_mutable_copy",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSubscriptionSet_make_mutable_copy"), 1,
                            SyncSubscriptionSet_make_mutable_copy));
    exports.setProperty(_env, "SyncSubscriptionSet_get_state_change_notification",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "SyncSubscriptionSet_get_state_change_notification"), 1,
                            SyncSubscriptionSet_get_state_change_notification));
    exports.setProperty(_env, "SyncSubscriptionSet_find_by_name",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSubscriptionSet_find_by_name"), 1,
                            SyncSubscriptionSet_find_by_name));
    exports.setProperty(_env, "SyncSubscriptionSet_find_by_query",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSubscriptionSet_find_by_query"), 1,
                            SyncSubscriptionSet_find_by_query));
    exports.setProperty(
        _env, "SyncSubscriptionSet_refresh",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSubscriptionSet_refresh"), 1,
                                              SyncSubscriptionSet_refresh));
    exports.setProperty(
        _env, "SyncSubscriptionSet_version",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSubscriptionSet_version"), 1,
                                              SyncSubscriptionSet_version));
    exports.setProperty(
        _env, "SyncSubscriptionSet_state",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSubscriptionSet_state"), 1,
                                              SyncSubscriptionSet_state));
    exports.setProperty(
        _env, "SyncSubscriptionSet_error_str",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSubscriptionSet_error_str"),
                                              1, SyncSubscriptionSet_error_str));
    exports.setProperty(
        _env, "SyncSubscriptionSet_size",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "SyncSubscriptionSet_size"), 1,
                                              SyncSubscriptionSet_size));
    exports.setProperty(_env, "SyncSubscriptionSet_Symbol_iterator",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "SyncSubscriptionSet_Symbol_iterator"), 1,
                            SyncSubscriptionSet_Symbol_iterator));
    exports.setProperty(_env, "MutableSyncSubscriptionSet_clear",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "MutableSyncSubscriptionSet_clear"), 1,
                            MutableSyncSubscriptionSet_clear));
    exports.setProperty(_env, "MutableSyncSubscriptionSet_insert_or_assign_by_name",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "MutableSyncSubscriptionSet_insert_or_assign_by_name"), 1,
                            MutableSyncSubscriptionSet_insert_or_assign_by_name));
    exports.setProperty(_env, "MutableSyncSubscriptionSet_insert_or_assign_by_query",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "MutableSyncSubscriptionSet_insert_or_assign_by_query"),
                            1, MutableSyncSubscriptionSet_insert_or_assign_by_query));
    exports.setProperty(_env, "MutableSyncSubscriptionSet_erase_by_name",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "MutableSyncSubscriptionSet_erase_by_name"), 1,
                            MutableSyncSubscriptionSet_erase_by_name));
    exports.setProperty(_env, "MutableSyncSubscriptionSet_erase_by_query",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "MutableSyncSubscriptionSet_erase_by_query"), 1,
                            MutableSyncSubscriptionSet_erase_by_query));
    exports.setProperty(_env, "MutableSyncSubscriptionSet_commit",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "MutableSyncSubscriptionSet_commit"), 1,
                            MutableSyncSubscriptionSet_commit));
    exports.setProperty(_env, "JsPlatformHelpers_set_default_realm_file_directory",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_set_default_realm_file_directory"), 1,
                            JsPlatformHelpers_set_default_realm_file_directory));
    exports.setProperty(_env, "JsPlatformHelpers_default_realm_file_directory",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_default_realm_file_directory"),
                            1, JsPlatformHelpers_default_realm_file_directory));
    exports.setProperty(_env, "JsPlatformHelpers_ensure_directory_exists_for_file",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_ensure_directory_exists_for_file"), 1,
                            JsPlatformHelpers_ensure_directory_exists_for_file));
    exports.setProperty(_env, "JsPlatformHelpers_copy_bundled_realm_files",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_copy_bundled_realm_files"), 1,
                            JsPlatformHelpers_copy_bundled_realm_files));
    exports.setProperty(_env, "JsPlatformHelpers_remove_realm_files_from_directory",
                        jsi::Function::createFromHostFunction(
                            _env,
                            jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_remove_realm_files_from_directory"), 1,
                            JsPlatformHelpers_remove_realm_files_from_directory));
    exports.setProperty(
        _env, "JsPlatformHelpers_remove_file",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_remove_file"),
                                              1, JsPlatformHelpers_remove_file));
    exports.setProperty(_env, "JsPlatformHelpers_remove_directory",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_remove_directory"), 1,
                            JsPlatformHelpers_remove_directory));
    exports.setProperty(_env, "JsPlatformHelpers_exclude_from_icloud_backup",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_exclude_from_icloud_backup"), 1,
                            JsPlatformHelpers_exclude_from_icloud_backup));
    exports.setProperty(
        _env, "JsPlatformHelpers_get_cpu_arch",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "JsPlatformHelpers_get_cpu_arch"),
                                              1, JsPlatformHelpers_get_cpu_arch));
    exports.setProperty(_env, "WeakSyncSession_raw_dereference",
                        jsi::Function::createFromHostFunction(
                            _env, jsi::PropNameID::forAscii(_env, "WeakSyncSession_raw_dereference"), 1,
                            WeakSyncSession_raw_dereference));
    exports.setProperty(
        _env, "WeakSyncSession_weak_copy_of",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "WeakSyncSession_weak_copy_of"),
                                              1, WeakSyncSession_weak_copy_of));
    exports.setProperty(_env, "createWeakRef",
                        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "createWeakRef"),
                                                              1, createWeakRef));
    exports.setProperty(
        _env, "lockWeakRef",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "lockWeakRef"), 1, lockWeakRef));
    ;

    using namespace std::placeholders; // for _1, _2, _3...
    exports.setProperty(
        _env, "injectInjectables",
        jsi::Function::createFromHostFunction(_env, jsi::PropNameID::forAscii(_env, "injectInjectables"), 1,
                                              std::bind(&RealmAddon::injectInjectables, this, _1, _2, _3, _4)));

    _env.global().setProperty(_env, "__RealmFuncs", exports);
}
jsi::Value Helpers_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_TableRef(
            _env, Helpers::get_table(JS_TO_SHARED_Realm(_env, args[0]), TableKey(int32_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_get_keypath_mapping([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_KeyPathMapping(_env, Helpers::get_keypath_mapping(JS_TO_SHARED_Realm(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_results_append_query([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Results(_env, Helpers::results_append_query(JS_TO_CLASS_Results(_env, args[0]),
                                                                         JS_TO_CLASS_Query(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_make_object_notifier([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_SHARED_ObjectNotifier(
            _env, Helpers::make_object_notifier(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_Obj(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Helpers::BindingContextMethods STRUCT_FROM_JS_BindingContext(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = Helpers::BindingContextMethods();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_didChange);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.did_change = [&](auto&& val) {
                return val.isNull()
                           ? util::UniqueFunction<void(std::shared_ptr<Realm>)>()
                           : util::UniqueFunction<void(std::shared_ptr<Realm>)>(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<Realm> r) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(r))})));
                                 });
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "BindingContext::didChange is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_beforeNotify);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.before_notify = [&](auto&& val) {
                return val.isNull()
                           ? util::UniqueFunction<void(std::shared_ptr<Realm>)>()
                           : util::UniqueFunction<void(std::shared_ptr<Realm>)>(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<Realm> r) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(r))})));
                                 });
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "BindingContext::beforeNotify is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_schemaDidChange);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.schema_did_change = [&](auto&& val) {
                return val.isNull()
                           ? util::UniqueFunction<void(std::shared_ptr<Realm>)>()
                           : util::UniqueFunction<void(std::shared_ptr<Realm>)>(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<Realm> r) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(r))})));
                                 });
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "BindingContext::schemaDidChange is required");
        }
    }
    return out;
}
jsi::Value Helpers_set_binding_context([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)(Helpers::set_binding_context(JS_TO_SHARED_Realm(_env, args[0]),
                                                    STRUCT_FROM_JS_BindingContext(_env, args[1]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_get_or_create_object_with_primary_key([[maybe_unused]] jsi::Runtime& _env,
                                                         [[maybe_unused]] const jsi::Value& thisValue,
                                                         [[maybe_unused]] const jsi::Value* args,
                                                         [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return [&](auto&& tup) {
            auto out = jsi::Array(_env, 2);
            out.setValueAtIndex(_env, 0, JS_FROM_CLASS_Obj(_env, std::get<0>(FWD(tup))));
            out.setValueAtIndex(_env, 1, jsi::Value(bool(std::get<1>(FWD(tup)))));
            return out;
        }(Helpers::get_or_create_object_with_primary_key(JS_TO_CLASS_TableRef(_env, args[0]),
                                                         JS_TO_Mixed(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_Request(jsi::Runtime& _env, const app::Request& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_method, [&] {
        static_assert(sizeof(app::HttpMethod) <= sizeof(int32_t), "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.method));
    }());
    out.setProperty(_env, RealmAddon::self->m_prop_url, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.url)));
    out.setProperty(_env, RealmAddon::self->m_prop_timeoutMs, bigIntFromU64(_env, in.timeout_ms));
    out.setProperty(_env, RealmAddon::self->m_prop_headers,

                    [&](auto&& map) {
                        auto out = jsi::Object(_env);
                        for (auto&& [k, v] : map) {
                            out.setProperty(_env, ([&](auto&& sd) {
                                                return jsi::String::createFromUtf8(
                                                    _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                            }(k)),
                                            ([&](auto&& sd) {
                                                return jsi::String::createFromUtf8(
                                                    _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                            }(v)));
                        }
                        return out;
                    }(in.headers));
    out.setProperty(_env, RealmAddon::self->m_prop_body, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.body)));
    return out;
}
app::Response STRUCT_FROM_JS_Response(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = app::Response();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_httpStatusCode);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.http_status_code = int32_t((FWD(field)).asNumber());
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "Response::httpStatusCode is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_customStatusCode);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.custom_status_code = int32_t((FWD(field)).asNumber());
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "Response::customStatusCode is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_headers);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.headers = [&](jsi::Object obj) {
                auto out = std::map<std::string, std::string>();
                const auto names = obj.getPropertyNames(_env);
                const auto length = names.length(_env);
                for (size_t i = 0; i < length; i++) {
                    auto name = names.getValueAtIndex(_env, i).getString(_env);
                    out.insert({name.utf8(_env), (obj.getProperty(_env, name)).asString(_env).utf8(_env)});
                }
                return out;
            }((FWD(field)).getObject(_env));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "Response::headers is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_body);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.body = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "Response::body is required");
        }
    }
    return out;
}
jsi::Value Helpers_make_network_transport([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_SHARED_GenericNetworkTransport(
            _env,
            Helpers::make_network_transport(util::EventLoopDispatcher(
                [_cb = std::make_shared<jsi::Function>(args[0].getObject(_env).getFunction(_env)),
                 _thread = ThreadConfinementChecker()](
                    app::Request const& request, util::UniqueFunction<void(app::Response&&)>&& callback) -> void {
                    _thread.assertOnSameThread();
                    auto& _env = RealmAddon::self->m_rt;
                    return ((void)(_cb->call(
                        _env,
                        {STRUCT_TO_JS_Request(_env, FWD(request)), [&](auto&& cb) -> jsi::Value {
                             if constexpr (std::is_constructible_v<bool, decltype(cb)>) {
                                 REALM_ASSERT(bool(cb) && "Must mark nullable callbacks with Nullable<> in spec");
                             }
                             return jsi::Function::createFromHostFunction(
                                 _env, RealmAddon::self->m_prop_callback, 1,
                                 [cb = MakeCopyable(FWD(cb))](jsi::Runtime& _env, const jsi::Value&,
                                                              const jsi::Value* args, size_t count) -> jsi::Value {
                                     const auto callBlock = RealmAddon::self->startCall();
                                     REALM_ASSERT_3(count, ==, 1u);
                                     try {

                                         return ((void)(cb(STRUCT_FROM_JS_Response(_env, args[0]))),
                                                 jsi::Value::undefined());
                                     }
                                     catch (const std::exception& ex) {
                                         throwJsiException(_env, ex);
                                     }
                                 });
                         }(FWD(FWD(callback)))})));
                })));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_delete_data_for_object([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)(Helpers::delete_data_for_object(
                    JS_TO_SHARED_Realm(_env, args[0]),
                    RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_base64_decode([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ([&](const auto& bd) -> jsi::Value {
            auto arr = (*RealmAddon::self->m_cls_ArrayBuffer_ctor)
                           .callAsConstructor(_env, int(bd.size()))
                           .getObject(_env)
                           .getArrayBuffer(_env);
            memcpy(arr.data(_env), bd.data(), bd.size());
            return arr;
        }(Helpers::base64_decode(RealmAddon::self->wrapString((args[0]).asString(_env).utf8(_env)))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_make_logger_factory([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_LoggerFactory(
            _env, Helpers::make_logger_factory(util::EventLoopDispatcher(
                      [_cb = std::make_shared<jsi::Function>(args[0].getObject(_env).getFunction(_env)),
                       _thread = ThreadConfinementChecker()](std::string const& category, util::Logger::Level level,
                                                             std::string const& message) -> void {
                          _thread.assertOnSameThread();
                          auto& _env = RealmAddon::self->m_rt;
                          return ((void)(_cb->call(
                              _env, {([&](auto&& sd) {
                                         return jsi::String::createFromUtf8(
                                             _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                     }(FWD(category))),
                                     [&] {
                                         static_assert(sizeof(util::Logger::Level) <= sizeof(int32_t),
                                                       "we only support enums up to 32 bits");
                                         return jsi::Value(_env, int(FWD(level)));
                                     }(),
                                     ([&](auto&& sd) {
                                         return jsi::String::createFromUtf8(
                                             _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                     }(FWD(message)))})));
                      })));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_make_logger([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_SHARED_Logger(
            _env, Helpers::make_logger(util::EventLoopDispatcher(
                      [_cb = std::make_shared<jsi::Function>(args[0].getObject(_env).getFunction(_env)),
                       _thread = ThreadConfinementChecker()](std::string const& category, util::Logger::Level level,
                                                             std::string const& message) -> void {
                          _thread.assertOnSameThread();
                          auto& _env = RealmAddon::self->m_rt;
                          return ((void)(_cb->call(
                              _env, {([&](auto&& sd) {
                                         return jsi::String::createFromUtf8(
                                             _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                     }(FWD(category))),
                                     [&] {
                                         static_assert(sizeof(util::Logger::Level) <= sizeof(int32_t),
                                                       "we only support enums up to 32 bits");
                                         return jsi::Value(_env, int(FWD(level)));
                                     }(),
                                     ([&](auto&& sd) {
                                         return jsi::String::createFromUtf8(
                                             _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                     }(FWD(message)))})));
                      })));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_simulate_sync_error([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 5)
            throw jsi::JSError(_env, "expected 5 arguments");
        return ((void)(Helpers::simulate_sync_error(
                    *JS_TO_SHARED_SyncSession(_env, args[0]), int32_t((args[1]).asNumber()),
                    (args[2]).asString(_env).utf8(_env), (args[3]).asString(_env).utf8(_env), (args[4]).asBool())),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_consume_thread_safe_reference_to_shared_realm([[maybe_unused]] jsi::Runtime& _env,
                                                                 [[maybe_unused]] const jsi::Value& thisValue,
                                                                 [[maybe_unused]] const jsi::Value* args,
                                                                 [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_SHARED_Realm(_env, Helpers::consume_thread_safe_reference_to_shared_realm(
                                              JS_TO_CLASS_ThreadSafeReference(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_file_exists([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(
            bool(Helpers::file_exists(RealmAddon::self->wrapString((args[0]).asString(_env).utf8(_env)))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
sync::Subscription STRUCT_FROM_JS_SyncSubscription(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = sync::Subscription();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_id);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.id = ObjectId(FWD(field).toString(_env).utf8(_env));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "SyncSubscription::id is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_createdAt);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.created_at = JS_TO_CLASS_Timestamp(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "SyncSubscription::createdAt is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_updatedAt);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.updated_at = JS_TO_CLASS_Timestamp(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "SyncSubscription::updatedAt is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_name);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.name = [&](auto&& val) {
                return val.isUndefined() ? std::optional<std::string>() : (FWD(val)).asString(_env).utf8(_env);
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncSubscription::name is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_objectClassName);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.object_class_name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "SyncSubscription::objectClassName is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_queryString);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.query_string = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "SyncSubscription::queryString is required");
        }
    }
    return out;
}
jsi::Value Helpers_erase_subscription([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return jsi::Value(bool(Helpers::erase_subscription(JS_TO_CLASS_MutableSyncSubscriptionSet(_env, args[0]),
                                                           STRUCT_FROM_JS_SyncSubscription(_env, args[1]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_get_results_description([[maybe_unused]] jsi::Runtime& _env,
                                           [[maybe_unused]] const jsi::Value& thisValue,
                                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }(Helpers::get_results_description(JS_TO_CLASS_Results(_env, args[0]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_feed_buffer([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)(Helpers::feed_buffer(JS_TO_CLASS_WatchStream(_env, args[0]), ([&](auto&& v) -> BinaryData {
                                                auto buf = FWD(v).asObject(_env).getArrayBuffer(_env);
                                                auto data = buf.data(_env);
                                                return BinaryData(data ? reinterpret_cast<const char*>(data) : "",
                                                                  buf.length(_env));
                                            })(args[1]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_make_ssl_verify_callback([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_SSLVerifyCallback(
            _env,
            Helpers::make_ssl_verify_callback(schedulerWrapBlockingFunction(
                [_cb = std::make_shared<jsi::Function>(args[0].getObject(_env).getFunction(_env)),
                 _thread = ThreadConfinementChecker()](std::string const& server_address, int32_t server_port,
                                                       std::string_view pem_data, int32_t preverify_ok,
                                                       int32_t depth) -> bool {
                    _thread.assertOnSameThread();
                    auto& _env = RealmAddon::self->m_rt;
                    return (_cb->call(_env, {([&](auto&& sd) {
                                                 return jsi::String::createFromUtf8(
                                                     _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                             }(FWD(server_address))),
                                             jsi::Value(double(FWD(server_port))), ([&](auto&& sd) {
                                                 return jsi::String::createFromUtf8(
                                                     _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                             }(FWD(pem_data))),
                                             jsi::Value(double(FWD(preverify_ok))), jsi::Value(double(FWD(depth)))}))
                        .asBool();
                })));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Property STRUCT_FROM_JS_Property(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = Property();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_name);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "Property::name is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_publicName);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.public_name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::publicName is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_type);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.type = PropertyType((FWD(field)).getNumber());
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "Property::type is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_objectType);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.object_type = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::objectType is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_linkOriginPropertyName);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.link_origin_property_name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::linkOriginPropertyName is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_isPrimary);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.is_primary = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::isPrimary is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_isIndexed);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.is_indexed = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::isIndexed is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_isFulltextIndexed);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.is_fulltext_indexed = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::isFulltextIndexed is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_columnKey);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.column_key = ColKey(bigIntToI64(_env, jsi::Value(_env, FWD(field))));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "Property::columnKey is required");
        }
    }
    return out;
}
ObjectSchema STRUCT_FROM_JS_ObjectSchema(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = ObjectSchema();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_name);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "ObjectSchema::name is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_persistedProperties);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.persisted_properties = [&](jsi::Array vec) {
                auto out = std::vector<Property>();

                const size_t length = vec.length(_env);
                out.reserve(length);
                for (size_t i = 0; i < length; i++) {
                    out.push_back(STRUCT_FROM_JS_Property(_env, vec.getValueAtIndex(_env, i)));
                }
                return out;
            }((FWD(field)).getObject(_env).getArray(_env));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ObjectSchema::persistedProperties is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_computedProperties);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.computed_properties = [&](jsi::Array vec) {
                auto out = std::vector<Property>();

                const size_t length = vec.length(_env);
                out.reserve(length);
                for (size_t i = 0; i < length; i++) {
                    out.push_back(STRUCT_FROM_JS_Property(_env, vec.getValueAtIndex(_env, i)));
                }
                return out;
            }((FWD(field)).getObject(_env).getArray(_env));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ObjectSchema::computedProperties is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_primaryKey);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.primary_key = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ObjectSchema::primaryKey is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_tableKey);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.table_key = TableKey(int32_t((FWD(field)).asNumber()));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ObjectSchema::tableKey is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_tableType);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.table_type = ObjectSchema::ObjectType((FWD(field)).getNumber());
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ObjectSchema::tableType is required");
        }
    }
    return out;
}
jsi::Value STRUCT_TO_JS_CompensatingWriteErrorInfo(jsi::Runtime& _env, const sync::CompensatingWriteErrorInfo& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_objectName, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.object_name)));
    out.setProperty(_env, RealmAddon::self->m_prop_reason, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.reason)));
    out.setProperty(_env, RealmAddon::self->m_prop_primaryKey, JS_FROM_Mixed(_env, in.primary_key));
    return out;
}
jsi::Value STRUCT_TO_JS_SyncError(jsi::Runtime& _env, const SyncError& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_status, ([&](const Status& status) -> jsi::Value {
                        if (status.is_ok()) {
                            return jsi::Value::undefined();
                        }
                        else {
                            auto jsObj = jsi::Object(_env);
                            jsObj.setProperty(_env, "isOk", status.is_ok());
                            jsObj.setProperty(_env, "code", static_cast<int32_t>(status.code()));
                            jsObj.setProperty(_env, "reason", status.reason());
                            return jsObj;
                        }
                    }(in.status)));
    out.setProperty(_env, RealmAddon::self->m_prop_isFatal, jsi::Value(bool(in.is_fatal)));
    out.setProperty(_env, RealmAddon::self->m_prop_simpleMessage, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.simple_message)));
    out.setProperty(_env, RealmAddon::self->m_prop_logUrl, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.logURL)));
    out.setProperty(_env, RealmAddon::self->m_prop_userInfo,

                    [&](auto&& map) {
                        auto out = jsi::Object(_env);
                        for (auto&& [k, v] : map) {
                            out.setProperty(_env, ([&](auto&& sd) {
                                                return jsi::String::createFromUtf8(
                                                    _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                            }(k)),
                                            ([&](auto&& sd) {
                                                return jsi::String::createFromUtf8(
                                                    _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                            }(v)));
                        }
                        return out;
                    }(in.user_info));
    out.setProperty(_env, RealmAddon::self->m_prop_isClientResetRequested,
                    jsi::Value(bool(in.is_client_reset_requested())));
    out.setProperty(_env, RealmAddon::self->m_prop_compensatingWritesInfo, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, STRUCT_TO_JS_CompensatingWriteErrorInfo(_env, e));
        }
        return out;
    }(in.compensating_writes_info));
    return out;
}
SyncConfig::ProxyConfig STRUCT_FROM_JS_SyncProxyConfig(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = SyncConfig::ProxyConfig();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_address);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.address = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "SyncProxyConfig::address is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_port);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.port = int32_t((FWD(field)).asNumber());
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "SyncProxyConfig::port is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_type);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.type = SyncConfig::ProxyConfig::Type((FWD(field)).getNumber());
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "SyncProxyConfig::type is required");
        }
    }
    return out;
}
SyncConfig STRUCT_FROM_JS_SyncConfig(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = SyncConfig();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_user);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.user = JS_TO_SHARED_SyncUser(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "SyncConfig::user is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_partitionValue);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.partition_value = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::partitionValue is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_stopPolicy);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.stop_policy = SyncSessionStopPolicy((FWD(field)).getNumber());
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::stopPolicy is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_flxSyncRequested);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.flx_sync_requested = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::flxSyncRequested is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_errorHandler);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.error_handler = [&](auto&& val) {
                return val.isNull()
                           ? std::function<void(std::shared_ptr<SyncSession>, SyncError)>()
                           : std::function<void(std::shared_ptr<SyncSession>, SyncError)>(util::EventLoopDispatcher(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<SyncSession> session,
                                                                        SyncError error) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_SyncSession(_env, FWD(session)),
                                                                     STRUCT_TO_JS_SyncError(_env, FWD(error))})));
                                 }));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::errorHandler is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_customHttpHeaders);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.custom_http_headers = [&](jsi::Object obj) {
                auto out = std::map<std::string, std::string>();
                const auto names = obj.getPropertyNames(_env);
                const auto length = names.length(_env);
                for (size_t i = 0; i < length; i++) {
                    auto name = names.getValueAtIndex(_env, i).getString(_env);
                    out.insert({name.utf8(_env), (obj.getProperty(_env, name)).asString(_env).utf8(_env)});
                }
                return out;
            }((FWD(field)).getObject(_env));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::customHttpHeaders is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_clientValidateSsl);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.client_validate_ssl = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::clientValidateSsl is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_sslTrustCertificatePath);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.ssl_trust_certificate_path = [&](auto&& val) {
                return val.isUndefined() ? std::optional<std::string>() : (FWD(val)).asString(_env).utf8(_env);
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::sslTrustCertificatePath is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_sslVerifyCallback);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.ssl_verify_callback = [&](auto&& val) {
                return val.isNull() ? std::function<SyncConfig::SSLVerifyCallback>()
                                    : JS_TO_CLASS_SSLVerifyCallback(_env, FWD(val));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::sslVerifyCallback is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_clientResyncMode);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.client_resync_mode = ClientResyncMode((FWD(field)).getNumber());
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::clientResyncMode is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_notifyBeforeClientReset);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.notify_before_client_reset = [&](auto&& val) {
                return val.isNull()
                           ? std::function<void(std::shared_ptr<Realm>)>()
                           : std::function<void(std::shared_ptr<Realm>)>(util::EventLoopDispatcher(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread =
                                      ThreadConfinementChecker()](std::shared_ptr<Realm> before_frozen) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return (
                                         (void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(before_frozen))})));
                                 }));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::notifyBeforeClientReset is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_notifyAfterClientReset);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.notify_after_client_reset = [&](auto&& val) {
                return val.isNull()
                           ? std::function<void(std::shared_ptr<Realm>, ThreadSafeReference, bool)>()
                           : std::function<void(std::shared_ptr<Realm>, ThreadSafeReference, bool)>(
                                 util::EventLoopDispatcher([_cb = std::make_shared<jsi::Function>(
                                                                FWD(val).getObject(_env).getFunction(_env)),
                                                            _thread = ThreadConfinementChecker()](
                                                               std::shared_ptr<Realm> before_frozen,
                                                               ThreadSafeReference after, bool did_recover) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return (
                                         (void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(before_frozen)),
                                                                 JS_FROM_CLASS_ThreadSafeReference(_env, FWD(after)),
                                                                 jsi::Value(bool(FWD(did_recover)))})));
                                 }));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::notifyAfterClientReset is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_cancelWaitsOnNonfatalError);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.cancel_waits_on_nonfatal_error = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::cancelWaitsOnNonfatalError is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_proxyConfig);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.proxy_config = [&](auto&& val) {
                return val.isUndefined() ? std::optional<SyncConfig::ProxyConfig>()
                                         : STRUCT_FROM_JS_SyncProxyConfig(_env, FWD(val));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncConfig::proxyConfig is required");
        }
    }
    return out;
}
RealmConfig STRUCT_FROM_JS_RealmConfig(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = RealmConfig();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_path);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.path = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "RealmConfig::path is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_cache);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.cache = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::cache is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_encryptionKey);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.encryption_key = ([&](auto&& v) -> std::vector<char> {
                auto buf = FWD(v).asObject(_env).getArrayBuffer(_env);
                auto data = buf.data(_env);
                const auto size = buf.length(_env);
                if (size == 0)
                    return {};
                return std::vector<char>(data, data + size);
            })(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::encryptionKey is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_fifoFilesFallbackPath);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.fifo_files_fallback_path = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::fifoFilesFallbackPath is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_inMemory);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.in_memory = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::inMemory is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_schema);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.schema = [&](auto&& val) {
                return val.isUndefined() ? std::optional<std::vector<ObjectSchema>>() : [&](jsi::Array vec) {
                    auto out = std::vector<ObjectSchema>();

                    const size_t length = vec.length(_env);
                    out.reserve(length);
                    for (size_t i = 0; i < length; i++) {
                        out.push_back(STRUCT_FROM_JS_ObjectSchema(_env, vec.getValueAtIndex(_env, i)));
                    }
                    return out;
                }((FWD(val)).getObject(_env).getArray(_env));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::schema is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_schemaVersion);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.schema_version = bigIntToI64(_env, jsi::Value(_env, FWD(field)));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::schemaVersion is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_schemaMode);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.schema_mode = SchemaMode((FWD(field)).getNumber());
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::schemaMode is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_disableFormatUpgrade);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.disable_format_upgrade = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::disableFormatUpgrade is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_syncConfig);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.sync_config = [&](auto&& val) {
                return val.isNull() ? std::shared_ptr<SyncConfig>()
                                    : std::make_shared<SyncConfig>(STRUCT_FROM_JS_SyncConfig(_env, FWD(val)));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::syncConfig is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_forceSyncHistory);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.force_sync_history = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::forceSyncHistory is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_migrationFunction);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.migration_function = [&](auto&& val) {
                return val.isNull()
                           ? std::function<void(std::shared_ptr<Realm>, std::shared_ptr<Realm>, Schema&)>()
                           : std::function<void(std::shared_ptr<Realm>, std::shared_ptr<Realm>, Schema&)>(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<Realm> old_realm,
                                                                        std::shared_ptr<Realm> new_realm,
                                                                        Schema&) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(old_realm)),
                                                                     JS_FROM_SHARED_Realm(_env, FWD(new_realm))})));
                                 });
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::migrationFunction is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_initializationFunction);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.initialization_function = [&](auto&& val) {
                return val.isNull()
                           ? std::function<void(std::shared_ptr<Realm>)>()
                           : std::function<void(std::shared_ptr<Realm>)>(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](std::shared_ptr<Realm> realm) -> void {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return ((void)(_cb->call(_env, {JS_FROM_SHARED_Realm(_env, FWD(realm))})));
                                 });
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::initializationFunction is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_shouldCompactOnLaunchFunction);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.should_compact_on_launch_function = [&](auto&& val) {
                return val.isNull()
                           ? std::function<bool(uint64_t, uint64_t)>()
                           : std::function<bool(uint64_t, uint64_t)>(schedulerWrapBlockingFunction(
                                 [_cb = std::make_shared<jsi::Function>(FWD(val).getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](uint64_t total_bytes,
                                                                        uint64_t used_bytes) -> bool {
                                     _thread.assertOnSameThread();
                                     auto& _env = RealmAddon::self->m_rt;
                                     return (_cb->call(_env, {bigIntFromU64(_env, FWD(total_bytes)),
                                                              bigIntFromU64(_env, FWD(used_bytes))}))
                                         .asBool();
                                 }));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::shouldCompactOnLaunchFunction is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_automaticallyHandleBacklinksInMigrations);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.automatically_handle_backlinks_in_migrations = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "RealmConfig::automaticallyHandleBacklinksInMigrations is required");
        }
    }
    return out;
}
jsi::Value Helpers_needs_file_format_upgrade([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(bool(Helpers::needs_file_format_upgrade(STRUCT_FROM_JS_RealmConfig(_env, args[0]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_sync_user_as_app_user([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : JS_FROM_SHARED_User(_env, FWD(val));
        }(Helpers::sync_user_as_app_user([&](auto&& val) {
            return val.isNull() ? std::shared_ptr<SyncUser>() : JS_TO_SHARED_SyncUser(_env, FWD(val));
        }(args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Helpers_app_user_as_sync_user([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : JS_FROM_SHARED_SyncUser(_env, FWD(val));
        }(Helpers::app_user_as_sync_user([&](auto&& val) {
            return val.isNull() ? std::shared_ptr<app::User>() : JS_TO_SHARED_User(_env, FWD(val));
        }(args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Helpers& JS_TO_CLASS_Helpers(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Helpers_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Helpers&>::extract(_env, external));

    return *ptr;
}
jsi::Value LogCategoryRef_set_default_level_threshold([[maybe_unused]] jsi::Runtime& _env,
                                                      [[maybe_unused]] const jsi::Value& thisValue,
                                                      [[maybe_unused]] const jsi::Value* args,
                                                      [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<util::LogCategoryRef&>::extract(_env, args[0])))
                           .set_default_level_threshold(util::Logger::Level((args[1]).getNumber()))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value LogCategoryRef_get_category([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_LogCategoryRef(_env, util::LogCategoryRef::get_category(RealmAddon::self->wrapString(
                                                      (args[0]).asString(_env).utf8(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
util::LogCategoryRef& JS_TO_CLASS_LogCategoryRef(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_LogCategoryRef_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<util::LogCategoryRef&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_LogCategoryRef(jsi::Runtime& _env, util::LogCategoryRef val)
{

    return (*RealmAddon::self->m_cls_LogCategoryRef_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<util::LogCategoryRef, util::LogCategoryRef>::create(_env, std::move(val))});
}
jsi::Value Logger_set_default_logger([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(util::Logger::set_default_logger([&](auto&& val) {
                    return val.isNull() ? std::shared_ptr<util::Logger>() : JS_TO_SHARED_Logger(_env, FWD(val));
                }(args[0]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<util::Logger>& JS_TO_SHARED_Logger(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Logger_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<util::Logger>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "Logger");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_Logger(jsi::Runtime& _env, std::shared_ptr<util::Logger> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_Logger_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<std::shared_ptr<util::Logger>, std::shared_ptr<util::Logger>>::create(
                               _env, std::move(val))});
}
jsi::Value ConstTableRef_get_column_type([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&] {
            static_assert(sizeof(DataType::Type) <= sizeof(int32_t), "we only support enums up to 32 bits");
            return jsi::Value(_env, int((**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                                            .get_column_type(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1]))))));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_get_link_target([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_ConstTableRef(
            _env, (**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                      .get_link_target(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_get_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(_env, (**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                                           .get_object(ObjKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_try_get_object([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : JS_FROM_CLASS_Obj(_env, FWD(val));
        }((**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                   .try_get_object(ObjKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_query([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return JS_FROM_CLASS_Query(
            _env,
            (**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                .query((args[1]).asString(_env).utf8(_env),
                       [&](jsi::Array vec) {
                           auto out = std::vector<mpark::variant<Mixed, std::vector<Mixed>>>();

                           const size_t length = vec.length(_env);
                           out.reserve(length);
                           for (size_t i = 0; i < length; i++) {
                               out.push_back(([&](auto&& arg) -> mpark::variant<Mixed, std::vector<Mixed>> {
                                   jsi::Value v = FWD(arg);
                                   if (v.isObject()) {
                                       auto obj = std::move(v).getObject(_env);
                                       const bool isArray = obj.isArray(_env);
                                       v = std::move(obj); // move back into a value
                                       if (isArray) {
                                           return [&](jsi::Array vec) {
                                               auto out = std::vector<Mixed>();

                                               const size_t length = vec.length(_env);
                                               out.reserve(length);
                                               for (size_t i = 0; i < length; i++) {
                                                   out.push_back(JS_TO_Mixed(_env, vec.getValueAtIndex(_env, i)));
                                               }
                                               return out;
                                           }((std::move(v)).getObject(_env).getArray(_env));
                                       }
                                   }
                                   return JS_TO_Mixed(_env, std::move(v));
                               })(vec.getValueAtIndex(_env, i)));
                           }
                           return out;
                       }((args[2]).getObject(_env).getArray(_env)),
                       JS_TO_CLASS_KeyPathMapping(_env, args[3])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_find_primary_key([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return bigIntFromI64(_env, ((**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))
                                        .find_primary_key(JS_TO_Mixed(_env, args[1])))
                                       .value);
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_get_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double(((**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0]))).get_key()).value));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ConstTableRef_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");

        auto& self = (**(&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])));
        auto jsIt = jsi::Object(_env);
        jsIt.setProperty(_env, "_keepAlive", args[0]);
        jsIt.setProperty(_env, "next",
                         jsi::Function::createFromHostFunction(
                             _env, RealmAddon::self->m_prop_next, 0,
                             [it = self.begin(), end = self.end()](
                                 [[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count) mutable {
                                 auto ret = jsi::Object(_env);
                                 if (it == end) {
                                     ret.setProperty(_env, RealmAddon::self->m_prop_done, jsi::Value(true));
                                 }
                                 else {
                                     ret.setProperty(_env, RealmAddon::self->m_prop_value,
                                                     JS_FROM_CLASS_Obj(_env, *it));
                                     ++it;
                                 }
                                 return ret;
                             }));

        return jsIt;
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
ConstTableRef& JS_TO_CLASS_ConstTableRef(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_ConstTableRef_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<ConstTableRef&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_ConstTableRef(jsi::Runtime& _env, ConstTableRef val)
{

    return (*RealmAddon::self->m_cls_ConstTableRef_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<ConstTableRef, ConstTableRef>::create(_env, std::move(val))});
}
jsi::Value TableRef_create_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Obj(
            _env,
            (**static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))).create_object());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value TableRef_remove_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, args[0]))))
                           .remove_object(ObjKey(bigIntToI64(_env, jsi::Value(_env, args[1]))))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value TableRef_get_link_target([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_TableRef(
            _env, (**static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, args[0]))))
                      .get_link_target(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value TableRef_clear([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, args[0])))).clear()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value TableRef_get_primary_key_column([[maybe_unused]] jsi::Runtime& _env,
                                           [[maybe_unused]] const jsi::Value& thisValue,
                                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env,
                             ((**static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, args[0]))))
                                  .get_primary_key_column())
                                 .value);
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
TableRef& JS_TO_CLASS_TableRef(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_TableRef_extractor).call(_env, &val, size_t(1));
    const auto ptr = static_cast<TableRef*>((&HostRefWrapper<ConstTableRef&>::extract(_env, external)));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_TableRef(jsi::Runtime& _env, TableRef val)
{

    return (*RealmAddon::self->m_cls_TableRef_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<TableRef, ConstTableRef>::create(_env, std::move(val))});
}
jsi::Value Obj_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_Mixed(_env, (*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                                       .get_any(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_set_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                       .set_any(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1]))), JS_TO_Mixed(_env, args[2]))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_set_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Obj(_env, (*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                                           .set_collection(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1]))),
                                                           CollectionType((args[2]).getNumber())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_add_int([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Obj(_env, (*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                                           .add_int(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1]))),
                                                    bigIntToI64(_env, jsi::Value(_env, args[2]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_get_linked_object([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : JS_FROM_CLASS_Obj(_env, FWD(val));
        }((*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                   .get_linked_object(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_get_backlink_count([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double(asSigned((*(&HostRefWrapper<Obj&>::extract(_env, args[0]))).get_backlink_count())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_get_backlink_view([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_TableView(_env,
                                       (*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                                           .get_backlink_view(JS_TO_CLASS_TableRef(_env, args[1]),
                                                              ColKey(bigIntToI64(_env, jsi::Value(_env, args[2])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_create_and_set_linked_object([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env, (*(&HostRefWrapper<Obj&>::extract(_env, args[0])))
                      .create_and_set_linked_object(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((*(&HostRefWrapper<Obj&>::extract(_env, args[0]))).is_valid()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_TableRef(_env, (*(&HostRefWrapper<Obj&>::extract(_env, args[0]))).get_table());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Obj_get_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env, ((*(&HostRefWrapper<Obj&>::extract(_env, args[0]))).get_key()).value);
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Obj& JS_TO_CLASS_Obj(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Obj_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Obj&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Obj(jsi::Runtime& _env, Obj val)
{

    return (*RealmAddon::self->m_cls_Obj_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<Obj, Obj>::create(_env, std::move(val))});
}
const std::shared_ptr<Transaction>& JS_TO_SHARED_Transaction(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Transaction_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<Transaction>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "Transaction");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_Transaction(jsi::Runtime& _env, std::shared_ptr<Transaction> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_Transaction_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<std::shared_ptr<Transaction>, std::shared_ptr<Transaction>>::create(
                               _env, std::move(val))});
}
ObjectStore& JS_TO_CLASS_ObjectStore(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_ObjectStore_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<ObjectStore&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_ObjectStore(jsi::Runtime& _env, ObjectStore val)
{

    return (*RealmAddon::self->m_cls_ObjectStore_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<ObjectStore, ObjectStore>::create(_env, std::move(val))});
}
jsi::Value Timestamp_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Timestamp(
            _env, Timestamp(bigIntToI64(_env, jsi::Value(_env, args[0])), int32_t((args[1]).asNumber())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Timestamp_get_seconds([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env, (*(&HostRefWrapper<Timestamp&>::extract(_env, args[0]))).get_seconds());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Timestamp_get_nanoseconds([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double((*(&HostRefWrapper<Timestamp&>::extract(_env, args[0]))).get_nanoseconds()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Timestamp& JS_TO_CLASS_Timestamp(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Timestamp_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Timestamp&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Timestamp(jsi::Runtime& _env, Timestamp val)
{

    return (*RealmAddon::self->m_cls_Timestamp_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<Timestamp, Timestamp>::create(_env, std::move(val))});
}
GeoPoint STRUCT_FROM_JS_GeoPoint(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = GeoPoint();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_longitude);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.longitude = (FWD(field)).asNumber();
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoPoint::longitude is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_latitude);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.latitude = (FWD(field)).asNumber();
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoPoint::latitude is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_altitude);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.altitude = (FWD(field)).asNumber();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "GeoPoint::altitude is required");
        }
    }
    return out;
}
GeoCircle STRUCT_FROM_JS_GeoCircle(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = GeoCircle();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_radiusRadians);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.radius_radians = (FWD(field)).asNumber();
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoCircle::radiusRadians is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_center);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.center = STRUCT_FROM_JS_GeoPoint(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoCircle::center is required");
        }
    }
    return out;
}
jsi::Value Geospatial_make_from_circle([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Geospatial(_env, Geospatial(STRUCT_FROM_JS_GeoCircle(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
GeoBox STRUCT_FROM_JS_GeoBox(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = GeoBox();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_lo);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.lo = STRUCT_FROM_JS_GeoPoint(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoBox::lo is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_hi);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.hi = STRUCT_FROM_JS_GeoPoint(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoBox::hi is required");
        }
    }
    return out;
}
jsi::Value Geospatial_make_from_box([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Geospatial(_env, Geospatial(STRUCT_FROM_JS_GeoBox(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
GeoPolygon STRUCT_FROM_JS_GeoPolygon(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = GeoPolygon();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_points);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.points = [&](jsi::Array vec) {
                auto out = std::vector<std::vector<GeoPoint>>();

                const size_t length = vec.length(_env);
                out.reserve(length);
                for (size_t i = 0; i < length; i++) {
                    out.push_back([&](jsi::Array vec) {
                        auto out = std::vector<GeoPoint>();

                        const size_t length = vec.length(_env);
                        out.reserve(length);
                        for (size_t i = 0; i < length; i++) {
                            out.push_back(STRUCT_FROM_JS_GeoPoint(_env, vec.getValueAtIndex(_env, i)));
                        }
                        return out;
                    }((vec.getValueAtIndex(_env, i)).getObject(_env).getArray(_env)));
                }
                return out;
            }((FWD(field)).getObject(_env).getArray(_env));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "GeoPolygon::points is required");
        }
    }
    return out;
}
jsi::Value Geospatial_make_from_polygon([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Geospatial(_env, Geospatial(STRUCT_FROM_JS_GeoPolygon(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Geospatial& JS_TO_CLASS_Geospatial(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Geospatial_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Geospatial&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Geospatial(jsi::Runtime& _env, Geospatial val)
{

    return (*RealmAddon::self->m_cls_Geospatial_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<Geospatial, Geospatial>::create(_env, std::move(val))});
}
jsi::Value ObjLink_get_table_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double(((*(&HostRefWrapper<ObjLink&>::extract(_env, args[0]))).get_table_key()).value));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value ObjLink_get_obj_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env, ((*(&HostRefWrapper<ObjLink&>::extract(_env, args[0]))).get_obj_key()).value);
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
ObjLink& JS_TO_CLASS_ObjLink(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_ObjLink_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<ObjLink&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_ObjLink(jsi::Runtime& _env, ObjLink val)
{

    return (*RealmAddon::self->m_cls_ObjLink_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<ObjLink, ObjLink>::create(_env, std::move(val))});
}
query_parser::KeyPathMapping& JS_TO_CLASS_KeyPathMapping(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_KeyPathMapping_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<query_parser::KeyPathMapping&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_KeyPathMapping(jsi::Runtime& _env, query_parser::KeyPathMapping val)
{

    return (*RealmAddon::self->m_cls_KeyPathMapping_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<query_parser::KeyPathMapping, query_parser::KeyPathMapping>::create(
                               _env, std::move(val))});
}
jsi::Value Query_get_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_ConstTableRef(_env, (*(&HostRefWrapper<Query&>::extract(_env, args[0]))).get_table());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Query_get_description([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((*(&HostRefWrapper<Query&>::extract(_env, args[0]))).get_description()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Query& JS_TO_CLASS_Query(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Query_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Query&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Query(jsi::Runtime& _env, Query val)
{

    return (*RealmAddon::self->m_cls_Query_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<Query, Query>::create(_env, std::move(val))});
}
SortDescriptor& JS_TO_CLASS_SortDescriptor(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_SortDescriptor_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<SortDescriptor&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_SortDescriptor(jsi::Runtime& _env, SortDescriptor val)
{

    return (*RealmAddon::self->m_cls_SortDescriptor_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<SortDescriptor, SortDescriptor>::create(_env, std::move(val))});
}
TableView& JS_TO_CLASS_TableView(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_TableView_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<TableView&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_TableView(jsi::Runtime& _env, TableView val)
{

    return (*RealmAddon::self->m_cls_TableView_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<TableView, TableView>::create(_env, std::move(val))});
}
jsi::Value Results_size([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double(asSigned((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).size())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_index_of([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(double(
            asSigned((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).index_of(JS_TO_Mixed(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_index_of_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(double(asSigned(
            (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).index_of(JS_TO_CLASS_Obj(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env,
            (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_Mixed(
            _env,
            (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get_any(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_List(
            _env,
            (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get_list(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_dictionary([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Dictionary(_env, (*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                                                  .get_dictionary(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_sort_by_names([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Results(
            _env, (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).sort([&](jsi::Array vec) {
                auto out = std::vector<std::pair<std::string, bool>>();

                const size_t length = vec.length(_env);
                out.reserve(length);
                for (size_t i = 0; i < length; i++) {
                    out.push_back([&](const jsi::Array& arr) {
                        if (arr.length(_env) != 2u)
                            throw jsi::JSError(_env, "Need an array with exactly 2 elements");
                        return std::make_pair((arr.getValueAtIndex(_env, 0u)).asString(_env).utf8(_env),
                                              (arr.getValueAtIndex(_env, 1u)).asBool());
                    }((vec.getValueAtIndex(_env, i)).getObject(_env).getArray(_env)));
                }
                return out;
            }((args[1]).getObject(_env).getArray(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_snapshot([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Results(_env, (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).snapshot());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_max([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined() : JS_FROM_Mixed(_env, *FWD(opt));
        }((*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                   .max(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_min([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined() : JS_FROM_Mixed(_env, *FWD(opt));
        }((*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                   .min(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_average([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined() : JS_FROM_Mixed(_env, *FWD(opt));
        }((*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                   .average(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_sum([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined() : JS_FROM_Mixed(_env, *FWD(opt));
        }((*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                   .sum(ColKey(bigIntToI64(_env, jsi::Value(_env, args[1])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_clear([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).clear()), jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_CollectionChangeSet(jsi::Runtime& _env, const CollectionChangeSet& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_deletions, JS_FROM_CLASS_IndexSet(_env, in.deletions));
    out.setProperty(_env, RealmAddon::self->m_prop_insertions, JS_FROM_CLASS_IndexSet(_env, in.insertions));
    out.setProperty(_env, RealmAddon::self->m_prop_modifications, JS_FROM_CLASS_IndexSet(_env, in.modifications));
    out.setProperty(_env, RealmAddon::self->m_prop_modificationsNew,
                    JS_FROM_CLASS_IndexSet(_env, in.modifications_new));
    return out;
}
jsi::Value Results_add_notification_callback([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_NotificationToken(
            _env,
            (*(&HostRefWrapper<Results&>::extract(_env, args[0])))
                .add_notification_callback(
                    [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                     _thread = ThreadConfinementChecker()](CollectionChangeSet const& changes) -> void {
                        _thread.assertOnSameThread();
                        auto& _env = RealmAddon::self->m_rt;
                        return ((void)(_cb->call(_env, {STRUCT_TO_JS_CollectionChangeSet(_env, FWD(changes))})));
                    },
                    [&](auto&& val) {
                        return val.isUndefined()
                                   ? std::optional<std::vector<std::vector<std::pair<TableKey, ColKey>>>>()
                                   : [&](jsi::Array vec) {
                                         auto out = std::vector<std::vector<std::pair<TableKey, ColKey>>>();

                                         const size_t length = vec.length(_env);
                                         out.reserve(length);
                                         for (size_t i = 0; i < length; i++) {
                                             out.push_back([&](jsi::Array vec) {
                                                 auto out = std::vector<std::pair<TableKey, ColKey>>();

                                                 const size_t length = vec.length(_env);
                                                 out.reserve(length);
                                                 for (size_t i = 0; i < length; i++) {
                                                     out.push_back([&](const jsi::Array& arr) {
                                                         if (arr.length(_env) != 2u)
                                                             throw jsi::JSError(
                                                                 _env, "Need an array with exactly 2 elements");
                                                         return std::make_pair(
                                                             TableKey(
                                                                 int32_t((arr.getValueAtIndex(_env, 0u)).asNumber())),
                                                             ColKey(bigIntToI64(
                                                                 _env,
                                                                 jsi::Value(_env, arr.getValueAtIndex(_env, 1u)))));
                                                     }((vec.getValueAtIndex(_env, i))
                                                                       .getObject(_env)
                                                                       .getArray(_env)));
                                                 }
                                                 return out;
                                             }((vec.getValueAtIndex(_env, i)).getObject(_env).getArray(_env)));
                                         }
                                         return out;
                                     }((FWD(val)).getObject(_env).getArray(_env));
                    }(args[2])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_from_table([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Results(
            _env, Results(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_ConstTableRef(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_from_table_view([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_Results(
            _env, Results(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_TableView(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).is_valid()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_query([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Query(_env, (*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get_query());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_object_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get_object_type()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Results_get_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&] {
            static_assert(sizeof(PropertyType) <= sizeof(int32_t), "we only support enums up to 32 bits");
            return jsi::Value(_env, int((*(&HostRefWrapper<Results&>::extract(_env, args[0]))).get_type()));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
Results& JS_TO_CLASS_Results(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Results_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<Results&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Results(jsi::Runtime& _env, Results val)
{

    return (*RealmAddon::self->m_cls_Results_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<Results, Results>::create(_env, std::move(val))});
}
jsi::Value Realm_begin_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).begin_transaction()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_commit_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).commit_transaction()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_cancel_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).cancel_transaction()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_update_schema([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 6)
            throw jsi::JSError(_env, "expected 5 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0])))
                           .update_schema(
                               [&](jsi::Array vec) {
                                   auto out = std::vector<ObjectSchema>();

                                   const size_t length = vec.length(_env);
                                   out.reserve(length);
                                   for (size_t i = 0; i < length; i++) {
                                       out.push_back(STRUCT_FROM_JS_ObjectSchema(_env, vec.getValueAtIndex(_env, i)));
                                   }
                                   return out;
                               }((args[1]).getObject(_env).getArray(_env)),
                               bigIntToI64(_env, jsi::Value(_env, args[2])),
                               [&](auto&& val) {
                                   return val.isNull()
                                              ? std::function<void(std::shared_ptr<Realm>, std::shared_ptr<Realm>,
                                                                   Schema&)>()
                                              : std::function<void(std::shared_ptr<Realm>, std::shared_ptr<Realm>,
                                                                   Schema&)>(
                                                    [_cb = std::make_shared<jsi::Function>(
                                                         FWD(val).getObject(_env).getFunction(_env)),
                                                     _thread = ThreadConfinementChecker()](
                                                        std::shared_ptr<Realm> old_realm,
                                                        std::shared_ptr<Realm> new_realm, Schema&) -> void {
                                                        _thread.assertOnSameThread();
                                                        auto& _env = RealmAddon::self->m_rt;
                                                        return ((void)(_cb->call(
                                                            _env, {JS_FROM_SHARED_Realm(_env, FWD(old_realm)),
                                                                   JS_FROM_SHARED_Realm(_env, FWD(new_realm))})));
                                                    });
                               }(args[3]),
                               [&](auto&& val) {
                                   return val.isNull()
                                              ? std::function<void(std::shared_ptr<Realm>)>()
                                              : std::function<void(std::shared_ptr<Realm>)>(
                                                    [_cb = std::make_shared<jsi::Function>(
                                                         FWD(val).getObject(_env).getFunction(_env)),
                                                     _thread = ThreadConfinementChecker()](
                                                        std::shared_ptr<Realm> realm) -> void {
                                                        _thread.assertOnSameThread();
                                                        auto& _env = RealmAddon::self->m_rt;
                                                        return ((void)(_cb->call(
                                                            _env, {JS_FROM_SHARED_Realm(_env, FWD(realm))})));
                                                    });
                               }(args[4]),
                               (args[5]).asBool())),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_compact([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).compact()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_convert([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0])))
                           .convert(STRUCT_FROM_JS_RealmConfig(_env, args[1]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_verify_open([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).verify_open()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_create_key_path_array([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return [&](auto&& vec) {
            auto out = jsi::Array(_env, vec.size());
            size_t i = 0;
            for (auto&& e : vec) {
                out.setValueAtIndex(_env, i++, [&](auto&& vec) {
                    auto out = jsi::Array(_env, vec.size());
                    size_t i = 0;
                    for (auto&& e : vec) {
                        out.setValueAtIndex(_env, i++, [&](auto&& tup) {
                            auto out = jsi::Array(_env, 2);
                            out.setValueAtIndex(_env, 0, jsi::Value(double((std::get<0>(FWD(tup))).value)));
                            out.setValueAtIndex(_env, 1, bigIntFromI64(_env, (std::get<1>(FWD(tup))).value));
                            return out;
                        }(e));
                    }
                    return out;
                }(e));
            }
            return out;
        }((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0])))
                   .create_key_path_array(
                       RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)), [&](jsi::Array vec) {
                           auto out = std::vector<std::string>();

                           const size_t length = vec.length(_env);
                           out.reserve(length);
                           for (size_t i = 0; i < length; i++) {
                               out.push_back((vec.getValueAtIndex(_env, i)).asString(_env).utf8(_env));
                           }
                           return out;
                       }((args[2]).getObject(_env).getArray(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_close([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).close()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_get_shared_realm([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_SHARED_Realm(_env, Realm::get_shared_realm(STRUCT_FROM_JS_RealmConfig(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_get_synchronized_realm([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_SHARED_AsyncOpenTask(_env,
                                            Realm::get_synchronized_realm(STRUCT_FROM_JS_RealmConfig(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_get_schema_version([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return bigIntFromI64(_env, Realm::get_schema_version(STRUCT_FROM_JS_RealmConfig(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_Property(jsi::Runtime& _env, const Property& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_name, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.name)));
    out.setProperty(_env, RealmAddon::self->m_prop_publicName, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.public_name)));
    out.setProperty(_env, RealmAddon::self->m_prop_type, [&] {
        static_assert(sizeof(PropertyType) <= sizeof(int32_t), "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.type));
    }());
    out.setProperty(_env, RealmAddon::self->m_prop_objectType, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.object_type)));
    out.setProperty(_env, RealmAddon::self->m_prop_linkOriginPropertyName, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.link_origin_property_name)));
    out.setProperty(_env, RealmAddon::self->m_prop_isPrimary, jsi::Value(bool(in.is_primary)));
    out.setProperty(_env, RealmAddon::self->m_prop_isIndexed, jsi::Value(bool(in.is_indexed)));
    out.setProperty(_env, RealmAddon::self->m_prop_isFulltextIndexed, jsi::Value(bool(in.is_fulltext_indexed)));
    out.setProperty(_env, RealmAddon::self->m_prop_columnKey, bigIntFromI64(_env, (in.column_key).value));
    return out;
}
jsi::Value STRUCT_TO_JS_ObjectSchema(jsi::Runtime& _env, const ObjectSchema& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_name, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.name)));
    out.setProperty(_env, RealmAddon::self->m_prop_persistedProperties, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, STRUCT_TO_JS_Property(_env, e));
        }
        return out;
    }(in.persisted_properties));
    out.setProperty(_env, RealmAddon::self->m_prop_computedProperties, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, STRUCT_TO_JS_Property(_env, e));
        }
        return out;
    }(in.computed_properties));
    out.setProperty(_env, RealmAddon::self->m_prop_primaryKey, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.primary_key)));
    out.setProperty(_env, RealmAddon::self->m_prop_tableKey, jsi::Value(double((in.table_key).value)));
    out.setProperty(_env, RealmAddon::self->m_prop_tableType, [&] {
        static_assert(sizeof(ObjectSchema::ObjectType) <= sizeof(int32_t), "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.table_type));
    }());
    return out;
}
jsi::Value STRUCT_TO_JS_SyncProxyConfig(jsi::Runtime& _env, const SyncConfig::ProxyConfig& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_address, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.address)));
    out.setProperty(_env, RealmAddon::self->m_prop_port, jsi::Value(double(in.port)));
    out.setProperty(_env, RealmAddon::self->m_prop_type, [&] {
        static_assert(sizeof(SyncConfig::ProxyConfig::Type) <= sizeof(int32_t),
                      "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.type));
    }());
    return out;
}
jsi::Value STRUCT_TO_JS_SyncConfig(jsi::Runtime& _env, const SyncConfig& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_user, JS_FROM_SHARED_SyncUser(_env, in.user));
    out.setProperty(_env, RealmAddon::self->m_prop_partitionValue, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.partition_value)));
    out.setProperty(_env, RealmAddon::self->m_prop_stopPolicy, [&] {
        static_assert(sizeof(SyncSessionStopPolicy) <= sizeof(int32_t), "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.stop_policy));
    }());
    out.setProperty(_env, RealmAddon::self->m_prop_flxSyncRequested, jsi::Value(bool(in.flx_sync_requested)));
    out.setProperty(_env, RealmAddon::self->m_prop_customHttpHeaders,

                    [&](auto&& map) {
                        auto out = jsi::Object(_env);
                        for (auto&& [k, v] : map) {
                            out.setProperty(_env, ([&](auto&& sd) {
                                                return jsi::String::createFromUtf8(
                                                    _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                            }(k)),
                                            ([&](auto&& sd) {
                                                return jsi::String::createFromUtf8(
                                                    _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                            }(v)));
                        }
                        return out;
                    }(in.custom_http_headers));
    out.setProperty(_env, RealmAddon::self->m_prop_clientValidateSsl, jsi::Value(bool(in.client_validate_ssl)));
    out.setProperty(_env, RealmAddon::self->m_prop_sslTrustCertificatePath, [&](auto&& opt) {
        return !opt ? jsi::Value::undefined() : ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }(*FWD(opt)));
    }(in.ssl_trust_certificate_path));
    out.setProperty(_env, RealmAddon::self->m_prop_sslVerifyCallback, [&](auto&& val) {
        return !val ? jsi::Value::null() : JS_FROM_CLASS_SSLVerifyCallback(_env, FWD(val));
    }(in.ssl_verify_callback));
    out.setProperty(_env, RealmAddon::self->m_prop_clientResyncMode, [&] {
        static_assert(sizeof(ClientResyncMode) <= sizeof(int32_t), "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.client_resync_mode));
    }());
    out.setProperty(_env, RealmAddon::self->m_prop_cancelWaitsOnNonfatalError,
                    jsi::Value(bool(in.cancel_waits_on_nonfatal_error)));
    out.setProperty(_env, RealmAddon::self->m_prop_proxyConfig, [&](auto&& opt) {
        return !opt ? jsi::Value::undefined() : STRUCT_TO_JS_SyncProxyConfig(_env, *FWD(opt));
    }(in.proxy_config));
    return out;
}
jsi::Value STRUCT_TO_JS_RealmConfig(jsi::Runtime& _env, const RealmConfig& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_path, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.path)));
    out.setProperty(_env, RealmAddon::self->m_prop_cache, jsi::Value(bool(in.cache)));
    out.setProperty(_env, RealmAddon::self->m_prop_encryptionKey, ([&](const auto& bd) -> jsi::Value {
                        auto arr = (*RealmAddon::self->m_cls_ArrayBuffer_ctor)
                                       .callAsConstructor(_env, int(bd.size()))
                                       .getObject(_env)
                                       .getArrayBuffer(_env);
                        memcpy(arr.data(_env), bd.data(), bd.size());
                        return arr;
                    }(in.encryption_key)));
    out.setProperty(_env, RealmAddon::self->m_prop_fifoFilesFallbackPath, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.fifo_files_fallback_path)));
    out.setProperty(_env, RealmAddon::self->m_prop_inMemory, jsi::Value(bool(in.in_memory)));
    out.setProperty(_env, RealmAddon::self->m_prop_schema, [&](auto&& opt) {
        return !opt ? jsi::Value::undefined() : [&](auto&& vec) {
            auto out = jsi::Array(_env, vec.size());
            size_t i = 0;
            for (auto&& e : vec) {
                out.setValueAtIndex(_env, i++, STRUCT_TO_JS_ObjectSchema(_env, e));
            }
            return out;
        }(*FWD(opt));
    }(in.schema));
    out.setProperty(_env, RealmAddon::self->m_prop_schemaVersion, bigIntFromI64(_env, in.schema_version));
    out.setProperty(_env, RealmAddon::self->m_prop_schemaMode, [&] {
        static_assert(sizeof(SchemaMode) <= sizeof(int32_t), "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.schema_mode));
    }());
    out.setProperty(_env, RealmAddon::self->m_prop_disableFormatUpgrade, jsi::Value(bool(in.disable_format_upgrade)));
    out.setProperty(_env, RealmAddon::self->m_prop_syncConfig, [&](auto&& val) {
        return !val ? jsi::Value::null() : [&](const auto& ptr) {
            if constexpr (requires { bool(ptr); }) { // support claiming that always-valid iterators are pointers.
                REALM_ASSERT(bool(ptr) && "Must mark nullable pointers with Nullable<> in spec");
            }
            return STRUCT_TO_JS_SyncConfig(_env, *ptr);
        }(FWD(val));
    }(in.sync_config));
    out.setProperty(_env, RealmAddon::self->m_prop_forceSyncHistory, jsi::Value(bool(in.force_sync_history)));
    out.setProperty(_env, RealmAddon::self->m_prop_automaticallyHandleBacklinksInMigrations,
                    jsi::Value(bool(in.automatically_handle_backlinks_in_migrations)));
    return out;
}
jsi::Value Realm_config([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return STRUCT_TO_JS_RealmConfig(
            _env, (**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).config());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_schema([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&](auto&& vec) {
            auto out = jsi::Array(_env, vec.size());
            size_t i = 0;
            for (auto&& e : vec) {
                out.setValueAtIndex(_env, i++, STRUCT_TO_JS_ObjectSchema(_env, e));
            }
            return out;
        }((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).schema());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_schema_version([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env,
                             (**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).schema_version());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_is_in_transaction([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(
            bool((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).is_in_transaction()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_is_in_migration([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(
            bool((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).is_in_migration()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_is_empty([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).is_empty()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_is_closed([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).is_closed()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_sync_session([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : JS_FROM_SHARED_SyncSession(_env, FWD(val));
        }((**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).sync_session());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_get_latest_subscription_set([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_SyncSubscriptionSet(
            _env,
            (**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).get_latest_subscription_set());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_DOLLAR_addr([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(double(double(
            reinterpret_cast<intptr_t>(&(**(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0])))))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Realm_DOLLAR_resetSharedPtr([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*(&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, args[0]))).reset()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<Realm>& JS_TO_SHARED_Realm(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Realm_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<Realm>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "Realm");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_Realm(jsi::Runtime& _env, std::shared_ptr<Realm> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_Realm_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<std::shared_ptr<Realm>, std::shared_ptr<Realm>>::create(
                                     _env, std::move(val))});
}
jsi::Value RealmCoordinator_clear_all_caches([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 0)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)(_impl::RealmCoordinator::clear_all_caches()), jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<_impl::RealmCoordinator>& JS_TO_SHARED_RealmCoordinator(jsi::Runtime& _env,
                                                                              const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_RealmCoordinator_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<_impl::RealmCoordinator>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "RealmCoordinator");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_RealmCoordinator(jsi::Runtime& _env, std::shared_ptr<_impl::RealmCoordinator> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_RealmCoordinator_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<std::shared_ptr<_impl::RealmCoordinator>,
                                       std::shared_ptr<_impl::RealmCoordinator>>::create(_env, std::move(val))});
}
jsi::Value STRUCT_TO_JS_ObjectChangeSet(jsi::Runtime& _env, const ObjectChangeSet& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_isDeleted, jsi::Value(bool(in.is_deleted)));
    out.setProperty(_env, RealmAddon::self->m_prop_changedColumns, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, bigIntFromI64(_env, (e).value));
        }
        return out;
    }(in.changed_columns));
    return out;
}
jsi::Value ObjectNotifier_add_callback([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return bigIntFromU64(
            _env,
            (**(&HostRefWrapper<std::shared_ptr<_impl::ObjectNotifier>&>::extract(_env, args[0])))
                .add_callback(
                    [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                     _thread = ThreadConfinementChecker()](ObjectChangeSet changes) -> void {
                        _thread.assertOnSameThread();
                        auto& _env = RealmAddon::self->m_rt;
                        return ((void)(_cb->call(_env, {STRUCT_TO_JS_ObjectChangeSet(_env, FWD(changes))})));
                    },
                    [&](auto&& val) {
                        return val.isUndefined()
                                   ? std::optional<std::vector<std::vector<std::pair<TableKey, ColKey>>>>()
                                   : [&](jsi::Array vec) {
                                         auto out = std::vector<std::vector<std::pair<TableKey, ColKey>>>();

                                         const size_t length = vec.length(_env);
                                         out.reserve(length);
                                         for (size_t i = 0; i < length; i++) {
                                             out.push_back([&](jsi::Array vec) {
                                                 auto out = std::vector<std::pair<TableKey, ColKey>>();

                                                 const size_t length = vec.length(_env);
                                                 out.reserve(length);
                                                 for (size_t i = 0; i < length; i++) {
                                                     out.push_back([&](const jsi::Array& arr) {
                                                         if (arr.length(_env) != 2u)
                                                             throw jsi::JSError(
                                                                 _env, "Need an array with exactly 2 elements");
                                                         return std::make_pair(
                                                             TableKey(
                                                                 int32_t((arr.getValueAtIndex(_env, 0u)).asNumber())),
                                                             ColKey(bigIntToI64(
                                                                 _env,
                                                                 jsi::Value(_env, arr.getValueAtIndex(_env, 1u)))));
                                                     }((vec.getValueAtIndex(_env, i))
                                                                       .getObject(_env)
                                                                       .getArray(_env)));
                                                 }
                                                 return out;
                                             }((vec.getValueAtIndex(_env, i)).getObject(_env).getArray(_env)));
                                         }
                                         return out;
                                     }((FWD(val)).getObject(_env).getArray(_env));
                    }(args[2])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<_impl::ObjectNotifier>& JS_TO_SHARED_ObjectNotifier(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_ObjectNotifier_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<_impl::ObjectNotifier>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "ObjectNotifier");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_ObjectNotifier(jsi::Runtime& _env, std::shared_ptr<_impl::ObjectNotifier> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_ObjectNotifier_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<std::shared_ptr<_impl::ObjectNotifier>,
                                       std::shared_ptr<_impl::ObjectNotifier>>::create(_env, std::move(val))});
}
jsi::Value NotificationToken_unregister([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*(&HostRefWrapper<NotificationToken&>::extract(_env, args[0]))).unregister()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value NotificationToken_for_object([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_NotificationToken(_env, NotificationToken(JS_TO_SHARED_ObjectNotifier(_env, args[0]),
                                                                       bigIntToU64(_env, jsi::Value(_env, args[1]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
NotificationToken& JS_TO_CLASS_NotificationToken(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_NotificationToken_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<NotificationToken&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_NotificationToken(jsi::Runtime& _env, NotificationToken val)
{

    return (*RealmAddon::self->m_cls_NotificationToken_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<NotificationToken, NotificationToken>::create(_env, std::move(val))});
}
jsi::Value IndexSet_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");

        auto& self = (*(&HostRefWrapper<IndexSet&>::extract(_env, args[0])));
        auto jsIt = jsi::Object(_env);
        jsIt.setProperty(_env, "_keepAlive", args[0]);
        jsIt.setProperty(
            _env, "next",
            jsi::Function::createFromHostFunction(
                _env, RealmAddon::self->m_prop_next, 0,
                [it = self.begin(),
                 end = self.end()]([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count) mutable {
                    auto ret = jsi::Object(_env);
                    if (it == end) {
                        ret.setProperty(_env, RealmAddon::self->m_prop_done, jsi::Value(true));
                    }
                    else {
                        ret.setProperty(
                            _env, RealmAddon::self->m_prop_value,

                            [&](auto&& tup) {
                                auto out = jsi::Array(_env, 2);
                                out.setValueAtIndex(_env, 0, jsi::Value(double(asSigned(std::get<0>(FWD(tup))))));
                                out.setValueAtIndex(_env, 1, jsi::Value(double(asSigned(std::get<1>(FWD(tup))))));
                                return out;
                            }(*it));
                        ++it;
                    }
                    return ret;
                }));

        return jsIt;
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
IndexSet& JS_TO_CLASS_IndexSet(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_IndexSet_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<IndexSet&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_IndexSet(jsi::Runtime& _env, IndexSet val)
{

    return (*RealmAddon::self->m_cls_IndexSet_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<IndexSet, IndexSet>::create(_env, std::move(val))});
}
jsi::Value Collection_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_Mixed(_env, (*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0])))
                                       .get_any(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_as_results([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Results(
            _env, (*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).as_results());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_snapshot([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Results(
            _env, (*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).snapshot());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_get_type([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&] {
            static_assert(sizeof(PropertyType) <= sizeof(int32_t), "we only support enums up to 32 bits");
            return jsi::Value(
                _env, int((*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).get_type()));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_get_object_schema([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return STRUCT_TO_JS_ObjectSchema(
            _env, (*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).get_object_schema());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_size([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(
            double(asSigned((*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).size())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Collection_is_valid([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((*(&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))).is_valid()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
object_store::Collection& JS_TO_CLASS_Collection(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Collection_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<object_store::Collection&>::extract(_env, external));

    return *ptr;
}
jsi::Value List_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env, (*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .get(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_List(
            _env, (*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .get_list(int32_t((args[1]).asNumber())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_get_dictionary([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Dictionary(
            _env, (*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .get_dictionary(int32_t((args[1]).asNumber())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_move([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .move(size_t(ptrdiff_t((args[1]).asNumber())), size_t(ptrdiff_t((args[2]).asNumber())))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_remove([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .remove(size_t(ptrdiff_t((args[1]).asNumber())))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .remove_all()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_swap([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .swap(size_t(ptrdiff_t((args[1]).asNumber())), size_t(ptrdiff_t((args[2]).asNumber())))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_delete_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .delete_all()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .insert_any(size_t(ptrdiff_t((args[1]).asNumber())), JS_TO_Mixed(_env, args[2]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_insert_embedded([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env, (*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .insert_embedded(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_insert_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .insert_collection(int32_t((args[1]).asNumber()), CollectionType((args[2]).getNumber()))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_set_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .set_any(size_t(ptrdiff_t((args[1]).asNumber())), JS_TO_Mixed(_env, args[2]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_set_embedded([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env, (*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .set_embedded(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_set_collection([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .set_collection(int32_t((args[1]).asNumber()), CollectionType((args[2]).getNumber()))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value List_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 3 arguments");
        return JS_FROM_CLASS_List(_env, List(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_Obj(_env, args[1]),
                                             ColKey(bigIntToI64(_env, jsi::Value(_env, args[2])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
List& JS_TO_CLASS_List(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_List_extractor).call(_env, &val, size_t(1));
    const auto ptr = static_cast<List*>((&HostRefWrapper<object_store::Collection&>::extract(_env, external)));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_List(jsi::Runtime& _env, List val)
{

    return (*RealmAddon::self->m_cls_List_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<List, object_store::Collection>::create(_env, std::move(val))});
}
jsi::Value Set_get_obj([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(_env, (*static_cast<object_store::Set*>(
                                            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                           .get(size_t(ptrdiff_t((args[1]).asNumber()))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Set_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& tup) {
            auto out = jsi::Array(_env, 2);
            out.setValueAtIndex(_env, 0, jsi::Value(double(asSigned(std::get<0>(FWD(tup))))));
            out.setValueAtIndex(_env, 1, jsi::Value(bool(std::get<1>(FWD(tup)))));
            return out;
        }((*static_cast<object_store::Set*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                   .insert_any(JS_TO_Mixed(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Set_remove_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& tup) {
            auto out = jsi::Array(_env, 2);
            out.setValueAtIndex(_env, 0, jsi::Value(double(asSigned(std::get<0>(FWD(tup))))));
            out.setValueAtIndex(_env, 1, jsi::Value(bool(std::get<1>(FWD(tup)))));
            return out;
        }((*static_cast<object_store::Set*>((&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                   .remove_any(JS_TO_Mixed(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Set_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<object_store::Set*>(
                            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .remove_all()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Set_delete_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<object_store::Set*>(
                            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .delete_all()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Set_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 3 arguments");
        return JS_FROM_CLASS_Set(_env,
                                 object_store::Set(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_Obj(_env, args[1]),
                                                   ColKey(bigIntToI64(_env, jsi::Value(_env, args[2])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
object_store::Set& JS_TO_CLASS_Set(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Set_extractor).call(_env, &val, size_t(1));
    const auto ptr =
        static_cast<object_store::Set*>((&HostRefWrapper<object_store::Collection&>::extract(_env, external)));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Set(jsi::Runtime& _env, object_store::Set val)
{

    return (*RealmAddon::self->m_cls_Set_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<object_store::Set, object_store::Collection>::create(_env, std::move(val))});
}
jsi::Value Dictionary_get_list([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_List(_env, (*static_cast<object_store::Dictionary*>(
                                             (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                            .get_list((args[1]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_get_dictionary([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Dictionary(_env,
                                        (*static_cast<object_store::Dictionary*>(
                                             (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                            .get_dictionary((args[1]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_contains([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(bool((*static_cast<object_store::Dictionary*>(
                                    (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                   .contains(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_DictionaryChangeSet(jsi::Runtime& _env, const DictionaryChangeSet& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_deletions, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, JS_FROM_Mixed(_env, e));
        }
        return out;
    }(in.deletions));
    out.setProperty(_env, RealmAddon::self->m_prop_insertions, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, JS_FROM_Mixed(_env, e));
        }
        return out;
    }(in.insertions));
    out.setProperty(_env, RealmAddon::self->m_prop_modifications, [&](auto&& vec) {
        auto out = jsi::Array(_env, vec.size());
        size_t i = 0;
        for (auto&& e : vec) {
            out.setValueAtIndex(_env, i++, JS_FROM_Mixed(_env, e));
        }
        return out;
    }(in.modifications));
    return out;
}
jsi::Value Dictionary_add_key_based_notification_callback([[maybe_unused]] jsi::Runtime& _env,
                                                          [[maybe_unused]] const jsi::Value& thisValue,
                                                          [[maybe_unused]] const jsi::Value* args,
                                                          [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_NotificationToken(
            _env,
            (*static_cast<object_store::Dictionary*>(
                 (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                .add_key_based_notification_callback(
                    [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                     _thread = ThreadConfinementChecker()](DictionaryChangeSet changes) -> void {
                        _thread.assertOnSameThread();
                        auto& _env = RealmAddon::self->m_rt;
                        return ((void)(_cb->call(_env, {STRUCT_TO_JS_DictionaryChangeSet(_env, FWD(changes))})));
                    },
                    [&](auto&& val) {
                        return val.isUndefined()
                                   ? std::optional<std::vector<std::vector<std::pair<TableKey, ColKey>>>>()
                                   : [&](jsi::Array vec) {
                                         auto out = std::vector<std::vector<std::pair<TableKey, ColKey>>>();

                                         const size_t length = vec.length(_env);
                                         out.reserve(length);
                                         for (size_t i = 0; i < length; i++) {
                                             out.push_back([&](jsi::Array vec) {
                                                 auto out = std::vector<std::pair<TableKey, ColKey>>();

                                                 const size_t length = vec.length(_env);
                                                 out.reserve(length);
                                                 for (size_t i = 0; i < length; i++) {
                                                     out.push_back([&](const jsi::Array& arr) {
                                                         if (arr.length(_env) != 2u)
                                                             throw jsi::JSError(
                                                                 _env, "Need an array with exactly 2 elements");
                                                         return std::make_pair(
                                                             TableKey(
                                                                 int32_t((arr.getValueAtIndex(_env, 0u)).asNumber())),
                                                             ColKey(bigIntToI64(
                                                                 _env,
                                                                 jsi::Value(_env, arr.getValueAtIndex(_env, 1u)))));
                                                     }((vec.getValueAtIndex(_env, i))
                                                                       .getObject(_env)
                                                                       .getArray(_env)));
                                                 }
                                                 return out;
                                             }((vec.getValueAtIndex(_env, i)).getObject(_env).getArray(_env)));
                                         }
                                         return out;
                                     }((FWD(val)).getObject(_env).getArray(_env));
                    }(args[2])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_insert_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return [&](auto&& tup) {
            auto out = jsi::Array(_env, 2);
            out.setValueAtIndex(_env, 0, jsi::Value(double(asSigned(std::get<0>(FWD(tup))))));
            out.setValueAtIndex(_env, 1, jsi::Value(bool(std::get<1>(FWD(tup)))));
            return out;
        }((*static_cast<object_store::Dictionary*>(
               (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                   .insert_any(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)),
                               JS_TO_Mixed(_env, args[2])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_insert_embedded([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_Obj(
            _env, (*static_cast<object_store::Dictionary*>(
                       (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                      .insert_embedded(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_insert_collection([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)((*static_cast<object_store::Dictionary*>(
                            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .insert_collection((args[1]).asString(_env).utf8(_env),
                                              CollectionType((args[2]).getNumber()))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_try_get_any([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined() : JS_FROM_Mixed(_env, *FWD(opt));
        }((*static_cast<object_store::Dictionary*>(
               (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                   .try_get_any(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_remove_all([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<object_store::Dictionary*>(
                            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                           .remove_all()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_try_erase([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(bool((*static_cast<object_store::Dictionary*>(
                                    (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                   .try_erase(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 3 arguments");
        return JS_FROM_CLASS_Dictionary(
            _env, object_store::Dictionary(JS_TO_SHARED_Realm(_env, args[0]), JS_TO_CLASS_Obj(_env, args[1]),
                                           ColKey(bigIntToI64(_env, jsi::Value(_env, args[2])))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_get_keys([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Results(_env, (*static_cast<object_store::Dictionary*>(
                                                (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                               .get_keys());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_get_values([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_Results(_env, (*static_cast<object_store::Dictionary*>(
                                                (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))))
                                               .get_values());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value Dictionary_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");

        auto& self = (*static_cast<object_store::Dictionary*>(
            (&HostRefWrapper<object_store::Collection&>::extract(_env, args[0]))));
        auto jsIt = jsi::Object(_env);
        jsIt.setProperty(_env, "_keepAlive", args[0]);
        jsIt.setProperty(
            _env, "next",
            jsi::Function::createFromHostFunction(
                _env, RealmAddon::self->m_prop_next, 0,
                [it = self.begin(),
                 end = self.end()]([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count) mutable {
                    auto ret = jsi::Object(_env);
                    if (it == end) {
                        ret.setProperty(_env, RealmAddon::self->m_prop_done, jsi::Value(true));
                    }
                    else {
                        ret.setProperty(_env, RealmAddon::self->m_prop_value,

                                        [&](auto&& tup) {
                                            auto out = jsi::Array(_env, 2);
                                            out.setValueAtIndex(_env, 0, JS_FROM_Mixed(_env, std::get<0>(FWD(tup))));
                                            out.setValueAtIndex(_env, 1, JS_FROM_Mixed(_env, std::get<1>(FWD(tup))));
                                            return out;
                                        }(*it));
                        ++it;
                    }
                    return ret;
                }));

        return jsIt;
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
object_store::Dictionary& JS_TO_CLASS_Dictionary(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Dictionary_extractor).call(_env, &val, size_t(1));
    const auto ptr =
        static_cast<object_store::Dictionary*>((&HostRefWrapper<object_store::Collection&>::extract(_env, external)));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_Dictionary(jsi::Runtime& _env, object_store::Dictionary val)
{

    return (*RealmAddon::self->m_cls_Dictionary_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<object_store::Dictionary, object_store::Collection>::create(
                                     _env, std::move(val))});
}
jsi::Value GoogleAuthCode_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_GoogleAuthCode(_env, app::AuthCode((args[0]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
app::AuthCode& JS_TO_CLASS_GoogleAuthCode(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_GoogleAuthCode_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<app::AuthCode&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_GoogleAuthCode(jsi::Runtime& _env, app::AuthCode val)
{

    return (*RealmAddon::self->m_cls_GoogleAuthCode_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<app::AuthCode, app::AuthCode>::create(_env, std::move(val))});
}
jsi::Value GoogleIdToken_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_GoogleIdToken(_env, app::IdToken((args[0]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
app::IdToken& JS_TO_CLASS_GoogleIdToken(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_GoogleIdToken_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<app::IdToken&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_GoogleIdToken(jsi::Runtime& _env, app::IdToken val)
{

    return (*RealmAddon::self->m_cls_GoogleIdToken_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<app::IdToken, app::IdToken>::create(_env, std::move(val))});
}
jsi::Value AppCredentials_facebook([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_AppCredentials(_env, app::AppCredentials::facebook((args[0]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AppCredentials_anonymous([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_AppCredentials(_env, app::AppCredentials::anonymous((args[0]).asBool()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AppCredentials_apple([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_AppCredentials(_env, app::AppCredentials::apple((args[0]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AppCredentials_google_auth([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_AppCredentials(
            _env, app::AppCredentials::google(REALM_DECAY_COPY(JS_TO_CLASS_GoogleAuthCode(_env, args[0]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AppCredentials_google_id([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_AppCredentials(
            _env, app::AppCredentials::google(REALM_DECAY_COPY(JS_TO_CLASS_GoogleIdToken(_env, args[0]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AppCredentials_custom([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_AppCredentials(_env, app::AppCredentials::custom((args[0]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AppCredentials_username_password([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_CLASS_AppCredentials(
            _env, app::AppCredentials::username_password((args[0]).asString(_env).utf8(_env),
                                                         (args[1]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AppCredentials_function([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_AppCredentials(
            _env, app::AppCredentials::function(
                      ((*RealmAddon::self->m_cls_EJSON_stringify_ctor).call(_env, {FWD_OR_COPY(args[0])}))
                          .asString(_env)
                          .utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AppCredentials_api_key([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_AppCredentials(_env, app::AppCredentials::api_key((args[0]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
app::AppCredentials& JS_TO_CLASS_AppCredentials(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_AppCredentials_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<app::AppCredentials&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_AppCredentials(jsi::Runtime& _env, app::AppCredentials val)
{

    return (*RealmAddon::self->m_cls_AppCredentials_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<app::AppCredentials, app::AppCredentials>::create(_env, std::move(val))});
}
app::User::Token& JS_TO_CLASS_UserSubscriptionToken(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_UserSubscriptionToken_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<app::User::Token&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_UserSubscriptionToken(jsi::Runtime& _env, app::User::Token val)
{

    return (*RealmAddon::self->m_cls_UserSubscriptionToken_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<app::User::Token, app::User::Token>::create(_env, std::move(val))});
}
jsi::Value SyncUser_is_logged_in([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(
            bool((**(&HostRefWrapper<std::shared_ptr<SyncUser>&>::extract(_env, args[0]))).is_logged_in()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<SyncUser>& JS_TO_SHARED_SyncUser(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_SyncUser_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<SyncUser>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "SyncUser");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_SyncUser(jsi::Runtime& _env, std::shared_ptr<SyncUser> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_SyncUser_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<std::shared_ptr<SyncUser>, std::shared_ptr<SyncUser>>::create(
                                     _env, std::move(val))});
}
jsi::Value User_subscribe([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_UserSubscriptionToken(
            _env, (**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0])))
                      .subscribe([_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](app::User const&) -> void {
                          _thread.assertOnSameThread();
                          auto& _env = RealmAddon::self->m_rt;
                          return ((void)(_cb->call(_env, {})));
                      }));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_unsubscribe([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0])))
                           .unsubscribe(JS_TO_CLASS_UserSubscriptionToken(_env, args[1]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_path_for_realm([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0])))
                    .path_for_realm(STRUCT_FROM_JS_SyncConfig(_env, args[1]), [&](auto&& val) {
                        return val.isUndefined() ? std::optional<std::string>()
                                                 : (FWD(val)).asString(_env).utf8(_env);
                    }(args[2]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_access_token_refresh_required([[maybe_unused]] jsi::Runtime& _env,
                                              [[maybe_unused]] const jsi::Value& thisValue,
                                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0])))
                                   .access_token_refresh_required()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_request_refresh_location([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0])))
                           .request_refresh_location(util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_request_access_token([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0])))
                           .request_access_token(util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_track_realm([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0])))
                           .track_realm(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_user_id([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).user_id()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_app_id([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).app_id()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_legacy_identities([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&](auto&& vec) {
            auto out = jsi::Array(_env, vec.size());
            size_t i = 0;
            for (auto&& e : vec) {
                out.setValueAtIndex(_env, i++, ([&](auto&& sd) {
                                        return jsi::String::createFromUtf8(
                                            _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                    }(e)));
            }
            return out;
        }((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).legacy_identities());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_access_token([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).access_token()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_refresh_token([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).refresh_token()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_state([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&] {
            static_assert(sizeof(SyncUser::State) <= sizeof(int32_t), "we only support enums up to 32 bits");
            return jsi::Value(
                _env, int((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).state()));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_device_id([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).device_id()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_has_device_id([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(
            bool((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).has_device_id()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_user_profile([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_UserProfile(
            _env, (**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).user_profile());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_UserIdentity(jsi::Runtime& _env, const app::UserIdentity& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_id, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.id)));
    out.setProperty(_env, RealmAddon::self->m_prop_providerType, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.provider_type)));
    return out;
}
jsi::Value User_identities([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&](auto&& vec) {
            auto out = jsi::Array(_env, vec.size());
            size_t i = 0;
            for (auto&& e : vec) {
                out.setValueAtIndex(_env, i++, STRUCT_TO_JS_UserIdentity(_env, e));
            }
            return out;
        }((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).identities());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_custom_data([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&](auto&& opt) {
            return !opt ? jsi::Value::undefined()
                        : (*RealmAddon::self->m_cls_EJSON_parse_ctor)
                              .call(_env, {([&](auto&& sd) {
                                        return jsi::String::createFromUtf8(
                                            _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                    }(bson::Bson(*FWD(opt)).to_string()))});
        }((**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).custom_data());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value User_app([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_SHARED_App(_env,
                                  (**(&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, args[0]))).app());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<app::User>& JS_TO_SHARED_User(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_User_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<app::User>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "User");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_User(jsi::Runtime& _env, std::shared_ptr<app::User> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_User_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<std::shared_ptr<app::User>, std::shared_ptr<app::User>>::create(
                                     _env, std::move(val))});
}
jsi::Value UserProfile_data([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return (*RealmAddon::self->m_cls_EJSON_parse_ctor)
            .call(
                _env, {([&](auto&& sd) {
                    return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                }(bson::Bson((*(&HostRefWrapper<app::UserProfile&>::extract(_env, args[0]))).data()).to_string()))});
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
app::UserProfile& JS_TO_CLASS_UserProfile(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_UserProfile_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<app::UserProfile&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_UserProfile(jsi::Runtime& _env, app::UserProfile val)
{

    return (*RealmAddon::self->m_cls_UserProfile_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<app::UserProfile, app::UserProfile>::create(_env, std::move(val))});
}
app::App::Token& JS_TO_CLASS_AppSubscriptionToken(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_AppSubscriptionToken_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<app::App::Token&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_AppSubscriptionToken(jsi::Runtime& _env, app::App::Token val)
{

    return (*RealmAddon::self->m_cls_AppSubscriptionToken_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<app::App::Token, app::App::Token>::create(_env, std::move(val))});
}
jsi::Value App_log_in_with_credentials([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                       .log_in_with_credentials(
                           JS_TO_CLASS_AppCredentials(_env, args[1]),
                           util::UniqueFunction<void(std::shared_ptr<app::User> const&,
                                                     std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::shared_ptr<app::User> const& user,
                                                                      std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env,
                                       {[&](auto&& val) {
                                            return !val ? jsi::Value::null() : JS_FROM_SHARED_User(_env, FWD(val));
                                        }(FWD(user)),
                                        [&](auto&& opt) {
                                            return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                                auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                                jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                  double(err.code()));
                                                return jsErr;
                                            }(*FWD(opt)));
                                        }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_log_out_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                       .log_out(
                           JS_TO_SHARED_User(_env, args[1]),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_refresh_custom_data([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                       .refresh_custom_data(
                           JS_TO_SHARED_User(_env, args[1]),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_link_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return (
            (void)((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                       .link_user(
                           JS_TO_SHARED_User(_env, args[1]), JS_TO_CLASS_AppCredentials(_env, args[2]),
                           util::UniqueFunction<void(std::shared_ptr<app::User> const&,
                                                     std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[3].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::shared_ptr<app::User> const& user,
                                                                      std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env,
                                       {[&](auto&& val) {
                                            return !val ? jsi::Value::null() : JS_FROM_SHARED_User(_env, FWD(val));
                                        }(FWD(user)),
                                        [&](auto&& opt) {
                                            return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                                auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                                jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                  double(err.code()));
                                                return jsErr;
                                            }(*FWD(opt)));
                                        }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_switch_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                           .switch_user(JS_TO_SHARED_User(_env, args[1]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_remove_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                       .remove_user(
                           JS_TO_SHARED_User(_env, args[1]),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_delete_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                       .delete_user(
                           JS_TO_SHARED_User(_env, args[1]),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_usernamePasswordProviderClient([[maybe_unused]] jsi::Runtime& _env,
                                              [[maybe_unused]] const jsi::Value& thisValue,
                                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_UsernamePasswordProviderClient(
            _env, (**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                      .provider_client<app::App::UsernamePasswordProviderClient>());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_userAPIKeyProviderClient([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_UserAPIKeyProviderClient(
            _env, (**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                      .provider_client<app::App::UserAPIKeyProviderClient>());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_push_notification_client([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_PushClient(_env,
                                        (**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                                            .push_notification_client((args[1]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_subscribe([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_AppSubscriptionToken(
            _env, (**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                      .subscribe([_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                                  _thread = ThreadConfinementChecker()](app::App const&) -> void {
                          _thread.assertOnSameThread();
                          auto& _env = RealmAddon::self->m_rt;
                          return ((void)(_cb->call(_env, {})));
                      }));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_unsubscribe([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                           .unsubscribe(JS_TO_CLASS_AppSubscriptionToken(_env, args[1]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_call_function([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 6)
            throw jsi::JSError(_env, "expected 5 arguments");
        return (
            (void)((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                       .call_function(
                           JS_TO_SHARED_User(_env, args[1]), (args[2]).asString(_env).utf8(_env),
                           ((*RealmAddon::self->m_cls_EJSON_stringify_ctor).call(_env, {FWD_OR_COPY(args[3])}))
                               .asString(_env)
                               .utf8(_env),
                           [&](auto&& val) {
                               return val.isUndefined() ? std::optional<std::string>()
                                                        : (FWD(val)).asString(_env).utf8(_env);
                           }(args[4]),
                           util::UniqueFunction<void(std::string const*, std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[5].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::string const* result,
                                                                      std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env,
                                       {[&](auto&& val) {
                                            return !val ? jsi::Value::null() : [&](const auto& ptr) {
                                                if constexpr (requires {
                                                                  bool(ptr);
                                                              }) { // support claiming that always-valid iterators are
                                                                   // pointers.
                                                    REALM_ASSERT(
                                                        bool(ptr) &&
                                                        "Must mark nullable pointers with Nullable<> in spec");
                                                }
                                                return (*RealmAddon::self->m_cls_EJSON_parse_ctor)
                                                    .call(_env, {([&](auto&& sd) {
                                                              return jsi::String::createFromUtf8(
                                                                  _env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                                  sd.size());
                                                          }(*ptr))});
                                            }(FWD(val));
                                        }(FWD(result)),
                                        [&](auto&& opt) {
                                            return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                                auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                                jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                  double(err.code()));
                                                return jsErr;
                                            }(*FWD(opt)));
                                        }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_make_streaming_request([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 5)
            throw jsi::JSError(_env, "expected 4 arguments");
        return STRUCT_TO_JS_Request(
            _env, (**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                      .make_streaming_request(
                          JS_TO_SHARED_User(_env, args[1]), (args[2]).asString(_env).utf8(_env),
                          bson::BsonArray(bson::parse(
                              ((*RealmAddon::self->m_cls_EJSON_stringify_ctor).call(_env, {FWD_OR_COPY(args[3])}))
                                  .asString(_env)
                                  .utf8(_env))),
                          [&](auto&& val) {
                              return val.isUndefined() ? std::optional<std::string>()
                                                       : (FWD(val)).asString(_env).utf8(_env);
                          }(args[4])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_update_base_url([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                       .update_base_url(
                           RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_get_base_url([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0]))).get_base_url()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_immediately_run_file_actions([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(bool((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0])))
                                   .immediately_run_file_actions((args[1]).asString(_env).utf8(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
app::AppConfig::DeviceInfo STRUCT_FROM_JS_DeviceInfo(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = app::AppConfig::DeviceInfo();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_platformVersion);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.platform_version = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "DeviceInfo::platformVersion is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_sdkVersion);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.sdk_version = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "DeviceInfo::sdkVersion is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_sdk);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.sdk = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "DeviceInfo::sdk is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_deviceName);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.device_name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "DeviceInfo::deviceName is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_deviceVersion);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.device_version = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "DeviceInfo::deviceVersion is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_frameworkName);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.framework_name = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "DeviceInfo::frameworkName is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_frameworkVersion);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.framework_version = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "DeviceInfo::frameworkVersion is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_bundleId);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.bundle_id = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "DeviceInfo::bundleId is required");
        }
    }
    return out;
}
sync::ResumptionDelayInfo STRUCT_FROM_JS_ResumptionDelayInfo(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = sync::ResumptionDelayInfo();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_maxResumptionDelayInterval);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.max_resumption_delay_interval =
                std::chrono::milliseconds(bigIntToU64(_env, jsi::Value(_env, FWD(field))));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ResumptionDelayInfo::maxResumptionDelayInterval is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_resumptionDelayInterval);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.resumption_delay_interval =
                std::chrono::milliseconds(bigIntToU64(_env, jsi::Value(_env, FWD(field))));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ResumptionDelayInfo::resumptionDelayInterval is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_resumptionDelayBackoffMultiplier);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.resumption_delay_backoff_multiplier = int32_t((FWD(field)).asNumber());
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ResumptionDelayInfo::resumptionDelayBackoffMultiplier is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_delayJitterDivisor);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.delay_jitter_divisor = int32_t((FWD(field)).asNumber());
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "ResumptionDelayInfo::delayJitterDivisor is required");
        }
    }
    return out;
}
SyncClientTimeouts STRUCT_FROM_JS_SyncClientTimeouts(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = SyncClientTimeouts();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_connectTimeout);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.connect_timeout = bigIntToU64(_env, jsi::Value(_env, FWD(field)));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncClientTimeouts::connectTimeout is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_connectionLingerTime);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.connection_linger_time = bigIntToU64(_env, jsi::Value(_env, FWD(field)));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncClientTimeouts::connectionLingerTime is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_pingKeepalivePeriod);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.ping_keepalive_period = bigIntToU64(_env, jsi::Value(_env, FWD(field)));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncClientTimeouts::pingKeepalivePeriod is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_pongKeepaliveTimeout);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.pong_keepalive_timeout = bigIntToU64(_env, jsi::Value(_env, FWD(field)));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncClientTimeouts::pongKeepaliveTimeout is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_fastReconnectLimit);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.fast_reconnect_limit = bigIntToU64(_env, jsi::Value(_env, FWD(field)));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncClientTimeouts::fastReconnectLimit is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_reconnectBackoffInfo);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.reconnect_backoff_info = STRUCT_FROM_JS_ResumptionDelayInfo(_env, FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncClientTimeouts::reconnectBackoffInfo is required");
        }
    }
    return out;
}
SyncClientConfig STRUCT_FROM_JS_SyncClientConfig(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = SyncClientConfig();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_multiplexSessions);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.multiplex_sessions = (FWD(field)).asBool();
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncClientConfig::multiplexSessions is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_userAgentBindingInfo);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.user_agent_binding_info = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncClientConfig::userAgentBindingInfo is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_timeouts);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.timeouts = STRUCT_FROM_JS_SyncClientTimeouts(_env, FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "SyncClientConfig::timeouts is required");
        }
    }
    return out;
}
app::AppConfig STRUCT_FROM_JS_AppConfig(jsi::Runtime& _env, auto&& val)
{
    auto obj = FWD(val).asObject(_env);
    auto out = app::AppConfig();
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_appId);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.app_id = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "AppConfig::appId is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_transport);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.transport = JS_TO_SHARED_GenericNetworkTransport(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "AppConfig::transport is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_baseUrl);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.base_url = [&](auto&& val) {
                return val.isUndefined() ? std::optional<std::string>() : (FWD(val)).asString(_env).utf8(_env);
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "AppConfig::baseUrl is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_defaultRequestTimeoutMs);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.default_request_timeout_ms = [&](auto&& val) {
                return val.isUndefined() ? std::optional<uint64_t>() : bigIntToU64(_env, jsi::Value(_env, FWD(val)));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "AppConfig::defaultRequestTimeoutMs is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_deviceInfo);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.device_info = STRUCT_FROM_JS_DeviceInfo(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "AppConfig::deviceInfo is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_baseFilePath);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.base_file_path = (FWD(field)).asString(_env).utf8(_env);
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "AppConfig::baseFilePath is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_syncClientConfig);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.sync_client_config = STRUCT_FROM_JS_SyncClientConfig(_env, FWD(field));
        }
        else if constexpr (true) {
            throw jsi::JSError(_env, "AppConfig::syncClientConfig is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_metadataMode);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.metadata_mode = app::AppConfig::MetadataMode((FWD(field)).getNumber());
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "AppConfig::metadataMode is required");
        }
    }
    {
        auto field = obj.getProperty(_env, RealmAddon::self->m_prop_customEncryptionKey);
        if (!field.isUndefined()) {
            // Make functions on structs behave like bound methods.
            if (field.isObject()) {
                auto fieldObj = field.getObject(_env);
                if (fieldObj.isFunction(_env)) {
                    field = fieldObj.getProperty(_env, RealmAddon::self->m_prop_bind)
                                .getObject(_env)
                                .getFunction(_env)
                                .callWithThis(_env, fieldObj, obj);
                }
            }
            out.custom_encryption_key = [&](auto&& val) {
                return val.isUndefined() ? std::optional<std::vector<char>>() : ([&](auto&& v) -> std::vector<char> {
                    auto buf = FWD(v).asObject(_env).getArrayBuffer(_env);
                    auto data = buf.data(_env);
                    const auto size = buf.length(_env);
                    if (size == 0)
                        return {};
                    return std::vector<char>(data, data + size);
                })(FWD(val));
            }(FWD(field));
        }
        else if constexpr (false) {
            throw jsi::JSError(_env, "AppConfig::customEncryptionKey is required");
        }
    }
    return out;
}
jsi::Value App_get_app([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return JS_FROM_SHARED_App(_env, app::App::get_app(app::App::CacheMode((args[0]).getNumber()),
                                                          STRUCT_FROM_JS_AppConfig(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_clear_cached_apps([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 0)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)(app::App::clear_cached_apps()), jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_DeviceInfo(jsi::Runtime& _env, const app::AppConfig::DeviceInfo& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_platformVersion, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.platform_version)));
    out.setProperty(_env, RealmAddon::self->m_prop_sdkVersion, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.sdk_version)));
    out.setProperty(_env, RealmAddon::self->m_prop_sdk, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.sdk)));
    out.setProperty(_env, RealmAddon::self->m_prop_deviceName, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.device_name)));
    out.setProperty(_env, RealmAddon::self->m_prop_deviceVersion, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.device_version)));
    out.setProperty(_env, RealmAddon::self->m_prop_frameworkName, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.framework_name)));
    out.setProperty(_env, RealmAddon::self->m_prop_frameworkVersion, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.framework_version)));
    out.setProperty(_env, RealmAddon::self->m_prop_bundleId, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.bundle_id)));
    return out;
}
jsi::Value STRUCT_TO_JS_ResumptionDelayInfo(jsi::Runtime& _env, const sync::ResumptionDelayInfo& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_maxResumptionDelayInterval,
                    bigIntFromU64(_env, std::chrono::milliseconds(in.max_resumption_delay_interval).count()));
    out.setProperty(_env, RealmAddon::self->m_prop_resumptionDelayInterval,
                    bigIntFromU64(_env, std::chrono::milliseconds(in.resumption_delay_interval).count()));
    out.setProperty(_env, RealmAddon::self->m_prop_resumptionDelayBackoffMultiplier,
                    jsi::Value(double(in.resumption_delay_backoff_multiplier)));
    out.setProperty(_env, RealmAddon::self->m_prop_delayJitterDivisor, jsi::Value(double(in.delay_jitter_divisor)));
    return out;
}
jsi::Value STRUCT_TO_JS_SyncClientTimeouts(jsi::Runtime& _env, const SyncClientTimeouts& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_connectTimeout, bigIntFromU64(_env, in.connect_timeout));
    out.setProperty(_env, RealmAddon::self->m_prop_connectionLingerTime,
                    bigIntFromU64(_env, in.connection_linger_time));
    out.setProperty(_env, RealmAddon::self->m_prop_pingKeepalivePeriod,
                    bigIntFromU64(_env, in.ping_keepalive_period));
    out.setProperty(_env, RealmAddon::self->m_prop_pongKeepaliveTimeout,
                    bigIntFromU64(_env, in.pong_keepalive_timeout));
    out.setProperty(_env, RealmAddon::self->m_prop_fastReconnectLimit, bigIntFromU64(_env, in.fast_reconnect_limit));
    out.setProperty(_env, RealmAddon::self->m_prop_reconnectBackoffInfo,
                    STRUCT_TO_JS_ResumptionDelayInfo(_env, in.reconnect_backoff_info));
    return out;
}
jsi::Value STRUCT_TO_JS_SyncClientConfig(jsi::Runtime& _env, const SyncClientConfig& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_multiplexSessions, jsi::Value(bool(in.multiplex_sessions)));
    out.setProperty(_env, RealmAddon::self->m_prop_userAgentBindingInfo, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.user_agent_binding_info)));
    out.setProperty(_env, RealmAddon::self->m_prop_timeouts, STRUCT_TO_JS_SyncClientTimeouts(_env, in.timeouts));
    return out;
}
jsi::Value STRUCT_TO_JS_AppConfig(jsi::Runtime& _env, const app::AppConfig& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_appId, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.app_id)));
    out.setProperty(_env, RealmAddon::self->m_prop_transport,
                    JS_FROM_SHARED_GenericNetworkTransport(_env, in.transport));
    out.setProperty(_env, RealmAddon::self->m_prop_baseUrl, [&](auto&& opt) {
        return !opt ? jsi::Value::undefined() : ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }(*FWD(opt)));
    }(in.base_url));
    out.setProperty(_env, RealmAddon::self->m_prop_defaultRequestTimeoutMs, [&](auto&& opt) {
        return !opt ? jsi::Value::undefined() : bigIntFromU64(_env, *FWD(opt));
    }(in.default_request_timeout_ms));
    out.setProperty(_env, RealmAddon::self->m_prop_deviceInfo, STRUCT_TO_JS_DeviceInfo(_env, in.device_info));
    out.setProperty(_env, RealmAddon::self->m_prop_baseFilePath, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.base_file_path)));
    out.setProperty(_env, RealmAddon::self->m_prop_syncClientConfig,
                    STRUCT_TO_JS_SyncClientConfig(_env, in.sync_client_config));
    out.setProperty(_env, RealmAddon::self->m_prop_metadataMode, [&] {
        static_assert(sizeof(app::AppConfig::MetadataMode) <= sizeof(int32_t), "we only support enums up to 32 bits");
        return jsi::Value(_env, int(in.metadata_mode));
    }());
    out.setProperty(_env, RealmAddon::self->m_prop_customEncryptionKey, [&](auto&& opt) {
        return !opt ? jsi::Value::undefined() : ([&](const auto& bd) -> jsi::Value {
            auto arr = (*RealmAddon::self->m_cls_ArrayBuffer_ctor)
                           .callAsConstructor(_env, int(bd.size()))
                           .getObject(_env)
                           .getArrayBuffer(_env);
            memcpy(arr.data(_env), bd.data(), bd.size());
            return arr;
        }(*FWD(opt)));
    }(in.custom_encryption_key));
    return out;
}
jsi::Value App_config([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return STRUCT_TO_JS_AppConfig(
            _env, (**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0]))).config());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_current_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : JS_FROM_SHARED_User(_env, FWD(val));
        }((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0]))).current_user());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_all_users([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&](auto&& vec) {
            auto out = jsi::Array(_env, vec.size());
            size_t i = 0;
            for (auto&& e : vec) {
                out.setValueAtIndex(_env, i++, JS_FROM_SHARED_User(_env, e));
            }
            return out;
        }((**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0]))).all_users());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value App_sync_manager([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_SHARED_SyncManager(
            _env, (**(&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, args[0]))).sync_manager());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<app::App>& JS_TO_SHARED_App(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_App_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<app::App>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "App");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_App(jsi::Runtime& _env, std::shared_ptr<app::App> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_App_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<std::shared_ptr<app::App>, std::shared_ptr<app::App>>::create(
                                     _env, std::move(val))});
}
jsi::Value WatchStream_next_event([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                  [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return (*RealmAddon::self->m_cls_EJSON_parse_ctor)
            .call(_env, {([&](auto&& sd) {
                      return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                         sd.size());
                  }(bson::Bson((*(&HostRefWrapper<app::WatchStream&>::extract(_env, args[0]))).next_event())
                              .to_string()))});
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value WatchStream_make([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 0)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_WatchStream(_env, app::WatchStream());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value WatchStream_state([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&] {
            static_assert(sizeof(app::WatchStream::State) <= sizeof(int32_t), "we only support enums up to 32 bits");
            return jsi::Value(_env, int((*(&HostRefWrapper<app::WatchStream&>::extract(_env, args[0]))).state()));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value WatchStream_error([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](const app::AppError& err) {
            auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
            jsErr.setProperty(_env, RealmAddon::self->m_prop_code, double(err.code()));
            return jsErr;
        }((*(&HostRefWrapper<app::WatchStream&>::extract(_env, args[0]))).error()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
app::WatchStream& JS_TO_CLASS_WatchStream(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_WatchStream_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<app::WatchStream&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_WatchStream(jsi::Runtime& _env, app::WatchStream val)
{

    return (*RealmAddon::self->m_cls_WatchStream_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<app::WatchStream, app::WatchStream>::create(_env, std::move(val))});
}
jsi::Value PushClient_register_device([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return (
            (void)((*(&HostRefWrapper<app::PushClient&>::extract(_env, args[0])))
                       .register_device(
                           (args[1]).asString(_env).utf8(_env), JS_TO_SHARED_User(_env, args[2]),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[3].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value PushClient_deregister_device([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((*(&HostRefWrapper<app::PushClient&>::extract(_env, args[0])))
                       .deregister_device(
                           JS_TO_SHARED_User(_env, args[1]),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
app::PushClient& JS_TO_CLASS_PushClient(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_PushClient_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<app::PushClient&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_PushClient(jsi::Runtime& _env, app::PushClient val)
{

    return (*RealmAddon::self->m_cls_PushClient_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<app::PushClient, app::PushClient>::create(_env, std::move(val))});
}
jsi::Value UsernamePasswordProviderClient_register_email([[maybe_unused]] jsi::Runtime& _env,
                                                         [[maybe_unused]] const jsi::Value& thisValue,
                                                         [[maybe_unused]] const jsi::Value* args,
                                                         [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UsernamePasswordProviderClient&>::extract(_env, args[0])))
                       .register_email(
                           (args[1]).asString(_env).utf8(_env), (args[2]).asString(_env).utf8(_env),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[3].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UsernamePasswordProviderClient_retry_custom_confirmation([[maybe_unused]] jsi::Runtime& _env,
                                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                                    [[maybe_unused]] const jsi::Value* args,
                                                                    [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UsernamePasswordProviderClient&>::extract(_env, args[0])))
                       .retry_custom_confirmation(
                           (args[1]).asString(_env).utf8(_env),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UsernamePasswordProviderClient_confirm_user([[maybe_unused]] jsi::Runtime& _env,
                                                       [[maybe_unused]] const jsi::Value& thisValue,
                                                       [[maybe_unused]] const jsi::Value* args,
                                                       [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UsernamePasswordProviderClient&>::extract(_env, args[0])))
                       .confirm_user(
                           (args[1]).asString(_env).utf8(_env), (args[2]).asString(_env).utf8(_env),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[3].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UsernamePasswordProviderClient_resend_confirmation_email([[maybe_unused]] jsi::Runtime& _env,
                                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                                    [[maybe_unused]] const jsi::Value* args,
                                                                    [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UsernamePasswordProviderClient&>::extract(_env, args[0])))
                       .resend_confirmation_email(
                           (args[1]).asString(_env).utf8(_env),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UsernamePasswordProviderClient_reset_password([[maybe_unused]] jsi::Runtime& _env,
                                                         [[maybe_unused]] const jsi::Value& thisValue,
                                                         [[maybe_unused]] const jsi::Value* args,
                                                         [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 5)
            throw jsi::JSError(_env, "expected 4 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UsernamePasswordProviderClient&>::extract(_env, args[0])))
                       .reset_password(
                           (args[1]).asString(_env).utf8(_env), (args[2]).asString(_env).utf8(_env),
                           (args[3]).asString(_env).utf8(_env),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[4].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UsernamePasswordProviderClient_send_reset_password_email([[maybe_unused]] jsi::Runtime& _env,
                                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                                    [[maybe_unused]] const jsi::Value* args,
                                                                    [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UsernamePasswordProviderClient&>::extract(_env, args[0])))
                       .send_reset_password_email(
                           (args[1]).asString(_env).utf8(_env),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UsernamePasswordProviderClient_call_reset_password_function([[maybe_unused]] jsi::Runtime& _env,
                                                                       [[maybe_unused]] const jsi::Value& thisValue,
                                                                       [[maybe_unused]] const jsi::Value* args,
                                                                       [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 5)
            throw jsi::JSError(_env, "expected 4 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UsernamePasswordProviderClient&>::extract(_env, args[0])))
                       .call_reset_password_function(
                           (args[1]).asString(_env).utf8(_env), (args[2]).asString(_env).utf8(_env),
                           bson::BsonArray(bson::parse(
                               ((*RealmAddon::self->m_cls_EJSON_stringify_ctor).call(_env, {FWD_OR_COPY(args[3])}))
                                   .asString(_env)
                                   .utf8(_env))),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[4].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
app::App::UsernamePasswordProviderClient& JS_TO_CLASS_UsernamePasswordProviderClient(jsi::Runtime& _env,
                                                                                     const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_UsernamePasswordProviderClient_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<app::App::UsernamePasswordProviderClient&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_UsernamePasswordProviderClient(jsi::Runtime& _env,
                                                        app::App::UsernamePasswordProviderClient val)
{

    return (*RealmAddon::self->m_cls_UsernamePasswordProviderClient_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<app::App::UsernamePasswordProviderClient,
                                       app::App::UsernamePasswordProviderClient>::create(_env, std::move(val))});
}
jsi::Value STRUCT_TO_JS_UserAPIKey(jsi::Runtime& _env, const app::App::UserAPIKey& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_id,
                    (*RealmAddon::self->m_cls_ObjectId_ctor)
                        .callAsConstructor(_env, {([&](auto&& sd) {
                                               return jsi::String::createFromUtf8(
                                                   _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                           }(in.id.to_string()))}));
    out.setProperty(_env, RealmAddon::self->m_prop_key, [&](auto&& opt) {
        return !opt ? jsi::Value::undefined() : ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }(*FWD(opt)));
    }(in.key));
    out.setProperty(_env, RealmAddon::self->m_prop_name, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.name)));
    out.setProperty(_env, RealmAddon::self->m_prop_disabled, jsi::Value(bool(in.disabled)));
    return out;
}
jsi::Value UserAPIKeyProviderClient_create_api_key([[maybe_unused]] jsi::Runtime& _env,
                                                   [[maybe_unused]] const jsi::Value& thisValue,
                                                   [[maybe_unused]] const jsi::Value* args,
                                                   [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UserAPIKeyProviderClient&>::extract(_env, args[0])))
                       .create_api_key(
                           (args[1]).asString(_env).utf8(_env), JS_TO_SHARED_User(_env, args[2]),
                           util::UniqueFunction<void(app::App::UserAPIKey&&, std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[3].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](app::App::UserAPIKey&& apiKey,
                                                                      std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env,
                                       {STRUCT_TO_JS_UserAPIKey(_env, FWD(apiKey)), [&](auto&& opt) {
                                            return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                                auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                                jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                  double(err.code()));
                                                return jsErr;
                                            }(*FWD(opt)));
                                        }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UserAPIKeyProviderClient_fetch_api_key([[maybe_unused]] jsi::Runtime& _env,
                                                  [[maybe_unused]] const jsi::Value& thisValue,
                                                  [[maybe_unused]] const jsi::Value* args,
                                                  [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UserAPIKeyProviderClient&>::extract(_env, args[0])))
                       .fetch_api_key(
                           ObjectId(args[1].toString(_env).utf8(_env)), JS_TO_SHARED_User(_env, args[2]),
                           util::UniqueFunction<void(app::App::UserAPIKey&&, std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[3].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](app::App::UserAPIKey&& apiKey,
                                                                      std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env,
                                       {STRUCT_TO_JS_UserAPIKey(_env, FWD(apiKey)), [&](auto&& opt) {
                                            return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                                auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                                jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                  double(err.code()));
                                                return jsErr;
                                            }(*FWD(opt)));
                                        }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UserAPIKeyProviderClient_fetch_api_keys([[maybe_unused]] jsi::Runtime& _env,
                                                   [[maybe_unused]] const jsi::Value& thisValue,
                                                   [[maybe_unused]] const jsi::Value* args,
                                                   [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UserAPIKeyProviderClient&>::extract(_env, args[0])))
                       .fetch_api_keys(
                           JS_TO_SHARED_User(_env, args[1]),
                           util::UniqueFunction<void(std::vector<app::App::UserAPIKey>&&,
                                                     std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[2].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::vector<app::App::UserAPIKey>&& apiKeys,
                                                                      std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env,
                                       {[&](auto&& vec) {
                                            auto out = jsi::Array(_env, vec.size());
                                            size_t i = 0;
                                            for (auto&& e : vec) {
                                                out.setValueAtIndex(_env, i++, STRUCT_TO_JS_UserAPIKey(_env, e));
                                            }
                                            return out;
                                        }(FWD(apiKeys)),
                                        [&](auto&& opt) {
                                            return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                                auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                                jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                  double(err.code()));
                                                return jsErr;
                                            }(*FWD(opt)));
                                        }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UserAPIKeyProviderClient_delete_api_key([[maybe_unused]] jsi::Runtime& _env,
                                                   [[maybe_unused]] const jsi::Value& thisValue,
                                                   [[maybe_unused]] const jsi::Value* args,
                                                   [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UserAPIKeyProviderClient&>::extract(_env, args[0])))
                       .delete_api_key(
                           ObjectId(args[1].toString(_env).utf8(_env)), JS_TO_SHARED_User(_env, args[2]),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[3].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UserAPIKeyProviderClient_enable_api_key([[maybe_unused]] jsi::Runtime& _env,
                                                   [[maybe_unused]] const jsi::Value& thisValue,
                                                   [[maybe_unused]] const jsi::Value* args,
                                                   [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UserAPIKeyProviderClient&>::extract(_env, args[0])))
                       .enable_api_key(
                           ObjectId(args[1].toString(_env).utf8(_env)), JS_TO_SHARED_User(_env, args[2]),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[3].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value UserAPIKeyProviderClient_disable_api_key([[maybe_unused]] jsi::Runtime& _env,
                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                    [[maybe_unused]] const jsi::Value* args,
                                                    [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return (
            (void)((*(&HostRefWrapper<app::App::UserAPIKeyProviderClient&>::extract(_env, args[0])))
                       .disable_api_key(
                           ObjectId(args[1].toString(_env).utf8(_env)), JS_TO_SHARED_User(_env, args[2]),
                           util::UniqueFunction<void(std::optional<app::AppError>)>(
                               [_cb = std::make_shared<jsi::Function>(args[3].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](std::optional<app::AppError> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {[&](auto&& opt) {
                                           return !opt ? jsi::Value::undefined() : ([&](const app::AppError& err) {
                                               auto jsErr = jsi::JSError(_env, err.what()).value().getObject(_env);
                                               jsErr.setProperty(_env, RealmAddon::self->m_prop_code,
                                                                 double(err.code()));
                                               return jsErr;
                                           }(*FWD(opt)));
                                       }(FWD(err))})));
                               }))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
app::App::UserAPIKeyProviderClient& JS_TO_CLASS_UserAPIKeyProviderClient(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_UserApiKeyProviderClient_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<app::App::UserAPIKeyProviderClient&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_UserAPIKeyProviderClient(jsi::Runtime& _env, app::App::UserAPIKeyProviderClient val)
{

    return (*RealmAddon::self->m_cls_UserApiKeyProviderClient_ctor)
        .callAsConstructor(
            _env,
            {HostObjClassWrapper<app::App::UserAPIKeyProviderClient, app::App::UserAPIKeyProviderClient>::create(
                _env, std::move(val))});
}
std::function<std::shared_ptr<util::Logger>(util::Logger::Level)>& JS_TO_CLASS_LoggerFactory(jsi::Runtime& _env,
                                                                                             const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_LoggerFactory_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::function<std::shared_ptr<util::Logger>(util::Logger::Level)>&>::extract(
        _env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_LoggerFactory(jsi::Runtime& _env,
                                       std::function<std::shared_ptr<util::Logger>(util::Logger::Level)> val)
{

    return (*RealmAddon::self->m_cls_LoggerFactory_ctor)
        .callAsConstructor(
            _env,
            {HostObjClassWrapper<
                std::function<std::shared_ptr<util::Logger>(util::Logger::Level)>,
                std::function<std::shared_ptr<util::Logger>(util::Logger::Level)>>::create(_env, std::move(val))});
}
jsi::Value SyncManager_set_session_multiplexing([[maybe_unused]] jsi::Runtime& _env,
                                                [[maybe_unused]] const jsi::Value& thisValue,
                                                [[maybe_unused]] const jsi::Value* args,
                                                [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<SyncManager>&>::extract(_env, args[0])))
                           .set_session_multiplexing((args[1]).asBool())),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncManager_set_log_level([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<SyncManager>&>::extract(_env, args[0])))
                           .set_log_level(util::Logger::Level((args[1]).getNumber()))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncManager_set_logger_factory([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<SyncManager>&>::extract(_env, args[0])))
                           .set_logger_factory(JS_TO_CLASS_LoggerFactory(_env, args[1]))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncManager_set_user_agent([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<SyncManager>&>::extract(_env, args[0])))
                           .set_user_agent((args[1]).asString(_env).utf8(_env))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncManager_reconnect([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<SyncManager>&>::extract(_env, args[0]))).reconnect()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncManager_get_existing_active_session([[maybe_unused]] jsi::Runtime& _env,
                                                   [[maybe_unused]] const jsi::Value& thisValue,
                                                   [[maybe_unused]] const jsi::Value* args,
                                                   [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : JS_FROM_SHARED_SyncSession(_env, FWD(val));
        }((**(&HostRefWrapper<std::shared_ptr<SyncManager>&>::extract(_env, args[0])))
                   .get_existing_active_session((args[1]).asString(_env).utf8(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncManager_get_all_sessions_for([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& vec) {
            auto out = jsi::Array(_env, vec.size());
            size_t i = 0;
            for (auto&& e : vec) {
                out.setValueAtIndex(_env, i++, JS_FROM_SHARED_SyncSession(_env, e));
            }
            return out;
        }((**(&HostRefWrapper<std::shared_ptr<SyncManager>&>::extract(_env, args[0])))
                   .get_all_sessions_for(*JS_TO_SHARED_User(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncManager_has_existing_sessions([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(bool(
            (**(&HostRefWrapper<std::shared_ptr<SyncManager>&>::extract(_env, args[0]))).has_existing_sessions()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<SyncManager>& JS_TO_SHARED_SyncManager(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_SyncManager_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<SyncManager>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "SyncManager");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_SyncManager(jsi::Runtime& _env, std::shared_ptr<SyncManager> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_SyncManager_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<std::shared_ptr<SyncManager>, std::shared_ptr<SyncManager>>::create(
                               _env, std::move(val))});
}
ThreadSafeReference& JS_TO_CLASS_ThreadSafeReference(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_ThreadSafeReference_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<ThreadSafeReference&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_ThreadSafeReference(jsi::Runtime& _env, ThreadSafeReference val)
{

    return (*RealmAddon::self->m_cls_ThreadSafeReference_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<ThreadSafeReference, ThreadSafeReference>::create(_env, std::move(val))});
}
jsi::Value AsyncOpenTask_start([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<AsyncOpenTask>&>::extract(_env, args[0])))
                           .start(util::UniqueFunction<void(ThreadSafeReference, std::exception_ptr)>(
                               util::EventLoopDispatcher(
                                   [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                                    _thread = ThreadConfinementChecker()](ThreadSafeReference realm,
                                                                          std::exception_ptr error) -> void {
                                       _thread.assertOnSameThread();
                                       auto& _env = RealmAddon::self->m_rt;
                                       return ((void)(_cb->call(
                                           _env, {[&](auto&& val) {
                                                      return !val ? jsi::Value::null()
                                                                  : JS_FROM_CLASS_ThreadSafeReference(_env, FWD(val));
                                                  }(FWD(realm)),
                                                  [&](auto&& val) {
                                                      return !val ? jsi::Value::null()
                                                                  : toJsiException(_env, FWD(val));
                                                  }(FWD(error))})));
                                   })))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AsyncOpenTask_cancel([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<AsyncOpenTask>&>::extract(_env, args[0]))).cancel()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AsyncOpenTask_register_download_progress_notifier([[maybe_unused]] jsi::Runtime& _env,
                                                             [[maybe_unused]] const jsi::Value& thisValue,
                                                             [[maybe_unused]] const jsi::Value* args,
                                                             [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return bigIntFromU64(
            _env,
            (**(&HostRefWrapper<std::shared_ptr<AsyncOpenTask>&>::extract(_env, args[0])))
                .register_download_progress_notifier(util::EventLoopDispatcher(
                    [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                     _thread = ThreadConfinementChecker()](uint64_t transferred_bytes, uint64_t transferrable_bytes,
                                                           double progress_estimate) -> void {
                        _thread.assertOnSameThread();
                        auto& _env = RealmAddon::self->m_rt;
                        return ((void)(_cb->call(_env, {bigIntFromU64(_env, FWD(transferred_bytes)),
                                                        bigIntFromU64(_env, FWD(transferrable_bytes)),
                                                        jsi::Value(double(FWD(progress_estimate)))})));
                    })));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AsyncOpenTask_unregister_download_progress_notifier([[maybe_unused]] jsi::Runtime& _env,
                                                               [[maybe_unused]] const jsi::Value& thisValue,
                                                               [[maybe_unused]] const jsi::Value* args,
                                                               [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<AsyncOpenTask>&>::extract(_env, args[0])))
                           .unregister_download_progress_notifier(bigIntToU64(_env, jsi::Value(_env, args[1])))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value AsyncOpenTask_DOLLAR_resetSharedPtr([[maybe_unused]] jsi::Runtime& _env,
                                               [[maybe_unused]] const jsi::Value& thisValue,
                                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*(&HostRefWrapper<std::shared_ptr<AsyncOpenTask>&>::extract(_env, args[0]))).reset()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<AsyncOpenTask>& JS_TO_SHARED_AsyncOpenTask(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_AsyncOpenTask_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<AsyncOpenTask>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "AsyncOpenTask");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_AsyncOpenTask(jsi::Runtime& _env, std::shared_ptr<AsyncOpenTask> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_AsyncOpenTask_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<std::shared_ptr<AsyncOpenTask>, std::shared_ptr<AsyncOpenTask>>::create(
                      _env, std::move(val))});
}
jsi::Value SyncSession_wait_for_upload_completion([[maybe_unused]] jsi::Runtime& _env,
                                                  [[maybe_unused]] const jsi::Value& thisValue,
                                                  [[maybe_unused]] const jsi::Value* args,
                                                  [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0])))
                           .wait_for_upload_completion(util::UniqueFunction<void(Status)>(util::EventLoopDispatcher(
                               [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](Status err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {([&](const Status& status) -> jsi::Value {
                                           if (status.is_ok()) {
                                               return jsi::Value::undefined();
                                           }
                                           else {
                                               auto jsObj = jsi::Object(_env);
                                               jsObj.setProperty(_env, "isOk", status.is_ok());
                                               jsObj.setProperty(_env, "code", static_cast<int32_t>(status.code()));
                                               jsObj.setProperty(_env, "reason", status.reason());
                                               return jsObj;
                                           }
                                       }(FWD(err)))})));
                               })))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_wait_for_download_completion([[maybe_unused]] jsi::Runtime& _env,
                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                    [[maybe_unused]] const jsi::Value* args,
                                                    [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0])))
                           .wait_for_download_completion(util::UniqueFunction<void(Status)>(util::EventLoopDispatcher(
                               [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                                _thread = ThreadConfinementChecker()](Status err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env, {([&](const Status& status) -> jsi::Value {
                                           if (status.is_ok()) {
                                               return jsi::Value::undefined();
                                           }
                                           else {
                                               auto jsObj = jsi::Object(_env);
                                               jsObj.setProperty(_env, "isOk", status.is_ok());
                                               jsObj.setProperty(_env, "code", static_cast<int32_t>(status.code()));
                                               jsObj.setProperty(_env, "reason", status.reason());
                                               return jsObj;
                                           }
                                       }(FWD(err)))})));
                               })))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_register_progress_notifier([[maybe_unused]] jsi::Runtime& _env,
                                                  [[maybe_unused]] const jsi::Value& thisValue,
                                                  [[maybe_unused]] const jsi::Value* args,
                                                  [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 4)
            throw jsi::JSError(_env, "expected 3 arguments");
        return bigIntFromU64(
            _env, (**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0])))
                      .register_progress_notifier(
                          util::EventLoopDispatcher(
                              [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                               _thread = ThreadConfinementChecker()](uint64_t transferred_bytes,
                                                                     uint64_t transferrable_bytes,
                                                                     double progress_estimate) -> void {
                                  _thread.assertOnSameThread();
                                  auto& _env = RealmAddon::self->m_rt;
                                  return ((void)(_cb->call(_env, {bigIntFromU64(_env, FWD(transferred_bytes)),
                                                                  bigIntFromU64(_env, FWD(transferrable_bytes)),
                                                                  jsi::Value(double(FWD(progress_estimate)))})));
                              }),
                          SyncSession::ProgressDirection((args[2]).getNumber()), (args[3]).asBool()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_unregister_progress_notifier([[maybe_unused]] jsi::Runtime& _env,
                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                    [[maybe_unused]] const jsi::Value* args,
                                                    [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0])))
                           .unregister_progress_notifier(bigIntToU64(_env, jsi::Value(_env, args[1])))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_register_connection_change_callback([[maybe_unused]] jsi::Runtime& _env,
                                                           [[maybe_unused]] const jsi::Value& thisValue,
                                                           [[maybe_unused]] const jsi::Value* args,
                                                           [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return bigIntFromU64(
            _env, (**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0])))
                      .register_connection_change_callback(util::EventLoopDispatcher(
                          [_cb = std::make_shared<jsi::Function>(args[1].getObject(_env).getFunction(_env)),
                           _thread = ThreadConfinementChecker()](SyncSession::ConnectionState old_state,
                                                                 SyncSession::ConnectionState new_state) -> void {
                              _thread.assertOnSameThread();
                              auto& _env = RealmAddon::self->m_rt;
                              return ((void)(_cb->call(
                                  _env, {[&] {
                                             static_assert(sizeof(SyncSession::ConnectionState) <= sizeof(int32_t),
                                                           "we only support enums up to 32 bits");
                                             return jsi::Value(_env, int(FWD(old_state)));
                                         }(),
                                         [&] {
                                             static_assert(sizeof(SyncSession::ConnectionState) <= sizeof(int32_t),
                                                           "we only support enums up to 32 bits");
                                             return jsi::Value(_env, int(FWD(new_state)));
                                         }()})));
                          })));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_unregister_connection_change_callback([[maybe_unused]] jsi::Runtime& _env,
                                                             [[maybe_unused]] const jsi::Value& thisValue,
                                                             [[maybe_unused]] const jsi::Value* args,
                                                             [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0])))
                           .unregister_connection_change_callback(bigIntToU64(_env, jsi::Value(_env, args[1])))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_revive_if_needed([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return (
            (void)((**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0]))).revive_if_needed()),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_handle_reconnect([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return (
            (void)((**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0]))).handle_reconnect()),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_force_close([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                   [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0]))).force_close()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_SaltedFileIdent(jsi::Runtime& _env, const sync::SaltedFileIdent& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_ident, bigIntFromU64(_env, in.ident));
    out.setProperty(_env, RealmAddon::self->m_prop_salt, bigIntFromI64(_env, in.salt));
    return out;
}
jsi::Value SyncSession_get_file_ident([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return STRUCT_TO_JS_SaltedFileIdent(
            _env, (**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0]))).get_file_ident());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_state([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&] {
            static_assert(sizeof(SyncSession::State) <= sizeof(int32_t), "we only support enums up to 32 bits");
            return jsi::Value(
                _env, int((**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0]))).state()));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_connection_state([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&] {
            static_assert(sizeof(SyncSession::ConnectionState) <= sizeof(int32_t),
                          "we only support enums up to 32 bits");
            return jsi::Value(
                _env,
                int((**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0]))).connection_state()));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_user([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_SHARED_SyncUser(
            _env, (**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0]))).user());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_config([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return STRUCT_TO_JS_SyncConfig(
            _env, (**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0]))).config());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_full_realm_url([[maybe_unused]] jsi::Runtime& _env,
                                      [[maybe_unused]] const jsi::Value& thisValue,
                                      [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((**(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0]))).full_realm_url()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSession_DOLLAR_resetSharedPtr([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*(&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, args[0]))).reset()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
const std::shared_ptr<SyncSession>& JS_TO_SHARED_SyncSession(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_SyncSession_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<SyncSession>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "SyncSession");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_SyncSession(jsi::Runtime& _env, std::shared_ptr<SyncSession> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_SyncSession_ctor)
        .callAsConstructor(_env,
                           {HostObjClassWrapper<std::shared_ptr<SyncSession>, std::shared_ptr<SyncSession>>::create(
                               _env, std::move(val))});
}
std::function<SyncConfig::SSLVerifyCallback>& JS_TO_CLASS_SSLVerifyCallback(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_SslVerifyCallback_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::function<SyncConfig::SSLVerifyCallback>&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_SSLVerifyCallback(jsi::Runtime& _env, std::function<SyncConfig::SSLVerifyCallback> val)
{

    return (*RealmAddon::self->m_cls_SslVerifyCallback_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<std::function<SyncConfig::SSLVerifyCallback>,
                                       std::function<SyncConfig::SSLVerifyCallback>>::create(_env, std::move(val))});
}
jsi::Value SyncSubscriptionSet_make_mutable_copy([[maybe_unused]] jsi::Runtime& _env,
                                                 [[maybe_unused]] const jsi::Value& thisValue,
                                                 [[maybe_unused]] const jsi::Value* args,
                                                 [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_MutableSyncSubscriptionSet(
            _env, (*(&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))).make_mutable_copy());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSubscriptionSet_get_state_change_notification([[maybe_unused]] jsi::Runtime& _env,
                                                             [[maybe_unused]] const jsi::Value& thisValue,
                                                             [[maybe_unused]] const jsi::Value* args,
                                                             [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return (
            (void)((*(&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0])))
                       .get_state_change_notification(
                           sync::SubscriptionSet::State((args[1]).getNumber()),
                           util::UniqueFunction<void(std::optional<sync::SubscriptionSet::State>,
                                                     std::optional<Status>)>(
                               util::EventLoopDispatcher([_cb = std::make_shared<jsi::Function>(
                                                              args[2].getObject(_env).getFunction(_env)),
                                                          _thread = ThreadConfinementChecker()](
                                                             std::optional<sync::SubscriptionSet::State> new_state,
                                                             std::optional<Status> err) -> void {
                                   _thread.assertOnSameThread();
                                   auto& _env = RealmAddon::self->m_rt;
                                   return ((void)(_cb->call(
                                       _env,
                                       {[&](auto&& opt) {
                                            return !opt ? jsi::Value::undefined() : [&] {
                                                static_assert(sizeof(sync::SubscriptionSet::State) <= sizeof(int32_t),
                                                              "we only support enums up to 32 bits");
                                                return jsi::Value(_env, int(*FWD(opt)));
                                            }();
                                        }(FWD(new_state)),
                                        [&](auto&& opt) {
                                            return !opt ? jsi::Value::undefined()
                                                        : ([&](const Status& status) -> jsi::Value {
                                                              if (status.is_ok()) {
                                                                  return jsi::Value::undefined();
                                                              }
                                                              else {
                                                                  auto jsObj = jsi::Object(_env);
                                                                  jsObj.setProperty(_env, "isOk", status.is_ok());
                                                                  jsObj.setProperty(
                                                                      _env, "code",
                                                                      static_cast<int32_t>(status.code()));
                                                                  jsObj.setProperty(_env, "reason", status.reason());
                                                                  return jsObj;
                                                              }
                                                          }(*FWD(opt)));
                                        }(FWD(err))})));
                               })))),
            jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value STRUCT_TO_JS_SyncSubscription(jsi::Runtime& _env, const sync::Subscription& in)
{
    auto out = jsi::Object(_env);
    out.setProperty(_env, RealmAddon::self->m_prop_id,
                    (*RealmAddon::self->m_cls_ObjectId_ctor)
                        .callAsConstructor(_env, {([&](auto&& sd) {
                                               return jsi::String::createFromUtf8(
                                                   _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                           }(in.id.to_string()))}));
    out.setProperty(_env, RealmAddon::self->m_prop_createdAt, JS_FROM_CLASS_Timestamp(_env, in.created_at));
    out.setProperty(_env, RealmAddon::self->m_prop_updatedAt, JS_FROM_CLASS_Timestamp(_env, in.updated_at));
    out.setProperty(_env, RealmAddon::self->m_prop_name, [&](auto&& opt) {
        return !opt ? jsi::Value::undefined() : ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }(*FWD(opt)));
    }(in.name));
    out.setProperty(_env, RealmAddon::self->m_prop_objectClassName, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.object_class_name)));
    out.setProperty(_env, RealmAddon::self->m_prop_queryString, ([&](auto&& sd) {
                        return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()),
                                                           sd.size());
                    }(in.query_string)));
    return out;
}
jsi::Value SyncSubscriptionSet_find_by_name([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : [&](const auto& ptr) {
                if constexpr (requires { bool(ptr); }) { // support claiming that always-valid iterators are pointers.
                    REALM_ASSERT(bool(ptr) && "Must mark nullable pointers with Nullable<> in spec");
                }
                return STRUCT_TO_JS_SyncSubscription(_env, *ptr);
            }(FWD(val));
        }((*(&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0])))
                   .find(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSubscriptionSet_find_by_query([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : [&](const auto& ptr) {
                if constexpr (requires { bool(ptr); }) { // support claiming that always-valid iterators are pointers.
                    REALM_ASSERT(bool(ptr) && "Must mark nullable pointers with Nullable<> in spec");
                }
                return STRUCT_TO_JS_SyncSubscription(_env, *ptr);
            }(FWD(val));
        }((*(&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0])))
                   .find(JS_TO_CLASS_Query(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSubscriptionSet_refresh([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*(&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))).refresh()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSubscriptionSet_version([[maybe_unused]] jsi::Runtime& _env,
                                       [[maybe_unused]] const jsi::Value& thisValue,
                                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return bigIntFromI64(_env, (*(&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))).version());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSubscriptionSet_state([[maybe_unused]] jsi::Runtime& _env,
                                     [[maybe_unused]] const jsi::Value& thisValue,
                                     [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&] {
            static_assert(sizeof(sync::SubscriptionSet::State) <= sizeof(int32_t),
                          "we only support enums up to 32 bits");
            return jsi::Value(_env,
                              int((*(&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))).state()));
        }();
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSubscriptionSet_error_str([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }((*(&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))).error_str()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSubscriptionSet_size([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                    [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return jsi::Value(
            double(asSigned((*(&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))).size())));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value SyncSubscriptionSet_Symbol_iterator([[maybe_unused]] jsi::Runtime& _env,
                                               [[maybe_unused]] const jsi::Value& thisValue,
                                               [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");

        auto& self = (*(&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0])));
        auto jsIt = jsi::Object(_env);
        jsIt.setProperty(_env, "_keepAlive", args[0]);
        jsIt.setProperty(_env, "next",
                         jsi::Function::createFromHostFunction(
                             _env, RealmAddon::self->m_prop_next, 0,
                             [it = self.begin(), end = self.end()](
                                 [[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                                 [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count) mutable {
                                 auto ret = jsi::Object(_env);
                                 if (it == end) {
                                     ret.setProperty(_env, RealmAddon::self->m_prop_done, jsi::Value(true));
                                 }
                                 else {
                                     ret.setProperty(_env, RealmAddon::self->m_prop_value,
                                                     STRUCT_TO_JS_SyncSubscription(_env, *it));
                                     ++it;
                                 }
                                 return ret;
                             }));

        return jsIt;
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
sync::SubscriptionSet& JS_TO_CLASS_SyncSubscriptionSet(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_SyncSubscriptionSet_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_SyncSubscriptionSet(jsi::Runtime& _env, sync::SubscriptionSet val)
{

    return (*RealmAddon::self->m_cls_SyncSubscriptionSet_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<sync::SubscriptionSet, sync::SubscriptionSet>::create(_env, std::move(val))});
}
jsi::Value MutableSyncSubscriptionSet_clear([[maybe_unused]] jsi::Runtime& _env,
                                            [[maybe_unused]] const jsi::Value& thisValue,
                                            [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)((*static_cast<sync::MutableSubscriptionSet*>(
                            (&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))))
                           .clear()),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value MutableSyncSubscriptionSet_insert_or_assign_by_name([[maybe_unused]] jsi::Runtime& _env,
                                                               [[maybe_unused]] const jsi::Value& thisValue,
                                                               [[maybe_unused]] const jsi::Value* args,
                                                               [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 3)
            throw jsi::JSError(_env, "expected 2 arguments");
        return [&](auto&& tup) {
            auto out = jsi::Array(_env, 2);
            out.setValueAtIndex(_env, 0, [&](const auto& ptr) {
                if constexpr (requires { bool(ptr); }) { // support claiming that always-valid iterators are pointers.
                    REALM_ASSERT(bool(ptr) && "Must mark nullable pointers with Nullable<> in spec");
                }
                return STRUCT_TO_JS_SyncSubscription(_env, *ptr);
            }(std::get<0>(FWD(tup))));
            out.setValueAtIndex(_env, 1, jsi::Value(bool(std::get<1>(FWD(tup)))));
            return out;
        }((*static_cast<sync::MutableSubscriptionSet*>(
               (&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))))
                   .insert_or_assign(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)),
                                     JS_TO_CLASS_Query(_env, args[2])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value MutableSyncSubscriptionSet_insert_or_assign_by_query([[maybe_unused]] jsi::Runtime& _env,
                                                                [[maybe_unused]] const jsi::Value& thisValue,
                                                                [[maybe_unused]] const jsi::Value* args,
                                                                [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return [&](auto&& tup) {
            auto out = jsi::Array(_env, 2);
            out.setValueAtIndex(_env, 0, [&](const auto& ptr) {
                if constexpr (requires { bool(ptr); }) { // support claiming that always-valid iterators are pointers.
                    REALM_ASSERT(bool(ptr) && "Must mark nullable pointers with Nullable<> in spec");
                }
                return STRUCT_TO_JS_SyncSubscription(_env, *ptr);
            }(std::get<0>(FWD(tup))));
            out.setValueAtIndex(_env, 1, jsi::Value(bool(std::get<1>(FWD(tup)))));
            return out;
        }((*static_cast<sync::MutableSubscriptionSet*>(
               (&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))))
                   .insert_or_assign(JS_TO_CLASS_Query(_env, args[1])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value MutableSyncSubscriptionSet_erase_by_name([[maybe_unused]] jsi::Runtime& _env,
                                                    [[maybe_unused]] const jsi::Value& thisValue,
                                                    [[maybe_unused]] const jsi::Value* args,
                                                    [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(bool((*static_cast<sync::MutableSubscriptionSet*>(
                                    (&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))))
                                   .erase(RealmAddon::self->wrapString((args[1]).asString(_env).utf8(_env)))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value MutableSyncSubscriptionSet_erase_by_query([[maybe_unused]] jsi::Runtime& _env,
                                                     [[maybe_unused]] const jsi::Value& thisValue,
                                                     [[maybe_unused]] const jsi::Value* args,
                                                     [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 1 arguments");
        return jsi::Value(bool((*static_cast<sync::MutableSubscriptionSet*>(
                                    (&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))))
                                   .erase(JS_TO_CLASS_Query(_env, args[1]))));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value MutableSyncSubscriptionSet_commit([[maybe_unused]] jsi::Runtime& _env,
                                             [[maybe_unused]] const jsi::Value& thisValue,
                                             [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return JS_FROM_CLASS_SyncSubscriptionSet(
            _env, (*static_cast<sync::MutableSubscriptionSet*>(
                       (&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, args[0]))))
                      .commit());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
sync::MutableSubscriptionSet& JS_TO_CLASS_MutableSyncSubscriptionSet(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_MutableSyncSubscriptionSet_extractor).call(_env, &val, size_t(1));
    const auto ptr = static_cast<sync::MutableSubscriptionSet*>(
        (&HostRefWrapper<sync::SubscriptionSet&>::extract(_env, external)));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_MutableSyncSubscriptionSet(jsi::Runtime& _env, sync::MutableSubscriptionSet val)
{

    return (*RealmAddon::self->m_cls_MutableSyncSubscriptionSet_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<sync::MutableSubscriptionSet, sync::SubscriptionSet>::create(
                                     _env, std::move(val))});
}
const std::shared_ptr<util::Scheduler>& JS_TO_SHARED_Scheduler(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_Scheduler_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<util::Scheduler>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "Scheduler");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_Scheduler(jsi::Runtime& _env, std::shared_ptr<util::Scheduler> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_Scheduler_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<std::shared_ptr<util::Scheduler>, std::shared_ptr<util::Scheduler>>::create(
                      _env, std::move(val))});
}
const std::shared_ptr<app::GenericNetworkTransport>& JS_TO_SHARED_GenericNetworkTransport(jsi::Runtime& _env,
                                                                                          const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_GenericNetworkTransport_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::shared_ptr<app::GenericNetworkTransport>&>::extract(_env, external));
    if (!*ptr)
        throwNullSharedPtrError(_env, "GenericNetworkTransport");
    return *ptr;
}
jsi::Value JS_FROM_SHARED_GenericNetworkTransport(jsi::Runtime& _env,
                                                  std::shared_ptr<app::GenericNetworkTransport> val)
{
    REALM_ASSERT(bool(val) && "Must mark nullable pointers with Nullable<> in spec");
    return (*RealmAddon::self->m_cls_GenericNetworkTransport_ctor)
        .callAsConstructor(
            _env, {HostObjClassWrapper<std::shared_ptr<app::GenericNetworkTransport>,
                                       std::shared_ptr<app::GenericNetworkTransport>>::create(_env, std::move(val))});
}
jsi::Value JsPlatformHelpers_set_default_realm_file_directory([[maybe_unused]] jsi::Runtime& _env,
                                                              [[maybe_unused]] const jsi::Value& thisValue,
                                                              [[maybe_unused]] const jsi::Value* args,
                                                              [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(JsPlatformHelpers::set_default_realm_file_directory((args[0]).asString(_env).utf8(_env))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_default_realm_file_directory([[maybe_unused]] jsi::Runtime& _env,
                                                          [[maybe_unused]] const jsi::Value& thisValue,
                                                          [[maybe_unused]] const jsi::Value* args,
                                                          [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 0)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }(JsPlatformHelpers::default_realm_file_directory()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_ensure_directory_exists_for_file([[maybe_unused]] jsi::Runtime& _env,
                                                              [[maybe_unused]] const jsi::Value& thisValue,
                                                              [[maybe_unused]] const jsi::Value* args,
                                                              [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(JsPlatformHelpers::ensure_directory_exists_for_file((args[0]).asString(_env).utf8(_env))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_copy_bundled_realm_files([[maybe_unused]] jsi::Runtime& _env,
                                                      [[maybe_unused]] const jsi::Value& thisValue,
                                                      [[maybe_unused]] const jsi::Value* args,
                                                      [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 0)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ((void)(JsPlatformHelpers::copy_bundled_realm_files()), jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_remove_realm_files_from_directory([[maybe_unused]] jsi::Runtime& _env,
                                                               [[maybe_unused]] const jsi::Value& thisValue,
                                                               [[maybe_unused]] const jsi::Value* args,
                                                               [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(JsPlatformHelpers::remove_realm_files_from_directory((args[0]).asString(_env).utf8(_env))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_remove_file([[maybe_unused]] jsi::Runtime& _env,
                                         [[maybe_unused]] const jsi::Value& thisValue,
                                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(JsPlatformHelpers::remove_file((args[0]).asString(_env).utf8(_env))), jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_remove_directory([[maybe_unused]] jsi::Runtime& _env,
                                              [[maybe_unused]] const jsi::Value& thisValue,
                                              [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return ((void)(JsPlatformHelpers::remove_directory((args[0]).asString(_env).utf8(_env))),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_exclude_from_icloud_backup([[maybe_unused]] jsi::Runtime& _env,
                                                        [[maybe_unused]] const jsi::Value& thisValue,
                                                        [[maybe_unused]] const jsi::Value* args,
                                                        [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 2)
            throw jsi::JSError(_env, "expected 2 arguments");
        return ((void)(JsPlatformHelpers::exclude_from_icloud_backup((args[0]).asString(_env).utf8(_env),
                                                                     (args[1]).asBool())),
                jsi::Value::undefined());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value JsPlatformHelpers_get_cpu_arch([[maybe_unused]] jsi::Runtime& _env,
                                          [[maybe_unused]] const jsi::Value& thisValue,
                                          [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 0)
            throw jsi::JSError(_env, "expected 0 arguments");
        return ([&](auto&& sd) {
            return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
        }(JsPlatformHelpers::get_cpu_arch()));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
JsPlatformHelpers& JS_TO_CLASS_JsPlatformHelpers(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_JsPlatformHelpers_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<JsPlatformHelpers&>::extract(_env, external));

    return *ptr;
}
jsi::Value WeakSyncSession_raw_dereference([[maybe_unused]] jsi::Runtime& _env,
                                           [[maybe_unused]] const jsi::Value& thisValue,
                                           [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 0 arguments");
        return [&](auto&& val) {
            return !val ? jsi::Value::null() : JS_FROM_SHARED_SyncSession(_env, FWD(val));
        }((*(&HostRefWrapper<std::weak_ptr<SyncSession>&>::extract(_env, args[0]))).lock());
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value WeakSyncSession_weak_copy_of([[maybe_unused]] jsi::Runtime& _env,
                                        [[maybe_unused]] const jsi::Value& thisValue,
                                        [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 arguments");
        return JS_FROM_CLASS_WeakSyncSession(_env,
                                             std::weak_ptr<SyncSession>(JS_TO_SHARED_SyncSession(_env, args[0])));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
std::weak_ptr<SyncSession>& JS_TO_CLASS_WeakSyncSession(jsi::Runtime& _env, const jsi::Value& val)
{
    auto external = (*RealmAddon::self->m_cls_WeakSyncSession_extractor).call(_env, &val, size_t(1));
    const auto ptr = (&HostRefWrapper<std::weak_ptr<SyncSession>&>::extract(_env, external));

    return *ptr;
}
jsi::Value JS_FROM_CLASS_WeakSyncSession(jsi::Runtime& _env, std::weak_ptr<SyncSession> val)
{

    return (*RealmAddon::self->m_cls_WeakSyncSession_ctor)
        .callAsConstructor(_env, {HostObjClassWrapper<std::weak_ptr<SyncSession>, std::weak_ptr<SyncSession>>::create(
                                     _env, std::move(val))});
}
jsi::Value JS_FROM_Mixed(jsi::Runtime& _env, Mixed val)
{
    if (val.is_null())
        return jsi::Value::null();
    switch (val.get_type()) {

        case DataType::Type::Int:
            return bigIntFromI64(_env, val.get_int());


        case DataType::Type::Bool:
            return jsi::Value(bool(val.get_bool()));


        case DataType::Type::Float:
            return (*RealmAddon::self->m_cls_Float_ctor)
                .callAsConstructor(_env, {jsi::Value(double(val.get_float()))});


        case DataType::Type::Double:
            return jsi::Value(double(val.get_double()));


        case DataType::Type::String:
            return ([&](auto&& sd) {
                return jsi::String::createFromUtf8(_env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
            }(val.get_string()));


        case DataType::Type::Binary:
            return ([&](const auto& bd) -> jsi::Value {
                auto arr = (*RealmAddon::self->m_cls_ArrayBuffer_ctor)
                               .callAsConstructor(_env, int(bd.size()))
                               .getObject(_env)
                               .getArrayBuffer(_env);
                memcpy(arr.data(_env), bd.data(), bd.size());
                return arr;
            }(val.get_binary()));


        case DataType::Type::Timestamp:
            return JS_FROM_CLASS_Timestamp(_env, val.get_timestamp());


        case DataType::Type::Decimal:
            return (*RealmAddon::self->m_cls_Decimal128_ctor)
                .callAsConstructor(_env, {([&](auto&& sd) {
                                       return jsi::String::createFromUtf8(
                                           _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                   }(val.get_decimal().to_string()))});


        case DataType::Type::ObjectId:
            return (*RealmAddon::self->m_cls_ObjectId_ctor)
                .callAsConstructor(_env, {([&](auto&& sd) {
                                       return jsi::String::createFromUtf8(
                                           _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                   }(val.get_object_id().to_string()))});


        case DataType::Type::UUID:
            return (*RealmAddon::self->m_cls_UUID_ctor)
                .callAsConstructor(_env, {([&](auto&& sd) {
                                       return jsi::String::createFromUtf8(
                                           _env, reinterpret_cast<const uint8_t*>(sd.data()), sd.size());
                                   }(val.get_uuid().to_string()))});


        case DataType::Type::TypedLink:
            return JS_FROM_CLASS_ObjLink(_env, val.get_link());


        case DataType::Type::Link:
            return bigIntFromI64(_env, (val.get<ObjKey>()).value);


            // Silence these warnings as they might be confusing to developers as they build the binding

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wswitch"

        // We are returning sentinel values for lists and dictionaries in the
        // form of Symbol singletons. This is due to not being able to construct
        // the actual list or dictionary in the current context.
        case realm::type_List:
            return (*RealmAddon::self->m_cls_Symbol_for_ctor).call(_env, "Realm.List");

        case realm::type_Dictionary:
            return (*RealmAddon::self->m_cls_Symbol_for_ctor).call(_env, "Realm.Dictionary");

#pragma GCC diagnostic pop

        // The remaining cases are never stored in a Mixed.
        case DataType::Type::Mixed:
            break;
    }
    REALM_UNREACHABLE();
}
Mixed JS_TO_Mixed(jsi::Runtime& _env, auto&& val)
{
    if (val.isNull())
        return Mixed();
    if (val.isString())
        return RealmAddon::self->wrapString((val).asString(_env).utf8(_env));
    if (val.isNumber())
        return (val).asNumber();
    if (val.isBigInt())
        return bigIntToI64(_env, jsi::Value(_env, val));
    if (val.isBool())
        return (val).asBool();
    if (val.isObject()) {
        auto obj = std::move(val).asObject(_env);
        if (obj.isArrayBuffer(_env)) {
            return ([&](auto&& v) -> BinaryData {
                auto buf = FWD(v).asObject(_env).getArrayBuffer(_env);
                auto data = buf.data(_env);
                return BinaryData(data ? reinterpret_cast<const char*>(data) : "", buf.length(_env));
            })(jsi::Value(std::move(obj)));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Obj_ctor))) {
            return JS_TO_CLASS_Obj(_env, jsi::Value(std::move(obj)));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Timestamp_ctor))) {
            return JS_TO_CLASS_Timestamp(_env, jsi::Value(std::move(obj)));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Float_ctor))) {
            return float((jsi::Value(std::move(obj)))
                             .asObject(_env)
                             .getProperty(_env, RealmAddon::self->m_prop_value)
                             .asNumber());
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_ObjLink_ctor))) {
            return JS_TO_CLASS_ObjLink(_env, jsi::Value(std::move(obj)));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_ObjectId_ctor))) {
            return ObjectId(jsi::Value(std::move(obj)).toString(_env).utf8(_env));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Decimal128_ctor))) {
            return Decimal128(jsi::Value(std::move(obj)).toString(_env).utf8(_env));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_UUID_ctor))) {
            return UUID(jsi::Value(std::move(obj)).toString(_env).utf8(_env));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Long_ctor))) {
            return bigIntToI64(_env, jsi::Value(_env, jsi::Value(std::move(obj))));
        }
        else if (obj.instanceOf(_env, (*RealmAddon::self->m_cls_Geospatial_ctor))) {
            // This needs its own case because the constructor of Mixed for Geospatial requires a pointer
            return &JS_TO_CLASS_Geospatial(_env, jsi::Value(std::move(obj)));
        }
        else if (obj.isFunction(_env)) {
            throw jsi::JSError(_env, "Unable to convert a function to a Mixed");
        }
        else if (obj.isHostObject(_env)) {
            throw jsi::JSError(_env, "Unable to convert a native host object to a Mixed");
        }

        // TODO should we check for "boxed" values like 'new Number(1)'?

        const auto ctorName =
            obj.getProperty(_env, "constructor").getObject(_env).getProperty(_env, "name").asString(_env).utf8(_env);
        throw jsi::JSError(_env, "Unable to convert an object with ctor '" + ctorName + "' to a Mixed");
    }
    // NOTE: must not treat undefined as null here, because that makes optional<Mixed> ambiguous.
    throw jsi::JSError(_env, "Can't convert " + val.toString(_env).utf8(_env) + " to Mixed");
}
int64_t bigIntToI64(jsi::Runtime& _env, auto&& val)
{
    if (val.isBigInt())
        return FWD(val).asBigInt(_env).asInt64(_env);

    auto obj = FWD(val).asObject(_env);
    auto high = uint32_t(int32_t(obj.getProperty(_env, RealmAddon::self->m_prop_high).asNumber()));
    auto low = uint32_t(int32_t(obj.getProperty(_env, RealmAddon::self->m_prop_low).asNumber()));
    return (int64_t(high) << 32) | low;
}
uint64_t bigIntToU64(jsi::Runtime& _env, auto&& val)
{
    if (val.isBigInt())
        return FWD(val).asBigInt(_env).asUint64(_env);

    auto obj = FWD(val).asObject(_env);
    auto high = uint32_t(int32_t(obj.getProperty(_env, RealmAddon::self->m_prop_high).asNumber()));
    auto low = uint32_t(int32_t(obj.getProperty(_env, RealmAddon::self->m_prop_low).asNumber()));
    return (uint64_t(high) << 32) | low;
}
jsi::Value bigIntFromI64(jsi::Runtime& _env, int64_t val)
{
    if (RealmAddon::self->m_on_hermes)
        return jsi::BigInt::fromInt64(_env, val);

    return (*RealmAddon::self->m_cls_Long_ctor)
        .callAsConstructor(_env, {
                                     jsi::Value(int(val)),       // low
                                     jsi::Value(int(val >> 32)), // high
                                     jsi::Value(false),          // unsigned
                                 });
}
jsi::Value bigIntFromU64(jsi::Runtime& _env, uint64_t val)
{
    if (RealmAddon::self->m_on_hermes)
        return jsi::BigInt::fromUint64(_env, val);

    return (*RealmAddon::self->m_cls_Long_ctor)
        .callAsConstructor(_env, {
                                     jsi::Value(int(val)),       // low
                                     jsi::Value(int(val >> 32)), // high
                                     jsi::Value(true),           // unsigned
                                 });
}
jsi::Value createWeakRef([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                         [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 argument");
        if (!args[0].isObject())
            throw jsi::JSError(_env, "expected an object");
        return jsi::Object::createFromHostObject(_env,
                                                 std::make_shared<WeakObjectWrapper>(_env, args[0].getObject(_env)));
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}
jsi::Value lockWeakRef([[maybe_unused]] jsi::Runtime& _env, [[maybe_unused]] const jsi::Value& thisValue,
                       [[maybe_unused]] const jsi::Value* args, [[maybe_unused]] size_t count)
{
    const auto callBlock = RealmAddon::self->startCall();
    try {

        if (count != 1)
            throw jsi::JSError(_env, "expected 1 argument");
        if (!args[0].isObject())
            throw jsi::JSError(_env, "expected an object");
        auto obj = args[0].getObject(_env);
        if (!obj.isHostObject<WeakObjectWrapper>(_env))
            throw jsi::JSError(_env, "expected a WeakObjectWrapper");
        return std::move(obj).getHostObject<WeakObjectWrapper>(_env)->ref.lock(_env);
    }
    catch (const std::exception& ex) {
        throwJsiException(_env, ex);
    }
}

} // namespace

extern "C" {
void realm_jsi_invalidate_caches()
{
    // Clear the default logger, to prevent it from holding on to a pointer that was released
    realm::util::LogCategory::get_category(realm::util::LogCategory::realm.get_name())
        .set_default_level_threshold(realm::util::Logger::Level::off);
    realm::util::Logger::set_default_logger(nullptr);
    // Close all cached Realms
    realm::_impl::RealmCoordinator::clear_all_caches();
    // Clear the Object Store App cache, to prevent instances from using a context that was released
    realm::app::App::clear_cached_apps();
    // Blow away the addon state.
    RealmAddon::self.reset();
}
void realm_jsi_init(jsi::Runtime& rt, jsi::Object& exports)
{
    realm_jsi_invalidate_caches();
    RealmAddon::self = std::make_unique<RealmAddon>(rt, exports);
}
void realm_jsi_close_sync_sessions()
{
    // Force all sync sessions to close immediately. This prevents the new JS thread
    // from opening a new sync session while the old one is still active when reloading
    // in dev mode.
    realm::app::App::close_all_sync_sessions();
}
} // extern "C"

} // namespace realm::js::JSI
